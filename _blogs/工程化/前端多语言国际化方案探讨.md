---
title: 前端多语言国际化方案探讨
author: yrobot
keywords: 前端,多语言,切换,国际化,探讨,international
createTime: 2022年08月30日
---

## 国际化需求的基本场景

我目前运营着一个 figma 的插件 Figma-Nocode，他主要是帮助使用者将设计稿转化为前端页面文件。

但是通过埋点，我发现目前主要的使用用户都是国外的用户，中文使用者比例很少。

而目前的插件使用的主要语言是中文，这对大部分国外用户的使用体验是有很大的打击的，为了提升这部分用户的使用体验，页面就需要进行英文版的支持。

且由于后期运营主要市场可能还是国内，所以中文也要予以保留，页面最好可以根据用户的语言设置来自动切换展示语言。

这就是我面临的最基本的一个国际化需求。

## 一个实现国际化的基本框架设想

其实 国际化的本质和主题没有太大的区别，都是基于一个唯一的 key 进行配置内容的分发，将内容通过状态管理等手段通知到各个组件，进行更新。

### 此想法的核心伪代码

`locales.ts`

```ts
export default const locales = {
  en: {
    "home.title": "Hello World!",
    "home.form": { title: "Fill In Your Info", button: "Submit" },
  },
  zh: {
    "home.title": "你好 世界！",
    "home.form": { title: "填写你的信息", button: "提交" },
  },
};
```

`Translate.tsx`

```tsx
import React, { useState, useContext } from "react";
import locales from "locales.ts";

const I18NContext = React.createContext();

const LANGUAGE_KEY = "_local";
export const LanguageProvider = ({ children }) => {
  const [locale, setLocale] = useState(
    localStorage.getItem(LANGUAGE_KEY) || "zh"
  );

  const set = (locale) => {
    setLocale(locale);
    localStorage.setItem(LANGUAGE_KEY, locale);
  };

  return (
    <I18NContext.Provider value={[locales[locale], set, locale]}>
      {children}
    </I18NContext.Provider>
  );
};

export function useLocal(key) {
  const [locale, setLocale, locale] = useContext(I18NContext);
  return [locale[key], setLocale, locale];
}

export const T = ({ children }: { children: string }) => useLocal(children);
```

`Home.tsx`

```ts
import React from "react";
import { T, LanguageProvider, useLocal } from "Translate.tsx";

const Title = () => <T>home.title</T>;

const Form = () => {
  const [lan, updateLan] = useLocal("home.form");
  return (
    <>
      <form>
        <h1>{lan.title}</h1>
        <button>{lan.button}</button>
      </form>

      <button
        onClick={() => {
          updateLan("en");
        }}
      >
        Change Language
      </button>
    </>
  );
};

const Home = () => (
  <>
    <Title />
    <Form />
  </>
);

export default () => (
  <LanguageProvider>
    <Home />
  </LanguageProvider>
);
```

这其实就是目前 Yrobot‘s Blog 的国际化解决方案

### 这其实也是 react-i18next 核心逻辑

### 此方案存在的问题

#### SSR 和 SSG 场景会出现闪屏的情况

SSR 和 SSG 是在服务端生成 HTML，加载完 html 和 css 文件后即可展示首屏。

而语言的切换逻辑是在 client 端进行的，本地检测逻辑检测到当前浏览器语言环境是 另一种语言，或者发现用户之前设置过三方语言，那么运行语言切换逻辑对页面进行 重渲染。从而出现闪屏的现象

#### SEO 不友好

SEO 能探测到的永远是默认语言环境的页面信息

## SSR 和 SSG 场景怎么更好的处理国际化

由于 SSR 的方案最大的区别是在服务端生成 html，为了规避闪屏现象，那么就应该针对不同的语言生成对应的 html，如：

- ch -> index.ch.html
- en -> index.en.html

下一步就是针对用户页面请求分发对应语言的 html。

这一步遇到的一个大问题就是，怎么根据请求获取当前用户的语言设置。

- 利用请求 http 协议  
  在 http 协议下，可以获取用户语言配置信息主要是 [Accept-Language](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language)，所以最好的方案应该是服务端利用 Accept-Language 对返回 html 内容进行分发。

- client 设置请求信息，将语言数据放入请求中
  - 域名
  - 路由
  - cookie

从对业务和工程化影响来看，我们可以从 客户端修改能力 和 部署要求 来分析这几个方案：

|                           | 客户端修改 | 部署要求 |
| ------------------------- | ---------- | -------- |
| 利用 Accept-Language 分发 | ---------- | -------- |
| 利用 域名 分发            | ---------- | -------- |
| 利用 路由 分发            | ---------- | -------- |
| 利用 cookie 分发          | ---------- | -------- |

## 一些 Next.js 的 国际化方案分析

### Next.js 自带的 国际化路由 能力

#### 支持的国际化策略
