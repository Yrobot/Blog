{"pageProps":{"pre":{"path":"_blogs/SPA/react的状态管理/利用props状态提升.md","url":"/blog/SPA/react的状态管理/利用props状态提升","title":"react的状态管理—利用props状态提升","author":"yrobot","keywords":"状态管理,props,react,状态,提升,利用","createTime":1537200000000,"length":2341,"content":"<p><strong>本页目录：</strong><br><a href=\"#index\">场景思考</a><br><a href=\"#props\">利用props状态提升</a><br><a href=\"#result\">查看效果</a><br><a href=\"#code\">查看代码</a>  </p>\n<p><a id='index'></a></p>\n<h2 id=\"场景思考\">场景思考</h2>\n<p>现在我们用react去写一篇博客<br>博客包含 <code>标题</code> 和 <code>内容</code><br>而我期望<code>标题</code>和<code>内容</code>的颜色可以一键修改  </p>\n<p>当然最暴力的实现方式就是利用dom操作去被动的修改<br>但是有没有更优雅更可控的方式呢？  </p>\n<p>首先来看看项目的组件树：<br><img src=\"https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg\" alt=\"\"></p>\n<p>那么有什么好的优雅的方式使<code>Title</code>和<code>Content</code>的颜色保持一致呢？<br>换句话说，怎么更好的管理<code>Title</code>和<code>Content</code>的状态呢？  </p>\n<p><a id='props'></a></p>\n<h2 id=\"利用props状态提升\">利用props状态提升</h2>\n<p>学习了react，就知道组件间数据交互最普遍的方式就是利用props传递<br>而目我们要做的就是Title和Content引用的是同一个颜色变量，而且在变量改变时组件自动重新渲染<br>利用react最基础的方法就是利用状态提升:<br>把一些共享的状态放在最顶端的组件中，子组件通过props去访问和修改这些状态  </p>\n<p>本场景中需要共享的状态只有一个<code>mainColor</code>和一个修改mainColor的函数<code>changeMainColor()</code><br>具体流程如下图：<br><img src=\"https://ws1.sinaimg.cn/large/006tNbRwgy1fvexnc4cbcj30ss0poacx.jpg\" alt=\"\">\n\b可以看到，需要在content和title中用mainColor，需要通过组件props层层传递到需要用状态的组件，函数也是同理  </p>\n<p><a id='result'></a></p>\n<h2 id=\"查看效果\">查看效果</h2>\n<ol>\n<li><img src=\"https://ws3.sinaimg.cn/large/006tNbRwgy1fvey3e0sw6j31kw0lmdoe.jpg\" alt=\"\"></li>\n<li><img src=\"https://ws1.sinaimg.cn/large/006tNbRwgy1fvey3n6qu4j31kw0n1aju.jpg\" alt=\"\"></li>\n<li><img src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fvey3xqxwpj31kw0nntin.jpg\" alt=\"\"></li>\n</ol>\n<p><a id='code'></a></p>\n<h2 id=\"查看代码\">查看代码</h2>\n<p>BlogPage中定义全局状态mainColor和方法changeMainColor()并传递： </p>\n<pre><code>class BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            mainColor: &#39;black&#39;\n        }\n    }\n    changeMainColor = (color) =&gt; {\n        this.setState({\n            mainColor: color\n        })\n    }\n    render() {\n        const { mainColor } = this.state;\n        return (\n            &lt;div className=&quot;blogContainer&quot;&gt;\n                &lt;Header mainColor={mainColor}&gt;&lt;/Header&gt;\n                &lt;Main mainColor={mainColor} changeMainColor={this.changeMainColor}&gt;&lt;/Main&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n</code></pre>\n<p>Content组件中使用props传递的数据和方法：</p>\n<pre><code>class Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    randomColor = () =&gt; {\n        this.props.changeMainColor(&#39;#&#39; + (Math.random() * 0xffffff &lt;&lt; 0).toString(16));\n    }\n    render() {\n        const {mainColor}=this.props;\n        return (\n            &lt;div className=&quot;content&quot; style={{color:mainColor}}&gt;\n                内容...\n                &lt;div className=&quot;button&quot; onClick={this.randomColor}&gt;切换颜色&lt;/div&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n</code></pre>\n<hr>\n<p><em>\b本章节部分参考<a href=\"http://huziketang.mangojuice.top/books/react/lesson29\">React.js 小书</a>，在此感谢！</em></p>\n"},"blog":{"path":"_blogs/HTML&CSS/利用css绘制多边形/README.md","url":"/blog/HTML&CSS/利用css绘制多边形","title":"利用css绘制多边形","author":"yrobot","keywords":"css,多边形,绘制,利用","createTime":1535904000000,"length":6999,"content":"<p>本文主要讲解内容：  </p>\n<ol>\n<li>css绘制多边形的原理(一定要理解)  </li>\n<li>一些简单多边形的绘制示例  </li>\n</ol>\n<p><strong>本页目录：</strong><br><a href=\"#id1\">css绘制多边形的原理</a>  </p>\n<ul>\n<li><a href=\"#id11\">首先我们要知道css盒模型是什么样的</a></li>\n<li><a href=\"#id12\">然后我们还要理解border</a></li>\n<li><a href=\"#id13\">还要会用css伪元素</a></li>\n</ul>\n<p><a href=\"#id2\">css绘制正四边形</a><br><a href=\"#id3\">css绘制非正四边形</a><br><a href=\"#id4\">css绘制三角形</a><br><a href=\"#id5\">css绘制圆形</a><br><a href=\"#id6\">css绘制梯形</a><br><a href=\"#id7\">css绘制正五边形</a><br><a href=\"#id8\">css绘制正七边形</a>  </p>\n<p><a id='id1'></a></p>\n<h2 id=\"css绘制多边形的原理\">css绘制多边形的原理</h2>\n<p><a href=\"\" id=\"id11\"></a></p>\n<h3 id=\"首先我们要知道css盒模型是什么样的\"><strong>首先我们要知道css盒模型是什么样的</strong></h3>\n<p><img src=\"https://ws3.sinaimg.cn/large/0069RVTdgy1fuw4xid010j30a809aq38.jpg\" alt=\"\"><br>所谓的盒模型，可以理解为元素的表现内容，看上图可以发现：  </p>\n<pre><code>盒模型 = 内容 + padding + border + margin    \n</code></pre>\n<p>组成理解(<em>简单介绍</em> )：<br><code>内容</code> 元素内 文本、内元素 所包含的区域<br><code>padding</code> \b 内容 与 border 之间的距离，用于处理border和内容的表现关系<br><code>border</code>  边框，将内容包围的轮廓<br><code>margin</code>  元素 与 其他元素之间的距离，用于处理元素间的表现关系，位置样式  </p>\n<p>一般理解的 元素 由 内容、padding、border 组成，因为这3个影响到元素的表现样式。<br>css2中<code>width</code>的默认指向是内容宽度，而不是元素(包括padding、border)的宽度。<br>\b可以 利用 <code>box-sizing</code> 去修改width的指向：  </p>\n<ul>\n<li><code>box-sizing: content-box;</code> width、height指向内容<br>  <img src=\"https://ws2.sinaimg.cn/large/0069RVTdgy1fuw5olkw8wj303o010mx2.jpg\" alt=\"\"></li>\n<li><code>box-sizing: border-box;</code> width、height指向一般元素<br>  <img src=\"https://ws1.sinaimg.cn/large/0069RVTdgy1fuw5p6zb80j305q04wdgb.jpg\" alt=\"\"></li>\n</ul>\n<p>看下结果：<em>语言:stylus</em>    </p>\n<pre><code>.boxsize1\n    width 100px\n    height 80px\n    background-color #393\n    border 20px solid #999\n.boxsize2\n    width 100px\n    height 80px\n    background-color #393\n    border 20px solid #999\n    box-sizing border-box  //默认元素宽高指定，内容宽高自适应\n</code></pre>\n<p><img src=\"https://ws4.sinaimg.cn/large/0069RVTdgy1fuw6rtydjoj30ci0egweo.jpg\" alt=\"\">  </p>\n<p>本章我们就要利用元素的表现样式(内容、padding、border  )进行图形绘制<br><a href=\"\" id=\"id12\"></a></p>\n<h3 id=\"然后我们还要理解border\"><strong>然后我们还要理解border</strong></h3>\n<p>我们先来看一段有趣的代码：  </p>\n<pre><code>.square1 {\n  width: 0px;\n  height: 0px;\n  border-width: 40px 50px;\n  border-style: solid;\n  border-color: #f00 #008000 #808080 #00f;\n}\n</code></pre>\n<p>想想一下，这段代码的渲染效果是什么样的?<br>css是怎么处理border重叠的部分的？ \n好了，想清楚了，就来看一下结果吧。<br><img src=\"https://ws3.sinaimg.cn/large/0069RVTdgy1fuw65nqy85j309001u0sr.jpg\" alt=\"\"><br><img src=\"https://ws4.sinaimg.cn/large/0069RVTdgy1fuw60spn4lj306i05g0sm.jpg\" alt=\"\"><br>他的盒模型：<br><img src=\"https://ws4.sinaimg.cn/large/0069RVTdgy1fuw62e6752j307y05umxa.jpg\" alt=\"\"><br>可以得出规律：</p>\n<ol>\n<li>border的长 = 盒模型对应的长或宽  </li>\n<li>相邻方向border冲突时，进行等比均分。 </li>\n</ol>\n<p>在接下来的很多例子中都会用到border的这个规律<br><a href=\"\" id=\"id13\"></a></p>\n<h3 id=\"还要会用css伪元素\"><strong>还要会用css伪元素</strong></h3>\n<p><strong>css的伪元素：</strong> 之所以被称为伪元素，是因为他们不是真正的页面元素，html没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的css样式，表面上看上去貌似是页面的某些元素来展现，实际上是css样式展现的行为，因此被称为伪元素。   </p>\n<p>我们在绘制图形发现需要进行元素组装时，就可以利用伪元素 来减少对HTML元素的使用。 </p>\n<p><a href=\"https://www.cnblogs.com/wonyun/p/5807191.html\">css伪元素的用法</a></p>\n<p><a id='id2'></a></p>\n<h2 id=\"css绘制正四边形\">css绘制正四边形</h2>\n<p>绘制正四边形最简单的方法就是利用内容，直接使用width、height  </p>\n<pre><code>.square2 {\n  width: 80px;\n  height: 80px;\n  background-color: #393;\n}\n</code></pre>\n<p><img src=\"https://ws3.sinaimg.cn/large/0069RVTdgy1fuw6wmpdi1j309w092q31.jpg\" alt=\"\"></p>\n<p>当然利用border也可以  </p>\n<pre><code>.square3 {\n  width: 0px;\n  height: 0px;\n  border-width: 40px;\n  border-style: solid;\n  border-color: #008000;\n}\n</code></pre>\n<p><img src=\"https://ws3.sinaimg.cn/large/0069RVTdgy1fuw6ypx233j30a208s74d.jpg\" alt=\"\"></p>\n<p><a id='id3'></a></p>\n<h2 id=\"css绘制非正四边形\">css绘制非正四边形</h2>\n<h4 id=\"绘制平行四边形\">绘制平行四边形</h4>\n<p>平行四边形利用<a href=\"/blog/CSS3/CSS3-2D%E8%BD%AC%E6%8D%A2#14\">css3的倾斜函数skew()</a>比较方便  </p>\n<pre><code>.parallelogram {\n  width: 100px;\n  height: 80px;\n  background: #393;\n  -webkit-transform: skew(-30deg);\n  -moz-transform: skew(-30deg);\n  -o-transform: skew(-30deg);\n  transform: skew(-30deg);\n}\n</code></pre>\n<p><img src=\"https://ws2.sinaimg.cn/large/0069RVTdgy1fuw79w9e6dj30bk08cweo.jpg\" alt=\"\">   </p>\n<p>当然使用 <code>border</code> + <code>:after</code>伪类也是可以的  </p>\n<pre><code>.parallelogram2 {\n  width: 0px;\n  height: 0px;\n  border-bottom: 80px solid #393;\n  border-left: 80px solid transparent;\n}\n.parallelogram2:after {\n  display: block;\n  content: &#39;&#39;;\n  width: 0px;\n  height: 0px;\n  border-top: 80px solid #393;\n  border-right: 80px solid transparent;\n}\n</code></pre>\n<p><img src=\"https://ws3.sinaimg.cn/large/0069RVTdgy1fuw7opf0mhj30bq06qwee.jpg\" alt=\"\">  </p>\n<h4 id=\"绘制菱形\">绘制菱形</h4>\n<p>思路：绘制两个等边三角形，进行拼接（<code>height = sqr(3)*width/2</code>）</p>\n<pre><code>.rhombus {\n  width: 0px;\n  height: 0px;\n  border-bottom: 69.3px solid #393;\n  border-left: 40px solid transparent;\n  border-right: 40px solid transparent;\n}\n.rhombus:after {\n  display: block;\n  content: &#39;&#39;;\n  width: 0px;\n  width: 0px;\n  border-top: 69.3px solid #393;\n  border-left: 40px solid transparent;\n  border-right: 40px solid transparent;\n}\n</code></pre>\n<p><img src=\"https://ws4.sinaimg.cn/large/0069RVTdgy1fuwb07zx8zj308605o748.jpg\" alt=\"\"></p>\n<p><a id='id4'></a></p>\n<h2 id=\"css绘制三角形\">css绘制三角形</h2>\n<h4 id=\"绘制直角三角形\">绘制直角三角形</h4>\n<pre><code>.rightTriangle\n    width 0px\n    height 0px\n    border-bottom 80px solid #393 \n    border-left 80px solid transparent\n</code></pre>\n<p><img src=\"https://ws2.sinaimg.cn/large/0069RVTdgy1fuwcpx6dhfj306s06aa9x.jpg\" alt=\"\">  </p>\n<h4 id=\"绘制等边三角形\">绘制等边三角形</h4>\n<p>等边三角形的宽高比为 1 : sqr(3)/2<br>所以\b可以根据底边长计算三角形高<code>height = sqr(3)*width/2</code><br>本例中左右border宽为40，所以底边长为80，从而计算出底部border宽应为69.3  </p>\n<pre><code>.triangle\n    width 0px\n    height 0px\n    border-bottom 69.3px solid #393 \n    border-left 40px solid transparent\n    border-right 40px solid transparent\n</code></pre>\n<p><img src=\"https://ws1.sinaimg.cn/large/0069RVTdgy1fuwb2kyyzqj306g064746.jpg\" alt=\"\"></p>\n<p><a id='id5'></a></p>\n<h2 id=\"css绘制圆形\">css绘制圆形</h2>\n<p>圆形最简单的方式就是设置<code>border-radius</code>为50%  </p>\n<pre><code>.circle1\n    width 80px\n    height 80px\n    border-radius 50%\n    background-color #393\n</code></pre>\n<p><img src=\"https://ws1.sinaimg.cn/large/0069RVTdgy1fuwcsqggv5j306c068a9z.jpg\" alt=\"\"></p>\n<p>也可以使用border实现  </p>\n<pre><code>.circle2\n    width 0px\n    height 0px\n    border 40px solid #393 \n    border-radius 50%\n</code></pre>\n<p>\b哎？猜猜这时候设置padding是什么样子的</p>\n<pre><code>.circle3\n    width 0px\n    height 0px\n    border 40px solid #393 \n    border-radius 50%\n    padding 20px\n</code></pre>\n<p><img src=\"https://ws3.sinaimg.cn/large/0069RVTdgy1fuwcyjhdw6j308408874b.jpg\" alt=\"\"><br>看来border-radius把内外角度都设置了 </p>\n<p><a id='id6'></a></p>\n<h2 id=\"css绘制梯形\">css绘制梯形</h2>\n<pre><code>.trapezoid\n    width 40px\n    height 0px\n    border-top 40px solid #393 \n    border-left 20px solid transparent\n    border-right 20px solid transparent\n</code></pre>\n<p><img src=\"https://ws1.sinaimg.cn/large/0069RVTdgy1fuwd59x6bsj306w04gwec.jpg\" alt=\"\"></p>\n<p><a id='id7'></a></p>\n<h2 id=\"css绘制正五边形\">css绘制正五边形</h2>\n<p>正五边形可以拆分成上下两个部分：上边一个等腰三角形，下面一个等腰梯形，具体长宽计算这里不做介绍  </p>\n<pre><code>.pentagon {\n  width: 0px;\n  height: 0px;\n  border-top: 0px;\n  border-right: 81px solid transparent;\n  border-left: 81px solid transparent;\n  border-bottom: 59px solid #393;\n}\n.pentagon:after {\n  position: relative;\n  left: -81px;\n  top: 59px;\n  display: block;\n  content: &#39;&#39;;\n  width: 100px;\n  height: 0px;\n  border-top: 95px solid #393;\n  border-left: 31px solid transparent;\n  border-right: 31px solid transparent;\n}\n</code></pre>\n<p><img src=\"https://ws3.sinaimg.cn/large/0069RVTdgy1fuwdlbgoi3j30be0a8t8r.jpg\" alt=\"\"></p>\n<p><a id='id8'></a></p>\n<h2 id=\"css绘制正七边形\">css绘制正七边形</h2>\n<p>正七边形比较复杂，需要将整个图形分成3份来做<br><img src=\"https://ws1.sinaimg.cn/large/0069RVTdgy1fuwdo5l0qrj307s07974m.jpg\" alt=\"\"><br>上：等腰三角形<br>中：等腰梯形<br>下：等腰梯形  </p>\n<pre><code>.heptagon {\n  height: 0px;\n  width: 180px;\n  border-left: 22px solid transparent;\n  border-right: 22px solid transparent;\n  border-bottom: 97px solid #393;\n  margin-top: 63px;\n}\n.heptagon:before {\n  display: block;\n  content: &#39;&#39;;\n  width: 0px;\n  height: 0px;\n  border-right: 90px solid transparent;\n  border-left: 90px solid transparent;\n  border-bottom: 43px solid #393;\n  position: relative;\n  top: -43px;\n}\n.heptagon:after {\n  width: 100px;\n  height: 0px;\n  content: &#39;&#39;;\n  display: block;\n  border-top: 78px solid #393;\n  border-left: 62px solid transparent;\n  border-right: 62px solid transparent;\n  position: relative;\n  left: -22px;\n  bottom: -54px;\n}\n</code></pre>\n<p><img src=\"https://ws3.sinaimg.cn/large/0069RVTdgy1fuwe4xtv6lj30ec0dowen.jpg\" alt=\"\"></p>\n"},"next":{"path":"_blogs/微信小程序/小程序的运行.md","url":"/blog/微信小程序/小程序的运行","title":"小程序的运行","author":"yrobot","keywords":"小程序,运行","createTime":1535904000000,"length":1360,"content":"<p><strong>本页目录：</strong><br><a href=\"#id1\">小程序的运行环境</a><br><a href=\"#id2\">小程序目录结</a><br><a href=\"#id3\">小程序运行机制</a>  </p>\n<p><a id='id1'></a></p>\n<h2 id=\"小程序的运行环境\">小程序的运行环境</h2>\n<p>微信小程序运行在三端：iOS、Android 和 用于调试的开发者工具。</p>\n<p>三端的脚本执行环境以及用于渲染非原生组件的环境是各不相同的：</p>\n<ul>\n<li>在 iOS 上，小程序的 javascript 代码是运行在 JavaScriptCore 中，是由 WKWebView 来渲染的，环境有 - iOS8、iOS9、iOS10  </li>\n<li>在 Android 上，小程序的 javascript 代码是通过 X5 JSCore来解析，是由 X5 基于 Mobile Chrome 53/57 内- 核来渲染的  </li>\n<li>在 开发工具上， 小程序的 javascript 代码是运行在 nwjs 中，是由 Chrome Webview 来渲染的  </li>\n</ul>\n<p>尽管三端的环境是十分相似的，但是还是有些许区别：  </p>\n<ol>\n<li>ES6 语法支持不一致：语法上开发者可以通过开启 ES6 转 ES5 的功能来规避。详情</li>\n<li>wxss 渲染表现不一致：尽管可以通过开启样式补全来规避大部分的问题 详情，还是建议开发者需要在 iOS 和 Android 上分别检查小程序的真实表现。</li>\n</ol>\n<p><a id='id2'></a></p>\n<h2 id=\"小程序目录结\">小程序目录结</h2>\n<pre><code>project\n├── pages\n|   ├── index\n|   |   ├── index.json  index 页面配置\n|   |   ├── index.js    index 页面逻辑\n|   |   ├── index.wxml  index 页面结构\n|   |   └── index.wxss  index 页面样式表\n|   └── log\n|       ├── log.json    log 页面配置\n|       ├── log.wxml    log 页面逻辑\n|       ├── log.js      log 页面结构\n|       └── log.wxss    log 页面样式表·\n├── app.js              小程序逻辑\n├── app.json            小程序公共设置\n└── app.wxss            小程序公共样式表\n</code></pre>\n<p><a id='id3'></a></p>\n<h2 id=\"小程序运行机制\">小程序运行机制</h2>\n<ul>\n<li>小程序没有重启的概念</li>\n<li><strong>前台、后台定义：</strong> 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。</li>\n<li>当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁</li>\n<li>当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁\n<img src=\"https://ws3.sinaimg.cn/large/0069RVTdgy1fuwgqm9y1oj30my0bxgmx.jpg\" alt=\"\"></li>\n</ul>\n"}},"__N_SSG":true}