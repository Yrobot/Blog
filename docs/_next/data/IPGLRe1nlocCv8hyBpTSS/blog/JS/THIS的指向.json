{"pageProps":{"pre":{"path":"_blogs/JS/JS的三个定时器/README.md","url":"/blog/JS/JS的三个定时器","title":"JS的三个定时器","author":"yrobot","keywords":"JS,定时器,三个","createTime":1535040000000,"length":4090,"content":"<p><strong>本页目录：</strong><br><a href=\"#setTimeout\">setTimeout</a><br><a href=\"#setInterval\">setInterval</a><br><a href=\"#requestAnimationFrame\">requestAnimationFrame</a><br><a href=\"#jsAnimation\">JS动画</a><br><a href=\"#useAnimation\">推荐使用requestAnimationFrame绘制JS动画</a>   </p>\n<p><a id='setTimeout'></a></p>\n<h2 id=\"settimeout\">setTimeout</h2>\n<ul>\n<li>在执行时,是在载入后延迟指定时间后执行一次表达式（仅执行一次）  </li>\n</ul>\n<p><a id='setInterval'></a></p>\n<h2 id=\"setinterval\">setInterval</h2>\n<ul>\n<li>在执行时,它从载入后,每隔指定的时间就执行一次表达式  </li>\n<li>在代码运行到间歇调用和超时调用时，定时器（浏览器中 __独立于js线程的一个线程__）会在相应的时间，将相应的代码放入宏代码队列中，所以不必考虑放代码时，js是否有程序在运行。所以这两个函数只能保证按时将代码放入队列，但具体的执行时间要看队列前的函数执行情况（什么时候轮到放入的函数）。由于这三个函数都是js异步编程的一种实现，所以详情参看<a href=\"/blog/JS/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B#eventLoop\">JS异步编程 #浏览器线程和Event Loop</a>\n<img src=\"https://ws1.sinaimg.cn/large/006tNbRwgy1fukmxrd5ixj30m409smxx.jpg\" alt=\"\"></li>\n</ul>\n<p><a id='requestAnimationFrame'></a></p>\n<h2 id=\"requestanimationframe\">requestAnimationFrame</h2>\n<ul>\n<li>不能指定延迟时间，而是根据浏览器的刷新频率而定（帧），即浏览器页面刷新一次函数就执行一次，适合实现页面动画  </li>\n</ul>\n<p><a id='jsAnimation'></a></p>\n<h2 id=\"js动画\">JS动画</h2>\n<p>理解了上面的概念以后，我们不难发现，setTimeout 其实就是通过设置一个间隔时间来不断的改变元素属性，从而达到动画效果的。但我们会发现，利用 seTimeout 实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因：</p>\n<ol>\n<li>setTimeout 的执行时间并不是确定的。在JavaScript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，所以 setTimeout 的实际执行时机一般要比其设定的时间晚一些。</li>\n<li>刷新频率受 屏幕分辨率 和 屏幕尺寸 的影响，不同设备的屏幕绘制频率可能会不同，而 setTimeout 只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。  </li>\n</ol>\n<p>以上两种情况都会导致 setTimeout 的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。 那为什么步调不一致就会引起丢帧呢？   </p>\n<p>首先要明白，setTimeout 的执行只是在内存中对元素属性进行改变，这个变化必须要等到屏幕下次绘制时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素。假设屏幕每隔16.7ms刷新一次，而setTimeout 每隔10ms设置图像向左移动1px， 就会出现如下绘制过程：</p>\n<ul>\n<li>第0ms：屏幕未绘制，  等待中，setTimeout 也未执行，等待中；</li>\n<li>第10ms：屏幕未绘制，等待中，setTimeout 开始执行并设置元素属性 left=1px；</li>\n<li>第16.7ms：屏幕开始绘制，屏幕上的元素向左移动了 1px， setTimeout 未执行，继续等待中；</li>\n<li>第20ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=2px;</li>\n<li>第30ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=3px;</li>\n<li>第33.4ms：屏幕开始绘制，屏幕上的元素向左移动了 3px， setTimeout 未执行，继续等待中；</li>\n<li>...  </li>\n</ul>\n<p>从上面的绘制过程中可以看出，屏幕没有更新 left=2px 的那一帧画面，元素直接从left=1px 的位置跳到了 left=3px 的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。</p>\n<p><a href=\"\" id=\"useAnimation\"></a></p>\n<h2 id=\"推荐使用requestanimationframe绘制js动画\">推荐使用requestAnimationFrame绘制JS动画</h2>\n<p>与 setTimeout 相比，requestAnimationFrame() 最大的优势是 __由系统来决定回调函数的执行时机__。具体一点讲就是，系统每次绘制之前会主动调用 requestAnimationFrame() 中的回调函数，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms。换句话说就是，requestAnimationFrame() 的执行步伐跟着系统的绘制频率走。它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</p>\n<p>这个API的调用很简单，如下所示：</p>\n<pre><code>var progress = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-regexp\">//</span>回调函数\n<span class=\"hljs-keyword\">function</span> render() {\n    progress += <span class=\"hljs-number\">1</span>; <span class=\"hljs-regexp\">//</span>修改图像的位置\n \n    <span class=\"hljs-keyword\">if</span> (progress &lt; <span class=\"hljs-number\">100</span>) {\n           <span class=\"hljs-regexp\">//</span>在动画没有结束前，递归渲染\n           window.requestAnimationFrame(render);\n    }\n}\n \n<span class=\"hljs-regexp\">//</span>第一帧渲染\nwindow.requestAnimationFrame(render);\n</code></pre>\n<p>除此之外，requestAnimationFrame 还有以下两个优势：</p>\n<ol>\n<li><p>__PU节能__：使用 setTimeout 实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，而且还浪费 CPU 资源。而 rAF 则完全不同，当页面处理未激活的状态下，该页面的屏幕绘制任务也会被系统暂停，因此跟着系统步伐走的 rAF 也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。</p>\n</li>\n<li><p>__函数节流__：在高频率事件(resize,scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，使用 rAF 可保证每个绘制间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个绘制间隔内函数执行多次时没有意义的，因为显示器每16.7ms 绘制一次，多次绘制并不会在屏幕上体现出来。</p>\n</li>\n</ol>\n<p><a href=\"\" id=\"suitDown\"></a></p>\n<h2 id=\"适配低版本\">适配低版本</h2>\n<p>以下代码考虑到部分浏览器不支持requestAnimationFrame的情况，对requestAnimationFrame和cancelAnimationFrame进行降级适配。</p>\n<pre><code><span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">Date</span>.now)\n    <span class=\"hljs-built_in\">Date</span>.now = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime(); };\n \n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-meta\">    &#x27;use strict&#x27;</span>;\n     \n    <span class=\"hljs-keyword\">var</span> vendors = [<span class=\"hljs-string\">&#x27;webkit&#x27;</span>, <span class=\"hljs-string\">&#x27;moz&#x27;</span>];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; vendors.length &amp;&amp; !<span class=\"hljs-built_in\">window</span>.requestAnimationFrame; ++i) {\n        <span class=\"hljs-keyword\">var</span> vp = vendors[i];\n        <span class=\"hljs-built_in\">window</span>.requestAnimationFrame = <span class=\"hljs-built_in\">window</span>[vp+<span class=\"hljs-string\">&#x27;RequestAnimationFrame&#x27;</span>];\n        <span class=\"hljs-built_in\">window</span>.cancelAnimationFrame = (<span class=\"hljs-built_in\">window</span>[vp+<span class=\"hljs-string\">&#x27;CancelAnimationFrame&#x27;</span>]\n                                   || <span class=\"hljs-built_in\">window</span>[vp+<span class=\"hljs-string\">&#x27;CancelRequestAnimationFrame&#x27;</span>]);\n    }\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-regexp\">/iP(ad|hone|od).*OS 6/</span>.test(<span class=\"hljs-built_in\">window</span>.navigator.userAgent) <span class=\"hljs-comment\">// iOS6 is buggy</span>\n        || !<span class=\"hljs-built_in\">window</span>.requestAnimationFrame || !<span class=\"hljs-built_in\">window</span>.cancelAnimationFrame) {\n        <span class=\"hljs-keyword\">var</span> lastTime = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-built_in\">window</span>.requestAnimationFrame = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callback</span>) </span>{\n            <span class=\"hljs-keyword\">var</span> now = <span class=\"hljs-built_in\">Date</span>.now();\n            <span class=\"hljs-keyword\">var</span> nextTime = <span class=\"hljs-built_in\">Math</span>.max(lastTime + <span class=\"hljs-number\">16</span>, now);\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{ callback(lastTime = nextTime); },\n                              nextTime - now);\n        };\n        <span class=\"hljs-built_in\">window</span>.cancelAnimationFrame = <span class=\"hljs-built_in\">clearTimeout</span>;\n    }\n}());\n<span class=\"hljs-string\">``</span><span class=\"hljs-string\">`---  \n*\b本章节部分参考[一像素 博客](https://www.cnblogs.com/onepixel/p/7078617.html)，在此感谢！*\n\n</span>\n</code></pre>\n"},"blog":{"path":"_blogs/JS/THIS的指向/README.md","url":"/blog/JS/THIS的指向","title":"THIS的指向","author":"yrobot","keywords":"THIS,指向","createTime":1535040000000,"length":807,"content":"<p><strong>本页目录：</strong><br><a href=\"#build\">this的建立</a><br><a href=\"#index\">this指向</a><br><a href=\"#rule\">this规则概括</a>  </p>\n<p><a id='build'></a></p>\n<h2 id=\"this的建立\">this的建立</h2>\n<ul>\n<li>一般函数在预编译过程中生成的AO上下文  </li>\n<li>AO中除了函数内的一些属性和函数参数外，还有<code>arguments</code>和<code>this</code>(箭头函数没有)。  </li>\n<li>所以函数（除了箭头函数）预编译过程会生成<code>this</code>隐式对象，并 <strong>默认指向window。</strong>  </li>\n</ul>\n<p><a id='index'></a></p>\n<h2 id=\"this指向\">this指向</h2>\n<ul>\n<li>而在预编译过程中，<code>this</code>会默认指向<code>window</code>。  </li>\n<li>而<code>new</code>操作时，会在函数内生成一个隐式<code>this</code>对象，而同时改变AO中<code>this</code>指向为本<code>this</code></li>\n<li>用<code>obj.func()</code>调用的时候，会将<code>func()</code>内的<code>this</code>指向改为<code>obj</code>  </li>\n<li><h4 id=\"以上this的修改是在func有this的情况下，箭头函数没有this，直接沿着作用域链向上寻找this\">以上<code>this</code>的修改是在<code>func</code>有<code>this</code>的情况下，箭头函数没有this，直接沿着作用域链向上寻找this</h4>\n</li>\n<li><h4 id=\"注意函数作用域链的数据是由函数参数、函数内声明组成，funprop无法\b增加或更改作用域\">注意函数作用域链的数据是由函数参数、函数内声明组成，fun.prop无法\b增加或更改作用域</h4>\n</li>\n</ul>\n<p><a id='rule'></a></p>\n<h2 id=\"this规则概括\">this规则概括</h2>\n<ol>\n<li>函数编译过程中AO上下文中<code>this</code>默认指向<code>window</code>  </li>\n<li>全局作用域里<code>this</code>指向<code>window</code>  </li>\n<li><code>call</code>/<code>apply</code>可以利用参数改变<code>this</code>的指向  </li>\n<li><code>obj.fun()</code>调用时，<code>fun()</code>AO中<code>this</code>指向obj (<code>new</code> 生成对象时默认<code>return this</code>，所以只有<code>this.xxx</code>的属性才能被访问到)  </li>\n<li>html元素脚本中，函数参数中的<code>this</code>指向元素本身  </li>\n</ol>\n<hr>\n"},"next":{"path":"_blogs/JS/遍历obj和array/README.md","url":"/blog/JS/遍历obj和array","title":"遍历obj和array","author":"yrobot","keywords":"array,obj,遍历","createTime":1535040000000,"length":1377,"content":"<p><strong>本页目录：</strong><br><a href=\"#for\">基础for循环</a><br><a href=\"#forin\">for in 循环</a><br><a href=\"#forof\">for of 循环</a><br><a href=\"#foreach\">array.forEach()方法</a><br><a href=\"#summary\">总结</a>  </p>\n<p><a id='for'></a></p>\n<h2 id=\"1-基础for循环\">1. 基础for循环</h2>\n<pre><code><span class=\"hljs-keyword\">for</span> (var <span class=\"hljs-keyword\">index</span> = <span class=\"hljs-number\">0</span>; <span class=\"hljs-keyword\">index</span> &lt; myArray.<span class=\"hljs-built_in\">length</span>; <span class=\"hljs-keyword\">index</span>++) {\n  console.<span class=\"hljs-built_in\">log</span>(myArray[<span class=\"hljs-keyword\">index</span>]);\n}\n</code></pre>\n<p><a id='forin'></a></p>\n<h2 id=\"2-for-in-循环\">2. for in 循环</h2>\n<ul>\n<li>for...in 语句用于对数组或者对象的属性进行循环操作。<pre><code><span class=\"hljs-function\"><span class=\"hljs-title\">for</span><span class=\"hljs-params\">(let i in array)</span></span>  <span class=\"hljs-comment\">// i为数组的index：0，1，2，3.....</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">for</span><span class=\"hljs-params\">(let i in obj)</span></span>  <span class=\"hljs-comment\">// i为obj 的属性名</span>\n</code></pre>\n<img src=\"https://ws3.sinaimg.cn/large/006tNbRwgy1fukqtphbb9j31e60bwgmv.jpg\" alt=\"\">\n<a id='forof'></a></li>\n</ul>\n<h2 id=\"3-for-of-循环\">3. for of 循环</h2>\n<p>参考链接：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of</a></p>\n<pre><code><span class=\"hljs-keyword\">for</span> (let value of iterable) {  <span class=\"hljs-regexp\">//</span> value为属性值\n    <span class=\"hljs-regexp\">//</span>statements\n}\n</code></pre>\n<p><strong>value</strong><br>在每次迭代中，将不同属性的值分配给变量。 </p>\n<p><strong>iterable</strong> ( Array，Map，Set，String，TypedArray，arguments 对象等等) (obj不是iterable)<br>被迭代枚举其属性的对象。<br><img src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fukqtq7vk6j31e60fqmzh.jpg\" alt=\"\">  </p>\n<p><a id='foreach'></a></p>\n<h2 id=\"4-arrayforeach方法\">4. array.forEach()方法</h2>\n<pre><code>arr.<span class=\"hljs-keyword\">for</span><span class=\"hljs-constructor\">Each(<span class=\"hljs-params\">function</span> <span class=\"hljs-params\">callback</span>(<span class=\"hljs-params\">value</span>[, <span class=\"hljs-params\">index</span>[, <span class=\"hljs-params\">array</span>]])</span> { <span class=\"hljs-comment\">// value:属性值，index:当前索引，array:当前遍历数组</span>\n    <span class=\"hljs-comment\">//your iterator</span>\n}<span class=\"hljs-literal\">[, <span class=\"hljs-identifier\">thisArg</span>]</span>);   <span class=\"hljs-comment\">// thisArg:作为callback函数的this值</span>\n</code></pre>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fukqto6spyj31ec0c0dh4.jpg\" alt=\"\"></p>\n<p><a id='summary'></a></p>\n<h2 id=\"总结\">总结</h2>\n<ol>\n<li>少用for of，支持不好。性能也一般。性能基础for优化较好</li>\n<li>遍历array，以上方法均可</li>\n<li>遍历obj思路：<ol>\n<li>获取obj的keys，利用基础for遍历</li>\n<li>for in利用属性名获取属性值</li>\n<li>利用object.keys()方法获取keys，再用keys.forEach()遍历获取属性值</li>\n</ol>\n</li>\n</ol>\n"}},"__N_SSG":true}