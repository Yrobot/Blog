{"pageProps":{"pre":{"path":"_blogs/微信小程序/小程序的分享与传参.md","url":"/blog/微信小程序/小程序的分享与传参","title":"小程序的分享与传参","author":"yrobot","keywords":"小程序,传参,分享","createTime":1538236800000,"length":5284,"content":"<p><strong>本页目录：</strong><br><a href=\"#before\">事先说明</a><br><a href=\"#share\">分享方法概括</a>  </p>\n<p>分享传参</p>\n<ul>\n<li><a href=\"#url\">利用URL参数</a>  </li>\n<li><a href=\"#qrcode\">二维码传参</a>  </li>\n<li><a href=\"#st\">shareTicket</a>  </li>\n<li><a href=\"#cb\">剪切板传参</a>  </li>\n</ul>\n<p><a href=\"#note\">分享的注意点</a>  </p>\n<p><a id='before'></a></p>\n<h2 id=\"事先说明\">事先说明</h2>\n<p>首先要说的就是<br>微信仗着自己的生态圈日益完善，随随便便就可以废弃或者改动API<code>(比如这次的分享回调函数)</code><br>所以本文只能做到说，对于目前<code>2018年09月30日</code>这个时间结点，我所做的总结是没有问题的   </p>\n<p>再说一下做本次总结的初衷，或者是出发点  </p>\n<p>最近要负责一个信用卡的小程序项目<br>我主要负责的就是项目的前端开发<br>那么一系列关于分享的问题就来了  </p>\n<ul>\n<li>什么这个页面能不能生成链接放群里啊</li>\n<li>小程序能不能分享到朋友圈啊</li>\n<li>分享对接到个人，进而引入任务机制啊</li>\n<li>能不能查看每个人发展了几个新用户啊</li>\n<li>朋友圈分享加入参数怎么实现啊</li>\n<li>巴拉巴拉</li>\n</ul>\n<p>呼~  </p>\n<p>索性做一次比较系统的总结吧<br>看你们谁敢再提一些xx的需求  </p>\n<p><a id='share'></a></p>\n<h2 id=\"分享方法概括\">分享方法概括</h2>\n<ol>\n<li>利用page生命周期onShareAppMessage()</li>\n<li>基于\b二维码图片进行分享</li>\n<li>通过剪切板分享   </li>\n</ol>\n<h3 id=\"1-利用page生命周期onshareappmessage\">1. 利用page生命周期onShareAppMessage()</h3>\n<p>只有设置了onShareAppMessage()函数<br>点击小程序右上角才会有分享选项<br>button方式的分享才会成功  </p>\n<p>具体API使用参考<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0\">官网-页面事件处理函数</a></p>\n<p><strong>优点：</strong><br>这个方法好的地方就是可以直接分享给用户和群<br>用户点击链接直接跳转小程序<br>非常方便，转化率也高  </p>\n<p><strong>缺点：</strong><br>不支持以链接形式分享到朋友圈  </p>\n<h3 id=\"2-\b基于\b二维码图片进行分享\">2. \b基于\b二维码图片进行分享</h3>\n<p>生成小程序二维码需要获取access_token<br>然后利用<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/qr-code.html\">官方的接口</a>去获取二维码<br>接口返回数据为二维码的二进制数据  </p>\n<p><strong>需要注意的是：</strong><br>官方的接口有3个<br>但是1、3的接口生成个数总和不得超过100000，但参数长度够长<br>2接口不限制总个数，生成频率也很大，但是2号接口的参数整体不得多于32个可见字符<br>这需要开发的取舍，或者进行适当的转换了  </p>\n<p><strong>优点：</strong><br>方法各种场景通用，可以对用户、对朋友圈、甚至支持以其他媒体介质传播  </p>\n<p><strong>缺点：</strong><br>方法操作复杂，转换率比较低<br>对于老年用户。可能不是很智能<br>参数可能还需要压缩  </p>\n<h3 id=\"3-通过剪切板分享\">3. 通过剪切板分享</h3>\n<p>这个方法适用的场景很单一<br>主要是\b各方都在用小程序的情况下<br>不是用来推广小程序的<br>而是用来分享具体内容的（前提是都已经在用小程序了） </p>\n<p>目前淘宝、支付宝这种方式的分享很多  </p>\n<p><strong>需要注意的是：</strong>\n由于是明文分享，需要做好防修改操作<br>最好就是以签名的方式进行判断  </p>\n<p><strong>优点：</strong><br>分享途径不受限制<br>分享方法也很简单  </p>\n<p><strong>缺点：</strong><br>不适用小程序的推广，单纯的内部分享<br>打开小程序后才能被监听  </p>\n<p><a id='url'></a></p>\n<h2 id=\"利用url参数\">利用URL参数</h2>\n<h4 id=\"方法简述\">方法简述</h4>\n<p>就是前段最朴素的传参，在url后添加?name=value的形式，然后利用路由或者小程序自带的方法读取参数   </p>\n<h4 id=\"方法步骤\">方法步骤</h4>\n<ol>\n<li>在页面onShareAppMessage()配置返回的url，以path?name=value的形式  </li>\n<li>获取参数：  <ol>\n<li>在Page的onLoad生命周期的参数 <code>option.参数名</code> 获取参数值</li>\n<li>还可以在APP的onLaunch生命周期的参数 <code>options.query.参数名</code> 获取</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"注意点\">注意点</h4>\n<ul>\n<li>关于参数的问题，onShareAppMessage()没有指明是否可以在tab页面的url带参数，但是wx路由API指明只能在跳转非tab页时带参数 。  </li>\n<li>必须触发Page的onLoad或者APP的onLaunch才获取的到参数  <h4 id=\"测试结果：\">测试结果：</h4>\n直接打开：\n<img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fvrmzyjpbkj30v80jignm.jpg\" alt=\"\">\n从分享链接打开：\n<img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fvrn0kxyohj30ve0m0tax.jpg\" alt=\"\">\n<a id='qrcode'></a></li>\n</ul>\n<h2 id=\"二维码传参\">二维码传参</h2>\n<h4 id=\"方法简述-1\">方法简述</h4>\n<p>利用小程序生成二维码的API生成二维码，让用户直接分享二维码  </p>\n<h4 id=\"方法步骤-1\">方法步骤</h4>\n<ol>\n<li>利用appID和appSECRET获取access_token</li>\n<li>利用access_token作为参数请求二维码API</li>\n<li>接口返回二维码的二进制数据，处理成url</li>\n<li>利用wx接口下载url并保存</li>\n</ol>\n<h4 id=\"注意点-1\">注意点</h4>\n<p>官方二维码生成接口有3种方法，具体参考<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/qr-code.html\">官方API</a><br>三种方式的参数和url，data格式都不一样，具体可以参考<a href=\"https://www.jianshu.com/p/441882c67b6a\">博客链接</a>   </p>\n<p>注意1、3一共只能生成10000个二维码，2的参数长度不能那个超过32个字符<br>接口返回的图片二进制，最好是在服务端储存然后返回链接给前端。<br><a id='st'></a></p>\n<h2 id=\"shareticket\">shareTicket</h2>\n<h4 id=\"方法简述-2\">方法简述</h4>\n<p>shareTicket的作用是用来换取 群的openID  </p>\n<h4 id=\"方法步骤-2\">方法步骤</h4>\n<ol>\n<li>在showSHareMenu()或者updateShareMenu()中设置shareTicket为true</li>\n<li>将小程序分享到群中</li>\n<li>有用户打开此链接后,即可在App.onLaunch 或 App.onShow 获取到一个 shareTicket</li>\n<li>利用wx.getShareInfo将shareTicket转化成加密数据</li>\n<li>加密数据解密后获得 群openID </li>\n</ol>\n<h4 id=\"注意点-2\">注意点</h4>\n<ol>\n<li>18年10月10号，微信关闭分享回调函数，所以无法再用户分享会后立刻获得shareTicket</li>\n<li>使用App.onLaunch获取要注意，App.onLaunch只在小程序初始化时触发，即当已经打开小程序，再去群里点击链接，是不会触发App.onLaunch的。推荐使用App.onShow<h4 id=\"代码演示\">代码演示</h4>\ndemo7.js:<pre><code>onShareAppMessage: <span class=\"hljs-keyword\">function</span> (res) {\n return {\n     title: <span class=\"hljs-string\">&#x27;Yrobot test share&#x27;</span>,\n     path: <span class=\"hljs-string\">&#x27;pages/demo7/index?shareID=Yrobot7&#x27;</span>\n }\n},\nonShow: <span class=\"hljs-keyword\">function</span> () {\n <span class=\"hljs-regexp\">//</span> setTimeout(() =&gt; {\n <span class=\"hljs-regexp\">//</span>     wx.redirectTo({\n <span class=\"hljs-regexp\">//</span>         url: <span class=\"hljs-string\">&#x27;../demo5/index&#x27;</span>\n <span class=\"hljs-regexp\">//</span>     }) \n <span class=\"hljs-regexp\">//</span> }, <span class=\"hljs-number\">6000</span>);\n wx.showShareMenu({\n     withShareTicket: true,\n });\n},\n</code></pre>\nApp.js:<pre><code>onShow: <span class=\"hljs-keyword\">options</span> =&gt; {\n console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;App.onShow&#x27;</span>);\n console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;shareID: &#x27;</span> + <span class=\"hljs-keyword\">options</span>.query.shareID);\n wx.getShareInfo({\n   shareTicket: <span class=\"hljs-keyword\">options</span>.shareTicket,\n   success: res =&gt; {\n     console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;wx.getShareInfo:success:&#x27;</span>);\n     console.<span class=\"hljs-built_in\">log</span>(res);\n   },\n   fail: res =&gt; {\n     console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;wx.getShareInfo:fail&#x27;</span>);\n     console.<span class=\"hljs-built_in\">log</span>(res);\n   }\n });\n},\n</code></pre>\n<h4 id=\"效果展示\">效果展示</h4>\n<img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fvro07yrz1j30ws0m0wsy.jpg\" alt=\"\">\n<a id='cb'></a></li>\n</ol>\n<h2 id=\"剪切板传参\">剪切板传参</h2>\n<h4 id=\"方法简述-3\">方法简述</h4>\n<p>利用剪切板监听的方式，获取页面和参数<br>功能类似于淘宝、支付宝的分享   </p>\n<h4 id=\"方法内容\">方法内容</h4>\n<ul>\n<li>利用wx.setClipboardData设置剪切板内容  </li>\n<li>利用wx.getClipboardData获取剪切内容  </li>\n<li>监听到剪切板时当前小程序的分享字符串时，进行解析、跳转  </li>\n</ul>\n<h4 id=\"注意点-3\">注意点</h4>\n<p>注意传参的话最好进行加密混淆、否则明码容易被用户手动替换<br>最好就是对整体进行签名，签名认证不一致(用户修改过)就不进行解析   </p>\n<h4 id=\"效果展示：\">效果展示：</h4>\n<p>初始进入：<br>    <img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fvrkc3incyj30gg0ncwfg.jpg\" alt=\"\"><br>复制指令后进入：<br>    <img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fvrkbv5lqlj30gm0nc3zb.jpg\" alt=\"\">   </p>\n<p><a id='note'></a></p>\n<h2 id=\"分享的注意点\">分享的注意点</h2>\n<p>由于7月5日微信更新API，减少“强制分享至不同群”等滥用分享能力，将不再支持onShareAppMessage()中获取分享状态(即那三个回调函数)，所以也无法在分享后立刻获得群id，而改为用户打开后利用shareTicket换取群id   </p>\n<p>具体参考微信公众平台公告：10月10日起新提交发布的版本，不再支持分享回调参数 success 、fail 、complete</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NDAwMTA2MA==&amp;mid=2695730124&amp;idx=1&amp;sn=666a448b047d657350de7684798f48d3&amp;chksm=83d74a07b4a0c311569a748f4d11a5ebcce3ba8f6bd5a4b3183a4fea0b3442634a1c71d3cdd0&amp;scene=21#wechat_redirect\">微信公共平台 - 分享功能调整及小程序组件更新</a>[时间不准确]<br><a href=\"https://mp.weixin.qq.com/cgi-bin/announce?action=getannouncement&amp;announce_id=11526372695t90Dn&amp;version=&amp;lang=zh_CN\">微信公共平台 - 分享功能调整</a>[时间不准确]<br><a href=\"https://developers.weixin.qq.com/community/develop/doc/0000447a5b431807af57249a551408?highLine=%25E5%2588%2586%25E4%25BA%25AB%25E5%259B%259E%25E8%25B0%2583%25E6%2588%2590%25E5%258A%259F\">微信开放社区 - “分享监听”能力调整</a>[时间准确]</p>\n"},"blog":{"path":"_blogs/JS/DOM操作/README.md","url":"/blog/JS/DOM操作","title":"DOM操作","author":"yrobot","keywords":"DOM,操作","createTime":1537977600000,"length":6382,"content":"<p><a id='top'></a></p>\n<p><strong>本页目录：</strong><br><a href=\"#nh\">NodeList 和 HTMLCollection</a><br><a href=\"#get\">获取 DOM 节点的方法</a><br><a href=\"#create\">生成节点的方法</a><br><a href=\"#action\">DOM 操作方法</a><br><a href=\"#near\">关系节点获取</a><br><a href=\"#props\">元素属性设置</a><br><a href=\"#style\">元素样式修改</a><br><a href=\"#position\">获取元素宽高、位置</a></p>\n<p><a id='nh'></a></p>\n<h2 id=\"nodelist-和-htmlcollection\">NodeList 和 HTMLCollection</h2>\n<h4 id=\"共同点：\">共同点：</h4>\n<ol>\n<li>都是类数组对象，都有 length 属性</li>\n<li>都有共同的方法：item，可以通过 item(index)或者 item(id)来访问返回结果中的元素</li>\n<li>都是实时变动的（live），document 上的更改会反映到相关对象上（例外：document.querySelectorAll 返回的 NodeList 不是实时的）</li>\n</ol>\n<h4 id=\"不同点：\">不同点：</h4>\n<ol>\n<li>NodeList 可以包含任何节点类型（包括换行、元素间的文字），HTMLCollection 只包含元素节点（elementNode），elementNode 就是 HTML 中的标签</li>\n<li>HTMLCollection 比 NodeList 多一项方法：namedItem，可以通过传递 id 或 name 属性来获取节点信息</li>\n</ol>\n<p><a id='get'></a></p>\n<h2 id=\"获取-dom-节点的方法\">获取 DOM 节点的方法</h2>\n<ol>\n<li><p><code>document.getElementById</code> ：根据 ID 查找元素，大小写敏感，如果有多个结果，只返回第一个；只能 document 调用</p>\n</li>\n<li><p><code>DOM.getElementsByClassName</code> ：根据类名查找元素，多个类名用空格分隔，返回一个 HTMLCollection 。</p>\n</li>\n<li><p><code>DOM.getElementsByTagName</code> ：根据标签查找元素， * 表示查询所有标签，返回一个 HTMLCollection 。</p>\n</li>\n<li><p><code>document.getElementsByName</code> ：根据元素的 name 属性查找，返回一个 NodeList 。只能 document 调用</p>\n</li>\n<li><p><code>DOM.querySelector</code> ：返回单个 Node，如果匹配到多个结果，只返回第一个。</p>\n</li>\n<li><p><code>DOM.querySelectorAll</code> ：返回一个 NodeList。不是实时的。</p>\n</li>\n<li><p><code>document.forms</code> ：获取当前页面所有 form，返回一个 HTMLCollection ；</p>\n</li>\n<li><p><code>document.documentElement</code>：获取 html 节点</p>\n</li>\n<li><p><code>document.body</code>：获取 body 节点</p>\n</li>\n</ol>\n<p><a id='create'></a></p>\n<h2 id=\"生成节点的方法\">生成节点的方法</h2>\n<ol>\n<li><p><code>document.createElement(&quot;p&quot;)</code>：生成 HTML 节点元素，参数为节点类型</p>\n</li>\n<li><p><code>document.createTextNode(&quot;text&quot;)</code>:文本内容（无标签包裹），节点间的文本、节点内的文本</p>\n</li>\n<li><p><code>DOM.cloneNode()</code>：方法创建节点的拷贝，并返回该副本。</p>\n</li>\n</ol>\n<p><a id='action'></a></p>\n<h2 id=\"dom-操作方法\">DOM 操作方法</h2>\n<h3 id=\"添加元素：\">添加元素：</h3>\n<ol>\n<li><code>DOM.appendChild(元素)</code>：在 DOM 节点末尾添加元素</li>\n<li><code>parentNode.insertBefore(newNode, refNode)</code>：在 redNode 前添加新元素 newNode</li>\n<li><code>DOM.insertAdjacentElement(position,ele)</code>：在 DOM 指定位置添加元素</li>\n<li><code>DOM.insertAdjacentHTML(position, text)</code>：同上<br><strong>position</strong><br>A DOMString representing the position relative to the element; must be one of the following strings: 相对于 p 节点<br>取值：<code>&#39;beforebegin&#39;</code>、<code>&#39;afterbegin&#39;</code>、<code>&#39;beforeend&#39;</code>、<code>&#39;afterend&#39;</code><pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- beforebegin --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- afterbegin --&gt;</span>\n  foo\n  <span class=\"hljs-comment\">&lt;!-- beforeend --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- afterend --&gt;</span>\n</code></pre>\n<strong>text</strong><br>text is the string to be parsed as HTML or XML and inserted into the tree.例如<code>&#39;&lt;div id=&quot;two&quot;&gt;two&lt;/div&gt;&#39;</code><br><strong>element</strong><br>要插入到树中的元素.</li>\n</ol>\n<h3 id=\"删除元素：\">删除元素：</h3>\n<ol>\n<li><code>parentNode.removeChild(node)</code>：删除 parentNode 下的 node 节点，注意是实时更新的，删除时 index 会时时改变<pre><code class=\"language-js\">function removeNode(<span class=\"hljs-keyword\">node</span><span class=\"hljs-title\">) {\n  if</span> (!<span class=\"hljs-keyword\">node</span><span class=\"hljs-title\">) return</span>;\n  if (node.parentNode) node.parentNode.removeChild(<span class=\"hljs-keyword\">node</span><span class=\"hljs-title\">);\n}</span>\n</code></pre>\n</li>\n<li><code>parentNode.replaceChild(newChild, oldChild)</code>：将 oldChild 替换为 newChild</li>\n</ol>\n<p><a id='near'></a></p>\n<h2 id=\"关系节点获取\">关系节点获取</h2>\n<ol>\n<li><p><code>parentNode</code> ：返回元素的父节点。Element 的父节点可能是 Element，Document 或 DocumentFragment；</p>\n</li>\n<li><p><code>parentElement</code> ：返回元素的父元素节点，与 parentNode 的区别在于，其父节点必须是一个 Element 元素，如果不是，则返回 null；</p>\n</li>\n<li><p><code>children</code> ：返回一个实时的 HTMLCollection ，子节点都是 Element，IE9 以下浏览器不支持；</p>\n</li>\n<li><p><code>childNodes</code> ：返回一个实时的 NodeList ，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等；</p>\n</li>\n<li><p><code>firstChild</code> ：返回第一个子节点，不存在返回 null，与之相对应的还有一个 firstElementChild ；</p>\n</li>\n<li><p><code>lastChild</code> ：返回最后一个子节点，不存在返回 null，与之相对应的还有一个 lastElementChild ；</p>\n</li>\n<li><p><code>previousSibling</code> ：返回节点的前一个节点，如果不存在则返回 null。注意有可能拿到的节点是文本节点或注释节点。</p>\n</li>\n<li><p><code>nextSibling</code> ：返回节点的后一个节点，如果不存在则返回 null。注意有可能拿到的节点是文本节点或注释节点。</p>\n</li>\n<li><p><code>previousElementSibling</code> ：返回前一个 element 元素节点，前一个节点必须是 Element，注意 IE9 以下浏览器不支持。</p>\n</li>\n<li><p><code>nextElementSibling</code> ：返回后一个 element 元素节点，后一个节点必须是 Element，注意 IE9 以下浏览器不支持。</p>\n</li>\n</ol>\n<p><a id='props'></a></p>\n<h2 id=\"元素属性设置\">元素属性设置</h2>\n<ol>\n<li><p><code>DOM.setAttribute(name, value)</code>: name 是特性名，value 是特性值，如 DOM.setAttribute(&#39;name&#39;, &#39;ele&#39;);</p>\n</li>\n<li><p><code>DOM.getAttribute(name)</code>: 返回指定的特性名相应的特性值，如果不存在，则返回 nul</p>\n</li>\n<li><p><code>DOM.hasAttribute(name)</code>: 判断 DOM 是否存在 name 的属性</p>\n</li>\n<li><p><code>DOM.dataset</code>: 获取 html data-开头的属性</p>\n<pre><code class=\"language-js\">&lt;div id=<span class=\"hljs-string\">&#x27;user&#x27;</span> data-id=<span class=\"hljs-string\">&#x27;1234567890&#x27;</span> data-user=<span class=\"hljs-string\">&#x27;johndoe&#x27;</span> data-date-of-birth&gt;\n  John Doe\n&lt;/div&gt;;\n\nlet el = document.querySelector(<span class=\"hljs-string\">&#x27;#user&#x27;</span>);\n<span class=\"hljs-regexp\">//</span> el.id == <span class=\"hljs-string\">&#x27;user&#x27;</span>\n<span class=\"hljs-regexp\">//</span> el.dataset.id === <span class=\"hljs-string\">&#x27;1234567890&#x27;</span>\n<span class=\"hljs-regexp\">//</span> el.dataset.user === <span class=\"hljs-string\">&#x27;johndoe&#x27;</span>\n<span class=\"hljs-regexp\">//</span> el.dataset.dateOfBirth === <span class=\"hljs-string\">&#x27;&#x27;</span>\n\nel.dataset.dateOfBirth = <span class=\"hljs-string\">&#x27;1960-10-03&#x27;</span>; <span class=\"hljs-regexp\">//</span> set the DOB.\n<span class=\"hljs-regexp\">//</span> <span class=\"hljs-string\">&#x27;someDataAttr&#x27;</span> <span class=\"hljs-keyword\">in</span> el.dataset === false\n\nel.dataset.someDataAttr = <span class=\"hljs-string\">&#x27;mydata&#x27;</span>;\n<span class=\"hljs-regexp\">//</span> <span class=\"hljs-string\">&#x27;someDataAttr&#x27;</span> <span class=\"hljs-keyword\">in</span> el.dataset === true\n</code></pre>\n</li>\n</ol>\n<p><a id='style'></a></p>\n<h2 id=\"元素样式修改\">元素样式修改</h2>\n<ol>\n<li><p>直接修改元素 style 样式： <em><code>element.sytle.xxx</code>只能获取到内联样式</em></p>\n<pre><code class=\"language-js\"><span class=\"hljs-built_in\">elem</span>.<span class=\"hljs-built_in\">style</span>.<span class=\"hljs-built_in\">color</span> = &#x27;red&#x27;;\n<span class=\"hljs-built_in\">elem</span>.<span class=\"hljs-built_in\">style</span>.setProperty(&#x27;<span class=\"hljs-built_in\">font</span>-size&#x27;, &#x27;16px&#x27;);\n<span class=\"hljs-built_in\">elem</span>.<span class=\"hljs-built_in\">style</span>.removeProperty(&#x27;<span class=\"hljs-built_in\">color</span>&#x27;);\n</code></pre>\n</li>\n<li><p>动态添加样式规则：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-built_in\">var</span> <span class=\"hljs-built_in\">style</span> = document.createElement(&#x27;<span class=\"hljs-built_in\">style</span>&#x27;);\n<span class=\"hljs-built_in\">style</span>.innerHTML = &#x27;body{<span class=\"hljs-built_in\">color</span>:red} #top:hover{<span class=\"hljs-built_in\">background</span>-<span class=\"hljs-built_in\">color</span>: red;<span class=\"hljs-built_in\">color</span>: white;}&#x27;;\ndocument.head.appendChild(<span class=\"hljs-built_in\">style</span>);\n</code></pre>\n</li>\n<li><p>classList 获取样式 class<br><strong><code>DOM.classList.xxx()</code>:</strong></p>\n<ul>\n<li>add( String [, String] )<br>添加指定的类值。如果这些类已经存在于元素的属性中，那么它们将被忽略。</li>\n<li>remove( String [,String] )<br>删除指定的类值。</li>\n<li>item ( Number )<br>按集合中的索引返回类值。</li>\n<li>toggle ( String [, force] )<br>当只有一个参数时：切换 class value; 即如果类存在，则删除它并返回 false，如果不存在，则添加它并返回 true。<br>当存在第二个参数时：如果第二个参数的计算结果为 true，则添加指定的类值，如果计算结果为 false，则删除它</li>\n<li>contains( String )<br>检查元素的类属性中是否存在指定的类值。</li>\n<li>replace( String, String )<br>用一个新类替换已有类。</li>\n</ul>\n</li>\n<li><p>使用<code>window.getComputedStyle</code>： <em>借助<code>window.getComputedStyle</code>可以获取应用到元素上的所有样式</em><br><code>let style = window.getComputedStyle(element, [pseudoElt]);</code></p>\n<ul>\n<li>element<br>用于获取计算样式的 Element。</li>\n<li>pseudoElt [可选]<br>指定一个要匹配的伪元素的字符串。必须对普通元素省略（或 null）。</li>\n</ul>\n<p>返回的 style 是一个实时的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CSSStyleDeclaration\">CSSStyleDeclaration</a> 对象，当元素的样式更改时，它会自动更新本身。</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> elem = document.get<span class=\"hljs-constructor\">ElementById(&#x27;<span class=\"hljs-params\">elem</span>-<span class=\"hljs-params\">container</span>&#x27;)</span>;\nwindow.get<span class=\"hljs-constructor\">ComputedStyle(<span class=\"hljs-params\">elem</span>, <span class=\"hljs-params\">null</span>)</span>.height = &#x27;<span class=\"hljs-number\">100</span>px&#x27;;\n</code></pre>\n</li>\n</ol>\n<p><a id='position'></a></p>\n<h2 id=\"获取元素宽高、位置\">获取元素宽高、位置</h2>\n<ol>\n<li><p><code>getBoundingClientRect()</code>:<br><code>DOM.getBoundingClientRect()</code>的属性：</p>\n<table>\n<thead>\n<tr>\n<th>Attribute</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bottom</td>\n<td>float</td>\n<td>Y 轴，相对于视口原点（viewport origin）矩形盒子的底部。只读。</td>\n</tr>\n<tr>\n<td>height</td>\n<td>float</td>\n<td>矩形盒子的高度（等同于 bottom 减 top）。只读。</td>\n</tr>\n<tr>\n<td>left</td>\n<td>float</td>\n<td>X 轴，相对于视口原点（viewport origin）矩形盒子的左侧。只读。</td>\n</tr>\n<tr>\n<td>right</td>\n<td>float</td>\n<td>X 轴，相对于视口原点（viewport origin）矩形盒子的右侧。只读。</td>\n</tr>\n<tr>\n<td>top</td>\n<td>float</td>\n<td>Y 轴，相对于视口原点（viewport origin）矩形盒子的顶部。只读。</td>\n</tr>\n<tr>\n<td>width</td>\n<td>float</td>\n<td>矩形盒子的宽度（等同于 right 减 left）。只读。</td>\n</tr>\n<tr>\n<td>x</td>\n<td>float</td>\n<td>X 轴，相对于视口原点（viewport origin）矩形盒子的左侧。只读。</td>\n</tr>\n<tr>\n<td>y</td>\n<td>float</td>\n<td>Y 轴，相对于视口原点（viewport origin）矩形盒子的顶部。只读。</td>\n</tr>\n<tr>\n<td>clientRect 是一个 DOMRect 对象，包含 width、height、left、top、right、bottom，它是相对于窗口顶部而不是文档顶部，<strong>滚动页面时它们的值是会发生变化的</strong>。</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n<li><p><code>DOM.clientWidth</code>：表示元素的内部宽度，以像素计。盒模型的 content+padding</p>\n</li>\n<li><p><code>DOM.offsetLeft</code>：返回当前元素左上角相对于 HTMLElement.offsetParent (距离元素的最近的父级定位元素) 节点的左边界偏移的像素值。</p>\n</li>\n<li><p><code>DOM.scrollLeft</code> 属性可以读取或设置元素滚动条到元素左边的距离。</p>\n</li>\n</ol>\n"},"next":{"path":"_blogs/SPA/react的状态管理/利用react-redux.md","url":"/blog/SPA/react的状态管理/利用react-redux","title":"react的状态管理—利用react-redux","author":"yrobot","keywords":"react,redux,状态管理,利用","createTime":1537632000000,"length":3545,"content":"<p><strong>本页目录：</strong><br><a href=\"#index\">场景思考</a><br><a href=\"#redux\">利用react-redux</a><br><a href=\"#result\">查看效果</a><br><a href=\"#code\">查看代码</a>  </p>\n<p><a id='index'></a></p>\n<h2 id=\"场景思考\">场景思考</h2>\n<p>现在我们用react去写一篇博客<br>博客包含 <code>标题</code> 和 <code>内容</code><br>而我期望<code>标题</code>和<code>内容</code>的颜色可以一键修改  </p>\n<p>当然最暴力的实现方式就是利用dom操作去被动的修改<br>但是有没有更优雅更可控的方式呢？  </p>\n<p>首先来看看项目的组件树：<br><img src=\"https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg\" alt=\"\"></p>\n<p>那么有什么好的优雅的方式使<code>Title</code>和<code>Content</code>的颜色保持一致呢？<br>换句话说，怎么更好的管理<code>Title</code>和<code>Content</code>的状态呢？ </p>\n<h4 id=\"回顾上一节\">回顾上一节</h4>\n<p>上一节我们使用react自带的 <a href=\"../%E5%88%A9%E7%94%A8context%E6%B3%A8%E5%85%A5\">\b利用context注入</a> 方法<br>利用react的context去实现状态共享很方便<br>但是react的context还是实验性的，何时会更新无法预知<br>所以为了保证软件的稳定性，我们还是使用react推荐的第三方状态管理redux   </p>\n<p><a id='redux'></a></p>\n<h2 id=\"利用react-redux\">利用react-redux</h2>\n<p>redux 是一套专业解决应用状态管理的独立的通用模块\b<br>它不仅可以和react结合，形成react-redux，也可以和vue、angular结合  </p>\n<p><strong>react-redux的作用：</strong> 类似于\breact的context，\breact-redux在顶层组件利用Provider将store注入，在需要用到状态的组件处用connect函数包裹，从组件的props中获取store  </p>\n<p><strong>react-redux的使用方法：</strong>  </p>\n<ol>\n<li>根据全局数据，将其拆分为多个<code>reducer</code></li>\n<li>对于每个<code>reducer</code>分配<code>state</code>（<code>reducers.reducer</code>）和<code>action</code>，处理对应的<code>action</code>操作，生成行的<code>state</code></li>\n<li>将<code>reducer</code>合并成<code>reducers</code>,<code>reducers</code>分配传入的<code>state</code>和<code>action</code>操作到<code>reducer</code> </li>\n<li><code>createStore()</code>传入<code>reducers</code>生成<code>store</code>，并用<code>Provider</code>将<code>store</code>注入顶层组件</li>\n<li>在要引用<code>store</code>的组件部分用<code>connect()</code>连接，<code>connect()</code>会注册监听、将<code>dispatch()</code>[默认写入]和<code>mapStateToProps</code>的属性写入<code>props</code>，当然如果使用<code>mapDispatchToProps</code>生成的<code>action creator</code>也会写入<code>props</code>。</li>\n<li>在组件中通过<code>props</code>获取5中写入<code>props</code>的数据即可使用。</li>\n<li>通过<code>dispatch()</code>的参数会触发<code>reducers</code>的<code>action</code>操作，从而更新状态  </li>\n</ol>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fvlqv6xb3uj30yu0sagqj.jpg\" alt=\"\"></p>\n<p><strong>react-redux的优势：</strong> </p>\n<ol>\n<li>相对于react自带的context，react-redux更加稳定成熟，并对性能进行了优化  </li>\n<li>相对于props的状态提升，react-redux更加的方便简洁，整个全局状态也更加清晰   </li>\n</ol>\n<p><strong>老话说的好，杀鸡焉用牛刀，在简单场景直接使用状态提升即可</strong>  </p>\n<p><a id='result'></a></p>\n<h2 id=\"查看效果\">查看效果</h2>\n<ol>\n<li><img src=\"https://ws3.sinaimg.cn/large/006tNbRwgy1fvhmmoieh4j31kw0nxdpk.jpg\" alt=\"\"></li>\n<li><img src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fvhmmukgfyj31kw0o2qcy.jpg\" alt=\"\"></li>\n</ol>\n<p><a id='code'></a></p>\n<h2 id=\"查看代码\">查看代码</h2>\n<p>reducers.js生成全局状态：  </p>\n<pre><code>import { combineReducers } <span class=\"hljs-keyword\">from</span> &#x27;redux&#x27;\n\n<span class=\"hljs-keyword\">const</span> mainColor = (<span class=\"hljs-keyword\">state</span> = &#x27;black&#x27;,action)=&gt;{\n    switch (action.type){\n        case &#x27;CHANGE_COLOR&#x27;:\n            <span class=\"hljs-keyword\">state</span> = action.color;\n            return <span class=\"hljs-keyword\">state</span>;\n        <span class=\"hljs-keyword\">default</span>:\n            return <span class=\"hljs-keyword\">state</span>;\n    }\n}\n\nexport <span class=\"hljs-keyword\">default</span> combineReducers({\n    mainColor,\n})\n</code></pre>\n<p>BlogPage.js中\b生成store，并利用Provider注入顶层组件：</p>\n<pre><code><span class=\"hljs-keyword\">import</span> reducers <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./reducers.js&#x27;</span>\n\n<span class=\"hljs-keyword\">const</span> store = createStore(reducers);\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BlogPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> {\n        <span class=\"hljs-built_in\">super</span>(props);\n        <span class=\"hljs-built_in\">this</span>.state = {\n        }\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n        <span class=\"hljs-keyword\">return</span> (\n            <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Provider</span> <span class=\"hljs-attr\">store</span> = <span class=\"hljs-string\">{store}</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span> =<span class=\"hljs-string\">&quot;blogContainer&quot;</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> &gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Header</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Main</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Main</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Provider</span>&gt;</span></span>\n        );\n    }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> BlogPage;\n</code></pre>\n<p>Content.js中利用connect()函数将状态写入组件props：  </p>\n<pre><code><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Content</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> {\n        <span class=\"hljs-built_in\">super</span>(props);\n        <span class=\"hljs-built_in\">this</span>.state = {}\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n        <span class=\"hljs-keyword\">const</span> {mainColor,changeMainColor} = <span class=\"hljs-built_in\">this</span>.props;\n        <span class=\"hljs-keyword\">return</span> (\n            <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;content&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">color:</span> <span class=\"hljs-attr\">mainColor</span> }}&gt;</span>\n                内容...\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;button&quot;</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> { changeMainColor(&#x27;#&#x27; + (Math.random() * 0xffffff &lt;&lt; 0).toString(16)) }}&gt;切换颜色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n\n        );\n    }\n}\n\n<span class=\"hljs-keyword\">const</span> mapStateToProps = <span class=\"hljs-function\"><span class=\"hljs-params\">state</span> =&gt;</span> ({  <span class=\"hljs-comment\">//引入状态到props，并注册监听变化</span>\n    <span class=\"hljs-attr\">mainColor</span>: state.mainColor\n})\n\n<span class=\"hljs-keyword\">const</span> mapDispatchToProps = <span class=\"hljs-function\"><span class=\"hljs-params\">dispatch</span> =&gt;</span> ({ <span class=\"hljs-comment\">//引入方法到props</span>\n    <span class=\"hljs-attr\">changeMainColor</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">color</span> =&gt;</span> {\n        dispatch({\n            <span class=\"hljs-attr\">type</span>:<span class=\"hljs-string\">&#x27;CHANGE_COLOR&#x27;</span>,\n            color,\n        })\n    }\n})\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> connect(  <span class=\"hljs-comment\">//绑定组件 //高阶组件:函数接受一个组件作为参数，并返回一个新的组件</span>\n    mapStateToProps,\n    mapDispatchToProps\n)(Content);\n</code></pre>\n"}},"__N_SSG":true}