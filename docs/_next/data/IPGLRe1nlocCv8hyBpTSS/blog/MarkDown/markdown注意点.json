{"pageProps":{"pre":{"path":"_blogs/JS/遍历obj和array/README.md","url":"/blog/JS/遍历obj和array","title":"遍历obj和array","author":"yrobot","keywords":"array,obj,遍历","createTime":1535040000000,"length":1377,"content":"<p><strong>本页目录：</strong><br><a href=\"#for\">基础for循环</a><br><a href=\"#forin\">for in 循环</a><br><a href=\"#forof\">for of 循环</a><br><a href=\"#foreach\">array.forEach()方法</a><br><a href=\"#summary\">总结</a>  </p>\n<p><a id='for'></a></p>\n<h2 id=\"1-基础for循环\">1. 基础for循环</h2>\n<pre><code><span class=\"hljs-keyword\">for</span> (var <span class=\"hljs-keyword\">index</span> = <span class=\"hljs-number\">0</span>; <span class=\"hljs-keyword\">index</span> &lt; myArray.<span class=\"hljs-built_in\">length</span>; <span class=\"hljs-keyword\">index</span>++) {\n  console.<span class=\"hljs-built_in\">log</span>(myArray[<span class=\"hljs-keyword\">index</span>]);\n}\n</code></pre>\n<p><a id='forin'></a></p>\n<h2 id=\"2-for-in-循环\">2. for in 循环</h2>\n<ul>\n<li>for...in 语句用于对数组或者对象的属性进行循环操作。<pre><code><span class=\"hljs-function\"><span class=\"hljs-title\">for</span><span class=\"hljs-params\">(let i in array)</span></span>  <span class=\"hljs-comment\">// i为数组的index：0，1，2，3.....</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">for</span><span class=\"hljs-params\">(let i in obj)</span></span>  <span class=\"hljs-comment\">// i为obj 的属性名</span>\n</code></pre>\n<img src=\"https://ws3.sinaimg.cn/large/006tNbRwgy1fukqtphbb9j31e60bwgmv.jpg\" alt=\"\">\n<a id='forof'></a></li>\n</ul>\n<h2 id=\"3-for-of-循环\">3. for of 循环</h2>\n<p>参考链接：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of</a></p>\n<pre><code><span class=\"hljs-keyword\">for</span> (let value of iterable) {  <span class=\"hljs-regexp\">//</span> value为属性值\n    <span class=\"hljs-regexp\">//</span>statements\n}\n</code></pre>\n<p><strong>value</strong><br>在每次迭代中，将不同属性的值分配给变量。 </p>\n<p><strong>iterable</strong> ( Array，Map，Set，String，TypedArray，arguments 对象等等) (obj不是iterable)<br>被迭代枚举其属性的对象。<br><img src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fukqtq7vk6j31e60fqmzh.jpg\" alt=\"\">  </p>\n<p><a id='foreach'></a></p>\n<h2 id=\"4-arrayforeach方法\">4. array.forEach()方法</h2>\n<pre><code>arr.<span class=\"hljs-keyword\">for</span><span class=\"hljs-constructor\">Each(<span class=\"hljs-params\">function</span> <span class=\"hljs-params\">callback</span>(<span class=\"hljs-params\">value</span>[, <span class=\"hljs-params\">index</span>[, <span class=\"hljs-params\">array</span>]])</span> { <span class=\"hljs-comment\">// value:属性值，index:当前索引，array:当前遍历数组</span>\n    <span class=\"hljs-comment\">//your iterator</span>\n}<span class=\"hljs-literal\">[, <span class=\"hljs-identifier\">thisArg</span>]</span>);   <span class=\"hljs-comment\">// thisArg:作为callback函数的this值</span>\n</code></pre>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fukqto6spyj31ec0c0dh4.jpg\" alt=\"\"></p>\n<p><a id='summary'></a></p>\n<h2 id=\"总结\">总结</h2>\n<ol>\n<li>少用for of，支持不好。性能也一般。性能基础for优化较好</li>\n<li>遍历array，以上方法均可</li>\n<li>遍历obj思路：<ol>\n<li>获取obj的keys，利用基础for遍历</li>\n<li>for in利用属性名获取属性值</li>\n<li>利用object.keys()方法获取keys，再用keys.forEach()遍历获取属性值</li>\n</ol>\n</li>\n</ol>\n"},"blog":{"path":"_blogs/MarkDown/markdown注意点.md","url":"/blog/MarkDown/markdown注意点","title":"markdown注意点","author":"yrobot","keywords":"markdown,注意","createTime":1535040000000,"length":377,"content":"<p><strong>本页目录：</strong><br><a href=\"#url\">链接</a><br><a href=\"#snippet\">VS-Code:snippet</a>  </p>\n<p><a id='url'></a></p>\n<h2 id=\"链接\">链接</h2>\n<p><strong>链接跳转：</strong> <code>[描述](url)</code><br><strong>图片：</strong><code>![](url)</code>  </p>\n<p><strong>markdown语法要求：</strong>  </p>\n<ol>\n<li>页内锚点链接：字母要统统小写，空格统统要替换成 &#39;-&#39;。  </li>\n<li>外部链接：不可包含空格。  </li>\n</ol>\n<p>__解决方案__：直接使用a标签即可  </p>\n<p><a id='snippet'></a></p>\n<h2 id=\"vs-codesnippet\">VS-Code:snippet</h2>\n<ul>\n<li>可以在vscode用户代码块添加对markdown的snippet。</li>\n<li>个人vscode的.md文件一直不提示，无奈修改&quot;editor.action.triggerSuggest&quot;快捷键，强制唤醒md文件的代码提示。</li>\n</ul>\n"},"next":{"path":"_blogs/JS/JS多线程WebWorker/README.md","url":"/blog/JS/JS多线程WebWorker","title":"JS多线程Web Worker","author":"yrobot","keywords":"多线程,Worker,JS,Web","createTime":1534953600000,"length":3842,"content":"<p><strong>本页目录：</strong><br><a href=\"#why\">为什么使用 Web Woker</a><br><a href=\"#what\">Web Woker 是什么</a><br><a href=\"#support\">检测浏览器支持</a><br><a href=\"#new\">新建 Web Worker</a><br><a href=\"#message\">mainjs 与 worker 之间的数据传递</a><br><a href=\"#workerPro\">主线程中 worker 的属性</a><br><a href=\"#selfPro\">子线程中的全局属性</a><br><a href=\"#close\">关闭子线程</a></p>\n<p><a href=\"\" id=\"why\"></a></p>\n<h2 id=\"为什么使用-web-woker\">为什么使用 Web Woker</h2>\n<p>核心思想：一些容易阻塞主线程的事情，或者说主线程一个线程完成不了的事情（单页面多连接），可以交给 WebWoker</p>\n<h4 id=\"1-使用专用线程进行数学运算\">1. 使用专用线程进行数学运算</h4>\n<p>Web Worker 最简单的应用就是用来做后台计算，而这种计算并不会中断前台用户的操作</p>\n<h4 id=\"2-图像处理\">2. 图像处理</h4>\n<p>通过使用从<code>&lt;canvas&gt;</code>或者<code>&lt;video&gt;</code>元素中获取的数据，可以把图像分割成几个不同的区域并且把它们推送给并行的不同 Workers 来做计算</p>\n<h4 id=\"3-大量数据的检索\">3. 大量数据的检索</h4>\n<p>当需要在调用 ajax 后处理大量的数据，如果处理这些数据所需的时间长短非常重要，可以在 Web Worker 中来做这些，避免冻结 UI 线程。</p>\n<h4 id=\"4-背景数据分析\">4. 背景数据分析</h4>\n<p>由于在使用 Web Worker 的时候，我们有更多潜在的 CPU 可用时间，我们现在可以考虑一下 JavaScript 中的新应用场景。例如，我们可以想像在不影响 UI 体验的情况下实时处理用户输入。利用这样一种可能，我们可以想像一个像 Word（Office Web Apps 套装）一样的应用：当用户打字时后台在词典中进行查找，帮助用户自动纠错等等。</p>\n<p><a href=\"\" id=\"what\"></a></p>\n<h2 id=\"web-woker-是什么\">Web Woker 是什么</h2>\n<p>Web Worker 是 HTML5 标准的一部分，这一规范定义了一套 API，它允许一段 JavaScript 程序运行在主线程之外的另外一个线程中。Web Worker 规范中定义了两类工作线程，分别是专用线程 Dedicated Worker 和共享线程 Shared Worker，其中，Dedicated Worker 只能为一个页面所使用，而 Shared Worker 则可以被多个页面所共享。</p>\n<p><a href=\"\" id=\"support\"></a></p>\n<h2 id=\"检测浏览器支持\">检测浏览器支持</h2>\n<pre><code class=\"language-js\"><span class=\"hljs-regexp\">//</span>引入modernizr.js的情况\n<span class=\"hljs-keyword\">if</span> (!Modernizr.webworker) {\n  alert(<span class=\"hljs-string\">&quot;This browser doesn&#x27;t support Web Worker!&quot;</span>);\n}\n\n<span class=\"hljs-regexp\">//</span>未引入modernizr.js的情况\n<span class=\"hljs-keyword\">if</span> (typeof Worker !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span>) {\n  <span class=\"hljs-regexp\">//</span>支持\n} <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-regexp\">//</span>不支持code\n}\n</code></pre>\n<p><a href=\"\" id=\"new\"></a></p>\n<h2 id=\"新建-web-worker\">新建 Web Worker</h2>\n<p><code>var worker = new Worker(&quot;task.js&quot;); //在main.js中new一个woker</code></p>\n<p>浏览器原生提供 Worker()构造函数，用来供主线程生成 Worker 线程。<br><code>var myWorker = new Worker(jsUrl, [options]);</code></p>\n<p>Worker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// 主线程</span>\nvar myWorker = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Worker(&#x27;<span class=\"hljs-params\">worker</span>.<span class=\"hljs-params\">js</span>&#x27;, { <span class=\"hljs-params\">name</span>: &#x27;<span class=\"hljs-params\">myWorker</span>&#x27; })</span>;\n\n<span class=\"hljs-comment\">// Worker 线程</span>\nself.name; <span class=\"hljs-comment\">// myWorker</span>\n</code></pre>\n<p><a href=\"\" id=\"message\"></a></p>\n<h2 id=\"mainjs-与-worker-之间的数据传递\">mainjs 与 worker 之间的数据传递</h2>\n<h4 id=\"主线程sendworker：\">主线程—send—&gt;worker：</h4>\n<pre><code class=\"language-js\"><span class=\"hljs-title\">worker</span>.postMessage(<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span>);</span>\n//<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span>可以死各种类型的数据、string、object、array、number。。。</span>\n//子线程通过监听函数参数e的<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span>属性获取上述<span class=\"hljs-keyword\">data</span></span>\n</code></pre>\n<h4 id=\"主线程getworker：\">主线程&lt;—get—worker：</h4>\n<pre><code class=\"language-js\">worker.onmessage = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Received message &#x27;</span> + event.data);\n  <span class=\"hljs-comment\">//相应业务操作</span>\n};\n</code></pre>\n<h4 id=\"workersend主线程：\">worker—send—&gt;主线程：</h4>\n<p><code>self.postMessage(data); //self指代worker线程全局对象(同this) </code></p>\n<h4 id=\"workerget主线程：\">worker&lt;—get—主线程：</h4>\n<pre><code class=\"language-js\"><span class=\"hljs-built_in\">self</span>.addEventListener(\n  <span class=\"hljs-string\">&#x27;message&#x27;</span>,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(e)</span></span> {\n    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;Main data: &#x27;</span> + e.data);\n  },\n  <span class=\"hljs-literal\">false</span>,\n);\n</code></pre>\n<p><strong>so：</strong><br>当主线程或者子线程要传递 命令以及数据 时：可以传递一个对象<code>{cmd:&#39;go&#39;,data:&#39;dt&#39;}</code>。<br>接收者用<code>event.data.cmd</code>和<code>event.data.data</code>获取命令和数据。</p>\n<h4 id=\"例子：主线程传参-cmd-msg\">例子：主线程传参 <code>{cmd:&quot;&quot;, msg:&quot;&quot;}</code></h4>\n<pre><code class=\"language-js\"><span class=\"hljs-built_in\">self</span>.addEventListener(\n  <span class=\"hljs-string\">&#x27;message&#x27;</span>,\n  function (e) {\n    <span class=\"hljs-built_in\">var</span> <span class=\"hljs-built_in\">data</span> = e.<span class=\"hljs-built_in\">data</span>;\n    switch (<span class=\"hljs-built_in\">data</span>.cmd) {\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;start&#x27;</span>:\n        <span class=\"hljs-built_in\">self</span>.postMessage(<span class=\"hljs-string\">&#x27;WORKER STARTED: &#x27;</span> + <span class=\"hljs-built_in\">data</span>.msg);\n        break;\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;stop&#x27;</span>:\n        <span class=\"hljs-built_in\">self</span>.postMessage(<span class=\"hljs-string\">&#x27;WORKER STOPPED: &#x27;</span> + <span class=\"hljs-built_in\">data</span>.msg);\n        <span class=\"hljs-built_in\">self</span>.close(); <span class=\"hljs-comment\">// Terminates the worker.</span>\n        break;\n      default:\n        <span class=\"hljs-built_in\">self</span>.postMessage(<span class=\"hljs-string\">&#x27;Unknown command: &#x27;</span> + <span class=\"hljs-built_in\">data</span>.msg);\n    }\n  },\n  <span class=\"hljs-literal\">false</span>,\n);\n</code></pre>\n<p><a href=\"\" id=\"workerPro\"></a></p>\n<h2 id=\"主线程中-worker-的属性\">主线程中 worker 的属性</h2>\n<ul>\n<li>Worker.onerror：指定 error 事件的监听函数。</li>\n<li>Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在 Event.data 属性中。</li>\n<li>Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>\n<li>Worker.postMessage()：向 Worker 线程发送消息。</li>\n<li>Worker.terminate()：立即终止 Worker 线程。</li>\n</ul>\n<p><strong>子线程的错误监听实例：</strong></p>\n<pre><code class=\"language-js\">worker.onerror(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log([<span class=\"hljs-string\">&#x27;ERROR: Line &#x27;</span>, e.lineno, <span class=\"hljs-string\">&#x27; in &#x27;</span>, e.filename, <span class=\"hljs-string\">&#x27;: &#x27;</span>, e.message].join(<span class=\"hljs-string\">&#x27;&#x27;</span>));\n});\n\n<span class=\"hljs-comment\">// 或者</span>\nworker.addEventListener(<span class=\"hljs-string\">&#x27;error&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) </span>{\n  <span class=\"hljs-comment\">// ...</span>\n});\n</code></pre>\n<p><a href=\"\" id=\"selfPro\"></a></p>\n<h2 id=\"子线程中的全局属性\">子线程中的全局属性</h2>\n<p>Web Worker 有自己的全局对象，不是主线程的 window，而是一个专门为 Worker 定制的全局对象.</p>\n<ul>\n<li>self.name：Worker 的名字。该属性只读，由构造函数指定。</li>\n<li>self.onmessage：指定 message 事件的监听函数。</li>\n<li>self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>\n<li>self.close()：关闭 Worker 线程。</li>\n<li>self.postMessage()：向产生这个 Worker 线程发送消息。</li>\n<li><strong>self.importScripts()：加载 JS 脚本。</strong></li>\n</ul>\n<p><a href=\"\" id=\"close\"></a></p>\n<h2 id=\"关闭子线程\">关闭子线程</h2>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// 主线程</span>\nworker.<span class=\"hljs-built_in\">terminate</span>();\n\n<span class=\"hljs-comment\">// Worker 线程</span>\nself.<span class=\"hljs-built_in\">close</span>();\n</code></pre>\n"}},"__N_SSG":true}