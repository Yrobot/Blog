{"pageProps":{"pre":{"path":"_blogs/JS/JS多线程WebWorker/README.md","url":"/blog/JS/JS多线程WebWorker","title":"JS多线程Web Worker","author":"yrobot","keywords":"多线程,Worker,JS,Web","createTime":1534953600000,"length":3839,"content":"<p><strong>本页目录：</strong><br><a href=\"#why\">为什么使用Web Woker</a><br><a href=\"#what\">Web Woker是什么</a><br><a href=\"#support\">检测浏览器支持</a><br><a href=\"#new\">新建Web Worker</a><br><a href=\"#message\">mainjs与worker之间的数据传递</a><br><a href=\"#workerPro\">主线程中worker的属性</a><br><a href=\"#selfPro\">子线程中的全局属性</a><br><a href=\"#close\">关闭子线程</a> </p>\n<p><a href=\"\" id=\"why\"></a></p>\n<h2 id=\"为什么使用web-woker\">为什么使用Web Woker</h2>\n<p>核心思想：一些容易阻塞主线程的事情，或者说主线程一个线程完成不了的事情（单页面多连接），可以交给WebWoker</p>\n<h4 id=\"1-使用专用线程进行数学运算\">1. 使用专用线程进行数学运算</h4>\n<p>Web Worker最简单的应用就是用来做后台计算，而这种计算并不会中断前台用户的操作</p>\n<h4 id=\"2-图像处理\">2. 图像处理</h4>\n<p>通过使用从<code>&lt;canvas&gt;</code>或者<code>&lt;video&gt;</code>元素中获取的数据，可以把图像分割成几个不同的区域并且把它们推送给并行的不同Workers来做计算</p>\n<h4 id=\"3-大量数据的检索\">3. 大量数据的检索</h4>\n<p>当需要在调用 ajax后处理大量的数据，如果处理这些数据所需的时间长短非常重要，可以在Web Worker中来做这些，避免冻结UI线程。</p>\n<h4 id=\"4-背景数据分析\">4. 背景数据分析</h4>\n<p>由于在使用Web Worker的时候，我们有更多潜在的CPU可用时间，我们现在可以考虑一下JavaScript中的新应用场景。例如，我们可以想像在不影响UI体验的情况下实时处理用户输入。利用这样一种可能，我们可以想像一个像Word（Office Web Apps 套装）一样的应用：当用户打字时后台在词典中进行查找，帮助用户自动纠错等等。</p>\n<p><a href=\"\" id=\"what\"></a>  </p>\n<h2 id=\"web-woker是什么\">Web Woker是什么</h2>\n<p>Web Worker 是HTML5标准的一部分，这一规范定义了一套 API，它允许一段JavaScript程序运行在主线程之外的另外一个线程中。Web Worker 规范中定义了两类工作线程，分别是专用线程Dedicated Worker和共享线程 Shared Worker，其中，Dedicated Worker只能为一个页面所使用，而Shared Worker则可以被多个页面所共享。</p>\n<p><a href=\"\" id=\"support\"></a></p>\n<h2 id=\"检测浏览器支持\">检测浏览器支持</h2>\n<pre><code>//引入modernizr.js的情况\nif(!Modernizr.webworker){\n    alert(&quot;This browser doesn&#39;t support Web Worker!&quot;);\n}  \n\n//未引入modernizr.js的情况\nif(typeof(Worker)!==&quot;undefined&quot;){\n    //支持\n}else{\n    //不支持code\n}\n</code></pre>\n<p><a href=\"\" id=\"new\"></a></p>\n<h2 id=\"新建web-worker\">新建Web Worker</h2>\n<p><code>var worker = new Worker(&quot;task.js&quot;); //在main.js中new一个woker</code></p>\n<p>浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。<br><code>var myWorker = new Worker(jsUrl, [options]);</code></p>\n<p>Worker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。</p>\n<pre><code>// 主线程\nvar myWorker = new Worker(&#39;worker.js&#39;, { name : &#39;myWorker&#39; });\n\n// Worker 线程\nself.name // myWorker\n</code></pre>\n<p><a href=\"\" id=\"message\"></a></p>\n<h2 id=\"mainjs与worker之间的数据传递\">mainjs与worker之间的数据传递</h2>\n<h4 id=\"主线程sendworker：\">主线程—send—&gt;worker：</h4>\n<pre><code>worker.postMessage(data);   \n//data可以死各种类型的数据、string、object、array、number。。。  \n//子线程通过监听函数参数e的data属性获取上述data  \n</code></pre>\n<h4 id=\"主线程getworker：\">主线程&lt;—get—worker：</h4>\n<pre><code>worker.onmessage = function (event) {  \n  console.log(&#39;Received message &#39; + event.data);  \n  //相应业务操作  \n}  \n</code></pre>\n<h4 id=\"workersend主线程：\">worker—send—&gt;主线程：</h4>\n<p><code>self.postMessage(data);  //self指代worker线程全局对象(同this) </code>  </p>\n<h4 id=\"workerget主线程：\">worker&lt;—get—主线程：</h4>\n<pre><code>self.addEventListener(&#39;message&#39;, function (e) {  \n  console.log(&#39;Main data: &#39; + e.data);  \n}, false);  \n</code></pre>\n<p><strong>so：</strong><br>当主线程或者子线程要传递 命令以及数据 时：可以传递一个对象<code>{cmd:&#39;go&#39;,data:&#39;dt&#39;}</code>。<br>接收者用<code>event.data.cmd</code>和<code>event.data.data</code>获取命令和数据。  </p>\n<h4 id=\"例子：主线程传参-cmd-msg\">例子：主线程传参 <code>{cmd:&quot;&quot;, msg:&quot;&quot;}</code></h4>\n<pre><code>self.addEventListener(&#39;message&#39;, function (e) {  \n  var data = e.data;  \n  switch (data.cmd) {  \n    case &#39;start&#39;:  \n      self.postMessage(&#39;WORKER STARTED: &#39; + data.msg);  \n      break;  \n    case &#39;stop&#39;:  \n      self.postMessage(&#39;WORKER STOPPED: &#39; + data.msg);  \n      self.close(); // Terminates the worker.  \n      break;  \n    default:  \n      self.postMessage(&#39;Unknown command: &#39; + data.msg);  \n  };  \n}, false);  \n</code></pre>\n<p><a href=\"\" id=\"workerPro\"></a></p>\n<h2 id=\"主线程中worker的属性\">主线程中worker的属性</h2>\n<ul>\n<li>Worker.onerror：指定 error 事件的监听函数。  </li>\n<li>Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。  </li>\n<li>Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。   </li>\n<li>Worker.postMessage()：向 Worker 线程发送消息。  </li>\n<li>Worker.terminate()：立即终止 Worker 线程。  </li>\n</ul>\n<p><strong>子线程的错误监听实例：</strong>   </p>\n<pre><code>worker.onerror(function (event) {\n  console.log([\n    &#39;ERROR: Line &#39;, e.lineno, &#39; in &#39;, e.filename, &#39;: &#39;, e.message\n  ].join(&#39;&#39;));\n});\n\n// 或者\nworker.addEventListener(&#39;error&#39;, function (event) {\n  // ...\n});\n</code></pre>\n<p><a href=\"\" id=\"selfPro\"></a></p>\n<h2 id=\"子线程中的全局属性\">子线程中的全局属性</h2>\n<p>Web Worker 有自己的全局对象，不是主线程的window，而是一个专门为 Worker 定制的全局对象.  </p>\n<ul>\n<li>self.name：Worker 的名字。该属性只读，由构造函数指定。  </li>\n<li>self.onmessage：指定message事件的监听函数。  </li>\n<li>self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。  </li>\n<li>self.close()：关闭 Worker 线程。  </li>\n<li>self.postMessage()：向产生这个 Worker 线程发送消息。  </li>\n<li><strong>self.importScripts()：加载 JS 脚本。</strong>  </li>\n</ul>\n<p><a href=\"\" id=\"close\"></a></p>\n<h2 id=\"关闭子线程\">关闭子线程</h2>\n<pre><code>// 主线程\nworker.terminate();\n\n// Worker 线程\nself.close();\n```---\n</code></pre>\n"},"blog":{"path":"_blogs/JSON/JSON使用注意点.md","url":"/blog/JSON/JSON使用注意点","title":"JSON使用注意点","slug":"home","author":"yrobot","keywords":"JSON,注意,使用","createTime":1534953600000,"length":1675,"content":"<p><strong>本页目录：</strong><br><a href=\"#import\">关于引入</a><br><a href=\"#todo\">关于操作</a>  </p>\n<p><a href=\"\" id=\"import\"></a></p>\n<h2 id=\"关于引入？\">关于引入？</h2>\n<p>早期的JSON解析器基本上就是使用JavaScript的eval()函数。由于JSON是JavaScript语法的自己，因此eval()函数可以解析、解释并返回JavaScript的对象和数组。</p>\n<p>ECMAScript 5对解析JSON的行为进行了规范，定义了全局对象JSON。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fuklqfg3zcj30hi06sjro.jpg\" alt=\"\">\n据网上资料，浏览器对JSON的支持情况 ： IE8 chrome1+ safari3+ firefox3+，所以在这些浏览器中使用JSON可以不引入json2.js，在其他低版本浏览器中需要引入json2.js。所以，默认引入即可，去除注释的json2也才8kb不到。</p>\n<p><a href=\"\" id=\"todo\"></a></p>\n<h2 id=\"关于操作？\">关于操作？</h2>\n<ul>\n<li> <strong>JSON.parse(string) ：接受一个 JSON字符串 并将其转换成一个 JavaScript 对象。</strong></li>\n<li> <strong>JSON.stringify(obj) ：接受一个 JavaScript 对象并将其转换为一个 JSON字符串。</strong></li>\n</ul>\n<h4 id=\"1-jsonparse-不允许在末尾添加多余的逗号\">1. <strong>JSON.parse() 不允许在末尾添加多余的逗号</strong></h4>\n<ul>\n<li>下面两行代码都会抛出错误:<br>1 JSON.parse(&#39;[1, 2, 3, 4, ]&#39;);<br>2 JSON.parse(&#39;{&quot;foo&quot; : 1, }&#39;);<br>3 // SyntaxError JSON.parse: unexpected character<br>4 // at line 1 column 14 of the JSON data  </li>\n<li>省略末尾多余的逗号解析 JSON 就是正确:<br>1 JSON.parse(&#39;[1, 2, 3, 4 ]&#39;);<br>2 JSON.parse(&#39;{&quot;foo&quot; : 1 }&#39;);  </li>\n</ul>\n<h4 id=\"2-json-的属性名必须使用双引号\">2. <strong>JSON 的属性名必须使用双引号</strong></h4>\n<ul>\n<li>属性名上不能使用单引号，例如： &#39;foo&#39;。<br>1 JSON.parse(&quot;{&#39;foo&#39; : 1 }&quot;);<br>2 // SyntaxError: JSON.parse: expected property name or &#39;}&#39;<br>3 // at line 1 column 2 of the JSON data  </li>\n<li>取而代之，写成 &quot;foo&quot;：<br>1 JSON.parse(&#39;{&quot;foo&quot; : 1 }&#39;);  </li>\n</ul>\n<h4 id=\"3-数字不能用-0-开头，比如01，并且你的小数点后面必须跟着至少一个数字。\">3. <strong>数字不能用 0 开头，比如01，并且你的小数点后面必须跟着至少一个数字。</strong></h4>\n<ul>\n<li>数字不能用 0 开头，比如01 ,小数点后面必须跟着至少一个数字。\n1 JSON.parse(&#39;{&quot;foo&quot; : 01 }&#39;);<br>2 // SyntaxError: JSON.parse: expected &#39;,&#39; or &#39;}&#39; after property value<br>3 // in object at line 1 column 2 of the JSON data<br>|\n4 JSON.parse(&#39;{&quot;foo&quot; : 1. }&#39;);<br>5 // SyntaxError: JSON.parse: unterminated fractional number<br>6 // at line 1 column 2 of the JSON data  </li>\n<li>正确的写法应该是只写一个1，不书写前面的0。在小数点的后面至少要跟上一个数字:<br>1 JSON.parse(&#39;{&quot;foo&quot; : 1 }&#39;);<br>2 JSON.parse(&#39;{&quot;foo&quot; : 1.0 }&#39;);  </li>\n</ul>\n"},"next":null},"__N_SSG":true}