{"pageProps":{"pre":{"path":"_blogs/JS/DOM操作/README.md","url":"/blog/JS/DOM操作","title":"DOM操作","author":"yrobot","keywords":"DOM,操作","createTime":1537977600000,"length":6547,"content":"<p><a id='top'></a></p>\n<p><strong>本页目录：</strong><br><a href=\"#nh\">NodeList 和 HTMLCollection</a><br><a href=\"#get\">获取DOM节点的方法</a><br><a href=\"#create\">生成节点的方法</a><br><a href=\"#action\">DOM操作方法</a><br><a href=\"#near\">关系节点获取</a><br><a href=\"#props\">元素属性设置</a><br><a href=\"#style\">元素样式修改</a><br><a href=\"#position\">获取元素宽高、位置</a>  </p>\n<p><a id='nh'></a></p>\n<h2 id=\"nodelist-和-htmlcollection\">NodeList 和 HTMLCollection</h2>\n<h4 id=\"共同点：\">共同点：</h4>\n<ol>\n<li>都是类数组对象，都有length属性</li>\n<li>都有共同的方法：item，可以通过item(index)或者item(id)来访问返回结果中的元素</li>\n<li>都是实时变动的（live），document上的更改会反映到相关对象上（例外：document.querySelectorAll返回的NodeList不是实时的） </li>\n</ol>\n<h4 id=\"不同点：\">不同点：</h4>\n<ol>\n<li>NodeList可以包含任何节点类型（包括换行、元素间的文字），HTMLCollection只包含元素节点（elementNode），elementNode就是HTML中的标签</li>\n<li>HTMLCollection比NodeList多一项方法：namedItem，可以通过传递id或name属性来获取节点信息</li>\n</ol>\n<p><a id='get'></a></p>\n<h2 id=\"获取dom节点的方法\">获取DOM节点的方法</h2>\n<ol>\n<li><p><code>document.getElementById</code> ：根据ID查找元素，大小写敏感，如果有多个结果，只返回第一个；只能document调用</p>\n</li>\n<li><p><code>DOM.getElementsByClassName</code> ：根据类名查找元素，多个类名用空格分隔，返回一个 HTMLCollection 。</p>\n</li>\n<li><p><code>DOM.getElementsByTagName</code> ：根据标签查找元素， * 表示查询所有标签，返回一个 HTMLCollection 。</p>\n</li>\n<li><p><code>document.getElementsByName</code> ：根据元素的name属性查找，返回一个 NodeList 。只能document调用</p>\n</li>\n<li><p><code>DOM.querySelector</code> ：返回单个Node，如果匹配到多个结果，只返回第一个。</p>\n</li>\n<li><p><code>DOM.querySelectorAll</code> ：返回一个 NodeList。不是实时的。</p>\n</li>\n<li><p><code>document.forms</code> ：获取当前页面所有form，返回一个 HTMLCollection ；</p>\n</li>\n<li><p><code>document.documentElement</code>：获取html节点</p>\n</li>\n<li><p> <code>document.body</code>：获取body节点</p>\n</li>\n</ol>\n<p><a id='create'></a></p>\n<h2 id=\"生成节点的方法\">生成节点的方法</h2>\n<ol>\n<li><p><code>document.createElement(&quot;p&quot;)</code>：生成HTML节点元素，参数为节点类型</p>\n</li>\n<li><p><code>document.createTextNode(&quot;text&quot;)</code>:文本内容（无标签包裹），节点间的文本、节点内的文本</p>\n</li>\n<li><p><code>DOM.cloneNode()</code>：方法创建节点的拷贝，并返回该副本。</p>\n</li>\n</ol>\n<p><a id='action'></a></p>\n<h2 id=\"dom操作方法\">DOM操作方法</h2>\n<h3 id=\"添加元素：\">添加元素：</h3>\n<ol>\n<li><code>DOM.appendChild(元素)</code>：在DOM节点末尾添加元素</li>\n<li><code>parentNode.insertBefore(newNode, refNode)</code>：在redNode前添加新元素newNode</li>\n<li><code>DOM.insertAdjacentElement(position,ele)</code>：在DOM指定位置添加元素</li>\n<li><code>DOM.insertAdjacentHTML(position, text)</code>：同上<br> <strong>position</strong><br> A DOMString representing the position relative to the element; must be one of the following strings: 相对于p节点<br> 取值：<code>&#39;beforebegin&#39;</code>、<code>&#39;afterbegin&#39;</code>、<code>&#39;beforeend&#39;</code>、<code>&#39;afterend&#39;</code>  <pre><code>    &lt;!-- beforebegin --&gt;\n    &lt;p&gt;\n        &lt;!-- afterbegin --&gt;\n        foo\n        &lt;!-- beforeend --&gt;\n    &lt;/p&gt;\n    &lt;!-- afterend --&gt;\n</code></pre>\n <strong>text</strong><br> text is the string to be parsed as HTML or XML and inserted into the tree.例如<code>&#39;&lt;div id=&quot;two&quot;&gt;two&lt;/div&gt;&#39;</code><br> <strong>element</strong><br> 要插入到树中的元素.  </li>\n</ol>\n<h3 id=\"删除元素：\">删除元素：</h3>\n<ol>\n<li><code>parentNode.removeChild(node)</code>：删除parentNode下的node节点，注意是实时更新的，删除时index会时时改变<pre><code>function removeNode(node)  \n{  \n    if(!node) return;  \n    if(node.parentNode) node.parentNode.removeChild(node);  \n}  \n</code></pre>\n</li>\n<li><code>parentNode.replaceChild(newChild, oldChild)</code>：将oldChild替换为newChild</li>\n</ol>\n<p><a id='near'></a></p>\n<h2 id=\"关系节点获取\">关系节点获取</h2>\n<ol>\n<li><p><code>parentNode</code> ：返回元素的父节点。Element的父节点可能是Element，Document或DocumentFragment；</p>\n</li>\n<li><p><code>parentElement</code> ：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element元素，如果不是，则返回null；</p>\n</li>\n<li><p><code>children</code> ：返回一个实时的 HTMLCollection ，子节点都是Element，IE9以下浏览器不支持；</p>\n</li>\n<li><p><code>childNodes</code> ：返回一个实时的 NodeList ，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等；</p>\n</li>\n<li><p><code>firstChild</code> ：返回第一个子节点，不存在返回null，与之相对应的还有一个 firstElementChild ；</p>\n</li>\n<li><p><code>lastChild</code> ：返回最后一个子节点，不存在返回null，与之相对应的还有一个 lastElementChild ；</p>\n</li>\n<li><p><code>previousSibling</code> ：返回节点的前一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点。</p>\n</li>\n<li><p><code>nextSibling</code> ：返回节点的后一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点。</p>\n</li>\n<li><p> <code>previousElementSibling</code> ：返回前一个element元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。</p>\n</li>\n<li><p><code>nextElementSibling</code> ：返回后一个element元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。</p>\n</li>\n</ol>\n<p><a id='props'></a></p>\n<h2 id=\"元素属性设置\">元素属性设置</h2>\n<ol>\n<li><p><code>DOM.setAttribute(name, value)</code>: name是特性名，value是特性值，如 DOM.setAttribute(&#39;name&#39;, &#39;ele&#39;);</p>\n</li>\n<li><p><code>DOM.getAttribute(name)</code>: 返回指定的特性名相应的特性值，如果不存在，则返回nul</p>\n</li>\n<li><p><code>DOM.hasAttribute(name)</code>: 判断DOM是否存在name的属性</p>\n</li>\n<li><p><code>DOM.dataset</code>: 获取html data-开头的属性</p>\n<pre><code>&lt;div id=&quot;user&quot; data-id=&quot;1234567890&quot; data-user=&quot;johndoe&quot; data-date-of-birth&gt;John Doe&lt;/div&gt;\n\nlet el = document.querySelector(&#39;#user&#39;);\n// el.id == &#39;user&#39;\n// el.dataset.id === &#39;1234567890&#39;\n// el.dataset.user === &#39;johndoe&#39;\n// el.dataset.dateOfBirth === &#39;&#39;\n\nel.dataset.dateOfBirth = &#39;1960-10-03&#39;; // set the DOB.\n// &#39;someDataAttr&#39; in el.dataset === false\n\nel.dataset.someDataAttr = &#39;mydata&#39;;\n// &#39;someDataAttr&#39; in el.dataset === true\n</code></pre>\n</li>\n</ol>\n<p><a id='style'></a></p>\n<h2 id=\"元素样式修改\">元素样式修改</h2>\n<ol>\n<li><p>直接修改元素style样式： <em><code>element.sytle.xxx</code>只能获取到内联样式</em>  </p>\n<pre><code>elem.style.color = &#39;red&#39;;    \nelem.style.setProperty(&#39;font-size&#39;, &#39;16px&#39;);    \nelem.style.removeProperty(&#39;color&#39;); \n</code></pre>\n</li>\n<li><p>动态添加样式规则：  </p>\n<pre><code>var style = document.createElement(&#39;style&#39;);  \nstyle.innerHTML = &#39;body{color:red} #top:hover{background-color: red;color: white;}&#39;;  \ndocument.head.appendChild(style);  \n</code></pre>\n</li>\n<li><p>classList获取样式class<br> <strong><code>DOM.classList.xxx()</code>:</strong>   </p>\n<ul>\n<li>add( String [, String] )<br>添加指定的类值。如果这些类已经存在于元素的属性中，那么它们将被忽略。</li>\n<li>remove( String [,String] )<br>删除指定的类值。  </li>\n<li>item ( Number )<br>按集合中的索引返回类值。  </li>\n<li>toggle ( String [, force] )<br>当只有一个参数时：切换 class value; 即如果类存在，则删除它并返回false，如果不存在，则添加它并返回true。<br>当存在第二个参数时：如果第二个参数的计算结果为true，则添加指定的类值，如果计算结果为false，则删除它  </li>\n<li>contains( String )<br>检查元素的类属性中是否存在指定的类值。  </li>\n<li>replace( String, String )<br>用一个新类替换已有类。   </li>\n</ul>\n</li>\n<li><p>使用<code>window.getComputedStyle</code>： <em>借助<code>window.getComputedStyle</code>可以获取应用到元素上的所有样式</em><br> <code>let style = window.getComputedStyle(element, [pseudoElt]);</code>  </p>\n<ul>\n<li>element<br>用于获取计算样式的Element。  </li>\n<li>pseudoElt [可选]<br>指定一个要匹配的伪元素的字符串。必须对普通元素省略（或null）。 </li>\n</ul>\n<p> 返回的style是一个实时的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CSSStyleDeclaration\">CSSStyleDeclaration</a> 对象，当元素的样式更改时，它会自动更新本身。   </p>\n<pre><code>let elem = document.getElementById(&quot;elem-container&quot;);\nwindow.getComputedStyle(elem,null).height = &#39;100px&#39;;\n</code></pre>\n</li>\n</ol>\n<p><a id='position'></a></p>\n<h2 id=\"获取元素宽高、位置\">获取元素宽高、位置</h2>\n<ol>\n<li><p><code>getBoundingClientRect()</code>:<br> <code>DOM.getBoundingClientRect()</code>的属性：</p>\n<table>\n<thead>\n<tr>\n<th>Attribute</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bottom</td>\n<td>float</td>\n<td>Y 轴，相对于视口原点（viewport origin）矩形盒子的底部。只读。</td>\n</tr>\n<tr>\n<td>height</td>\n<td>float</td>\n<td>矩形盒子的高度（等同于 bottom 减 top）。只读。</td>\n</tr>\n<tr>\n<td>left</td>\n<td>float</td>\n<td>X 轴，相对于视口原点（viewport origin）矩形盒子的左侧。只读。</td>\n</tr>\n<tr>\n<td>right</td>\n<td>float</td>\n<td>X 轴，相对于视口原点（viewport origin）矩形盒子的右侧。只读。</td>\n</tr>\n<tr>\n<td>top</td>\n<td>float</td>\n<td>Y 轴，相对于视口原点（viewport origin）矩形盒子的顶部。只读。</td>\n</tr>\n<tr>\n<td>width</td>\n<td>float</td>\n<td>矩形盒子的宽度（等同于 right 减 left）。只读。</td>\n</tr>\n<tr>\n<td>x</td>\n<td>float</td>\n<td>X 轴，相对于视口原点（viewport origin）矩形盒子的左侧。只读。</td>\n</tr>\n<tr>\n<td>y</td>\n<td>float</td>\n<td>Y 轴，相对于视口原点（viewport origin）矩形盒子的顶部。只读。</td>\n</tr>\n<tr>\n<td>clientRect是一个 DOMRect 对象，包含width、height、left、top、right、bottom，它是相对于窗口顶部而不是文档顶部，__滚动页面时它们的值是会发生变化的__。</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n<li><p><code>DOM.clientWidth</code>：表示元素的内部宽度，以像素计。盒模型的content+padding</p>\n</li>\n<li><p><code>DOM.offsetLeft</code>：返回当前元素左上角相对于  HTMLElement.offsetParent (距离元素的最近的父级定位元素) 节点的左边界偏移的像素值。</p>\n</li>\n<li><p><code>DOM.scrollLeft</code> 属性可以读取或设置元素滚动条到元素左边的距离。</p>\n</li>\n</ol>\n"},"blog":{"path":"_blogs/SPA/react的状态管理/利用react-redux.md","url":"/blog/SPA/react的状态管理/利用react-redux","title":"react的状态管理—利用react-redux","author":"yrobot","keywords":"react,redux,状态管理,利用","createTime":1537632000000,"length":3545,"content":"<p><strong>本页目录：</strong><br><a href=\"#index\">场景思考</a><br><a href=\"#redux\">利用react-redux</a><br><a href=\"#result\">查看效果</a><br><a href=\"#code\">查看代码</a>  </p>\n<p><a id='index'></a></p>\n<h2 id=\"场景思考\">场景思考</h2>\n<p>现在我们用react去写一篇博客<br>博客包含 <code>标题</code> 和 <code>内容</code><br>而我期望<code>标题</code>和<code>内容</code>的颜色可以一键修改  </p>\n<p>当然最暴力的实现方式就是利用dom操作去被动的修改<br>但是有没有更优雅更可控的方式呢？  </p>\n<p>首先来看看项目的组件树：<br><img src=\"https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg\" alt=\"\"></p>\n<p>那么有什么好的优雅的方式使<code>Title</code>和<code>Content</code>的颜色保持一致呢？<br>换句话说，怎么更好的管理<code>Title</code>和<code>Content</code>的状态呢？ </p>\n<h4 id=\"回顾上一节\">回顾上一节</h4>\n<p>上一节我们使用react自带的 <a href=\"../%E5%88%A9%E7%94%A8context%E6%B3%A8%E5%85%A5\">\b利用context注入</a> 方法<br>利用react的context去实现状态共享很方便<br>但是react的context还是实验性的，何时会更新无法预知<br>所以为了保证软件的稳定性，我们还是使用react推荐的第三方状态管理redux   </p>\n<p><a id='redux'></a></p>\n<h2 id=\"利用react-redux\">利用react-redux</h2>\n<p>redux 是一套专业解决应用状态管理的独立的通用模块\b<br>它不仅可以和react结合，形成react-redux，也可以和vue、angular结合  </p>\n<p><strong>react-redux的作用：</strong> 类似于\breact的context，\breact-redux在顶层组件利用Provider将store注入，在需要用到状态的组件处用connect函数包裹，从组件的props中获取store  </p>\n<p><strong>react-redux的使用方法：</strong>  </p>\n<ol>\n<li>根据全局数据，将其拆分为多个<code>reducer</code></li>\n<li>对于每个<code>reducer</code>分配<code>state</code>（<code>reducers.reducer</code>）和<code>action</code>，处理对应的<code>action</code>操作，生成行的<code>state</code></li>\n<li>将<code>reducer</code>合并成<code>reducers</code>,<code>reducers</code>分配传入的<code>state</code>和<code>action</code>操作到<code>reducer</code> </li>\n<li><code>createStore()</code>传入<code>reducers</code>生成<code>store</code>，并用<code>Provider</code>将<code>store</code>注入顶层组件</li>\n<li>在要引用<code>store</code>的组件部分用<code>connect()</code>连接，<code>connect()</code>会注册监听、将<code>dispatch()</code>[默认写入]和<code>mapStateToProps</code>的属性写入<code>props</code>，当然如果使用<code>mapDispatchToProps</code>生成的<code>action creator</code>也会写入<code>props</code>。</li>\n<li>在组件中通过<code>props</code>获取5中写入<code>props</code>的数据即可使用。</li>\n<li>通过<code>dispatch()</code>的参数会触发<code>reducers</code>的<code>action</code>操作，从而更新状态  </li>\n</ol>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fvlqv6xb3uj30yu0sagqj.jpg\" alt=\"\"></p>\n<p><strong>react-redux的优势：</strong> </p>\n<ol>\n<li>相对于react自带的context，react-redux更加稳定成熟，并对性能进行了优化  </li>\n<li>相对于props的状态提升，react-redux更加的方便简洁，整个全局状态也更加清晰   </li>\n</ol>\n<p><strong>老话说的好，杀鸡焉用牛刀，在简单场景直接使用状态提升即可</strong>  </p>\n<p><a id='result'></a></p>\n<h2 id=\"查看效果\">查看效果</h2>\n<ol>\n<li><img src=\"https://ws3.sinaimg.cn/large/006tNbRwgy1fvhmmoieh4j31kw0nxdpk.jpg\" alt=\"\"></li>\n<li><img src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fvhmmukgfyj31kw0o2qcy.jpg\" alt=\"\"></li>\n</ol>\n<p><a id='code'></a></p>\n<h2 id=\"查看代码\">查看代码</h2>\n<p>reducers.js生成全局状态：  </p>\n<pre><code>import { combineReducers } from &#39;redux&#39;\n\nconst mainColor = (state = &#39;black&#39;,action)=&gt;{\n    switch (action.type){\n        case &#39;CHANGE_COLOR&#39;:\n            state = action.color;\n            return state;\n        default:\n            return state;\n    }\n}\n\nexport default combineReducers({\n    mainColor,\n})\n</code></pre>\n<p>BlogPage.js中\b生成store，并利用Provider注入顶层组件：</p>\n<pre><code>import reducers from &#39;./reducers.js&#39;\n\nconst store = createStore(reducers);\n\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n        }\n    }\n    render() {\n        return (\n            &lt;Provider store = {store}&gt;\n                &lt;div className =&quot;blogContainer&quot;&gt;\n                    &lt;Header &gt;&lt;/Header&gt;\n                    &lt;Main&gt;&lt;/Main&gt;\n                &lt;/div&gt;\n            &lt;/Provider&gt;\n        );\n    }\n}\n\nexport default BlogPage;\n</code></pre>\n<p>Content.js中利用connect()函数将状态写入组件props：  </p>\n<pre><code>class Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    render() {\n        const {mainColor,changeMainColor} = this.props;\n        return (\n            &lt;div className=&quot;content&quot; style={{ color: mainColor }}&gt;\n                内容...\n                &lt;div className=&quot;button&quot; onClick={() =&gt; { changeMainColor(&#39;#&#39; + (Math.random() * 0xffffff &lt;&lt; 0).toString(16)) }}&gt;切换颜色&lt;/div&gt;\n            &lt;/div&gt;\n\n        );\n    }\n}\n\nconst mapStateToProps = state =&gt; ({  //引入状态到props，并注册监听变化\n    mainColor: state.mainColor\n})\n\nconst mapDispatchToProps = dispatch =&gt; ({ //引入方法到props\n    changeMainColor: color =&gt; {\n        dispatch({\n            type:&#39;CHANGE_COLOR&#39;,\n            color,\n        })\n    }\n})\n\nexport default connect(  //绑定组件 //高阶组件:函数接受一个组件作为参数，并返回一个新的组件\n    mapStateToProps,\n    mapDispatchToProps\n)(Content);\n</code></pre>\n"},"next":{"path":"_blogs/SPA/react的状态管理/利用context注入.md","url":"/blog/SPA/react的状态管理/利用context注入","title":"react的状态管理—利用context注入","author":"yrobot","keywords":"context,状态管理,react,注入,利用","createTime":1537545600000,"length":3383,"content":"<p><strong>本页目录：</strong><br><a href=\"#index\">场景思考</a><br><a href=\"#context\">利用context注入</a><br><a href=\"#result\">查看效果</a><br><a href=\"#code\">查看代码</a>  </p>\n<p><a id='index'></a></p>\n<h2 id=\"场景思考\">场景思考</h2>\n<p>现在我们用react去写一篇博客<br>博客包含 <code>标题</code> 和 <code>内容</code><br>而我期望<code>标题</code>和<code>内容</code>的颜色可以一键修改  </p>\n<p>当然最暴力的实现方式就是利用dom操作去被动的修改<br>但是有没有更优雅更可控的方式呢？  </p>\n<p>首先来看看项目的组件树：<br><img src=\"https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg\" alt=\"\"></p>\n<p>那么有什么好的优雅的方式使<code>Title</code>和<code>Content</code>的颜色保持一致呢？<br>换句话说，怎么更好的管理<code>Title</code>和<code>Content</code>的状态呢？ </p>\n<h4 id=\"回顾上一节\">回顾上一节</h4>\n<p>上一节我们使用最基础的<a href=\"../%E5%88%A9%E7%94%A8props%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87\">props状态提升</a>的方法<br>但当组件链很长的时候，新增一个状态就必须修改每个组件的props<br>那有没有跟直接的方法，搞一个共享状态，每个组件可以自由访问呢<br>react自带的context就是用来实现这一点的  </p>\n<p><a id='context'></a></p>\n<h2 id=\"利用context注入\">利用context注入</h2>\n<p>react的context可以代替props的传递工作  </p>\n<p><strong>context的作用：</strong> 将顶部\b组件的状态和方法与子组件共享  </p>\n<p><strong>context的使用方法：</strong>  </p>\n<ol>\n<li>利用<code>React.createContext()</code>生成一对<code>{Provider,Consumer}</code>  </li>\n<li>用生成的<code>Provider</code>包裹\b顶部组件，利用他props的value字段传入共享状态与方法  <pre><code> &lt;Provider value={{状态和方法}}&gt;\n     &lt;顶层组件&gt;\n &lt;/Provider&gt;\n</code></pre>\n</li>\n<li>用生成的<code>Consumer</code>包裹使用共享状态的组件，在Consumer内子组件外用函数传入共享的状态  <pre><code> &lt;Consumer&gt;\n     {value =&gt; (\n         &lt;子组件 使用value&gt;\n     )}\n &lt;/Consumer&gt;\n</code></pre>\n</li>\n<li>保证状态位于顶层组件的<code>state</code>中，而共享的方法要更新状态也是利用<code>setState</code>，这样UI层才会刷新  </li>\n</ol>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fvhm1xim52j30yg0pqads.jpg\" alt=\"\"></p>\n<p><strong>context的优势：</strong> </p>\n<ol>\n<li>只需要在顶层组件和用到状态的子组件进行操作，省去了props状态提升中对中间组件的数据传递操作。代码更清晰。   </li>\n<li>无需引入第三方状态管理，学习成本也相对较低  </li>\n</ol>\n<p><strong>尽管context相对于props状态提升方便很多，\b但是react官网还是 <em>不建议</em> 使用context，因为context的API是实验性的，在未来的react版本中会被修改。</strong>  </p>\n<p><strong>在简单场景,推荐使用props状态提升</strong><br><strong>在较复杂的场景，应该考虑引入第三方状态管理(如Redux、Mobx)</strong>  </p>\n<p><a id='result'></a></p>\n<h2 id=\"查看效果\">查看效果</h2>\n<ol>\n<li><img src=\"https://ws3.sinaimg.cn/large/006tNbRwgy1fvhmmoieh4j31kw0nxdpk.jpg\" alt=\"\"></li>\n<li><img src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fvhmmukgfyj31kw0o2qcy.jpg\" alt=\"\"></li>\n</ol>\n<p><a id='code'></a></p>\n<h2 id=\"查看代码\">查看代码</h2>\n<p>mainColorContext.js暴露React.createContext：  </p>\n<pre><code>import React from &#39;react&#39;;\n\nexport const mainColorContext = React.createContext(\n    {\n        mainColor:&#39;black&#39;\n    } // 默认值\n);\n</code></pre>\n<p>BlogPage.js中引入mainColorContext，定义全局状态mainColor和方法changeMainColor()并传入Provider： </p>\n<pre><code>import {mainColorContext} from &#39;./mainColorContext.js&#39;\n\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            mainColor: &#39;black&#39;\n        }\n    }\n    changeMainColor = (color) =&gt; {\n        this.setState({ //this的绑定//运行时//但是箭头函数没有this//直接沿着作用域链往上找找到BlogPage类的this //换成function就不行了，obj.func()会修改this指向为obj\n            mainColor: color\n        })\n    }\n    render() {\n        const { mainColor } = this.state;\n        return (\n            &lt;mainColorContext.Provider value={{mainColor,changeMainColor:this.changeMainColor}}&gt;\n                &lt;div className=&quot;blogContainer&quot;&gt;\n                    &lt;Header &gt;&lt;/Header&gt;\n                    &lt;Main&gt;&lt;/Main&gt;\n                &lt;/div&gt;\n            &lt;/mainColorContext.Provider&gt;\n        );\n    }\n}\n</code></pre>\n<p>Content.js组件中获取使用Consumer传递的数据和方法：</p>\n<pre><code>import {mainColorContext} from &#39;../../BlogPage/mainColorContext.js&#39;\n\nclass Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    render() {\n        return (\n            &lt;mainColorContext.Consumer&gt;\n                {value =&gt; (\n                    &lt;div className=&quot;content&quot; style={{ color: value.mainColor }}&gt;\n                        文本...\n                    &lt;div className=&quot;button&quot; onClick={()=&gt;{value.changeMainColor(&#39;#&#39; + (Math.random() * 0xffffff &lt;&lt; 0).toString(16))}}&gt;切换颜色&lt;/div&gt;\n                    &lt;/div&gt;\n                )}\n            &lt;/mainColorContext.Consumer&gt;\n\n        );\n    }\n}\n</code></pre>\n"}},"__N_SSG":true}