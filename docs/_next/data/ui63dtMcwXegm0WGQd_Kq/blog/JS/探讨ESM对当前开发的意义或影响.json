{"pageProps":{"pre":{"path":"_blogs/JS/JS模块化/README.md","url":"/blog/JS/JS模块化","title":"JS模块化","author":"yrobot","keywords":"JS,模块化","createTime":1571068800000,"length":5024,"content":"<p><a id='top'></a></p>\n<p><strong>本页目录：</strong><br><a href=\"#pre\">前言</a><br><a href=\"#none\">无模块化</a><br><a href=\"#commonjs\">CommonJS规范</a><br><a href=\"#AMD\">AMD规范</a><br><a href=\"#CMD\">CMD规范</a><br><a href=\"#ES6\">ES6模块化</a><br><a href=\"#ES6CMJS\">CommonJs和ES6区别</a>  </p>\n<p><strong>友情连接：</strong><br>Q：那么新的ES6模块化对我们前端开发有什么意义呢？webpack就没有用了嘛？<br>A：<a href=\"../%E6%8E%A2%E8%AE%A8ESM%E5%AF%B9%E5%BD%93%E5%89%8D%E5%BC%80%E5%8F%91%E7%9A%84%E6%84%8F%E4%B9%89%E6%88%96%E5%BD%B1%E5%93%8D\">探讨ESM对当前开发的意义或影响</a></p>\n<p><a id='pre'></a></p>\n<h2 id=\"前言\">前言</h2>\n<p>其实一直以来我在前端开发中都会用到模块化的相关知识，但是我总是一知半解的。<br>而且目前完善的构建工具让我无需深入的了解前端模块的知识（用就得了，莽就行了）。<br>但是有一天，我的后端室友发给我了一篇 <a href=\"https://juejin.im/post/5d4bcdb7e51d453b386a62c6\">《愿未来没有 Webpack》</a></p>\n<p>读完我不禁陷入了沉思。。。<br>不知道是什么时候开始接收了webpack作为前端开发必备工具这件事了。<br>而为什么要用webpack这件事，却从来没有问过自己。<br>而文中提到的<a href=\"https://github.com/pikapkg/web\">@pika/web</a>，又是一个什么神奇的操作？</p>\n<p>经过一段时间的学习理解，发现这原来是JS模块化造成的，总结成一句话就是：<br><code>浏览器无法支持commonjs模块化，所以需要打包工具将所有依赖和自写代码打包到一个文件中；而因为浏览器渐渐开始原生支持ESM，所以只要将commonjs规范转换成ESM规范，就可以直接在浏览器中静态引用了</code>  </p>\n<p>所以在这探索的过程中，就不得不好好学习JS模块化的知识，本文就是对JS模块的一个学习总结 </p>\n<p>by the way, 以下讲的是一些规范（用于模块化的理论而已），具体实现参看具体实现框架/库  </p>\n<p><a id='none'></a></p>\n<h2 id=\"无模块化\">无模块化</h2>\n<p>表现形式：</p>\n<pre><code>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;jquery.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;main.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;other.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>直接在html中利用script标签引入js文件，并按照引入顺序一个一个执行，每个js都是用window全局作用域  </p>\n<h4 id=\"无模块化的问题：\">无模块化的问题：</h4>\n<ol>\n<li>文件有依赖关系时，被依赖的文件必须在依赖文件前利用script标签引入并执行</li>\n<li>js引入文件声明的全局变量等会 <strong>污染全局作用域</strong> ，如果两个文件的全局变量重名，还会出现报错（甚至出现因为变量共用导致逻辑出错而发现不了的问题）</li>\n<li>维护时， <strong>模块之间的依赖关系隐蔽</strong> ，直接通过全局变量使用，而不是声明式的</li>\n</ol>\n<p><a id='commonjs'></a></p>\n<h2 id=\"commonjs规范\">CommonJS规范</h2>\n<p>表现形式：</p>\n<pre><code>    <span class=\"hljs-regexp\">//</span> utils.js (导出)\n    const log = s=&gt;{ <span class=\"hljs-built_in\">console</span>.log(s) };\n    <span class=\"hljs-built_in\">module</span>.<span class=\"hljs-built_in\">exports</span>={ log };  //<span class=\"hljs-built_in\">exports</span> 是对 <span class=\"hljs-built_in\">module</span>.<span class=\"hljs-built_in\">exports</span> 的引用,注意js对象引用使用（直接对<span class=\"hljs-built_in\">exports</span>赋值无法修改<span class=\"hljs-built_in\">module</span>.<span class=\"hljs-built_in\">exports</span>）\n\n    ------------------文件分割线-----------------\n\n    <span class=\"hljs-regexp\">//</span> index.js\n    const {log} = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>);\n    log(<span class=\"hljs-string\">&quot;you see see you&quot;</span>);\n</code></pre>\n<h4 id=\"commonjs解决：\">commonjs解决：</h4>\n<ol>\n<li>声明依赖关系：利用exports和require声明暴露和引入，将模块的依赖关系展示出来</li>\n<li>可避免全局作用域的变量污染：打包完的模块代码在新的函数作用域中，所以可以避免同名变量的全局污染。\nPS：由于js遇到未声明变量的赋值操作会将该变量将被自动作为全局变量声明(<a href=\"https://www.iteye.com/blog/huangqiqing123-1788646\">点击此查看</a>)，使用严格模式可以避免这种情况的发生</li>\n</ol>\n<h4 id=\"commonjs弊端：\">commonjs弊端：</h4>\n<ol>\n<li>当然最主要的弊端是浏览器并不原生支持commonjs模块化  </li>\n<li>对于网上说的网络问题造成的模块引入慢，其实任何模块规范遇到网上模块引入到会有这个问题（从请求到执行很慢，多引用就多请求），所以也不算commonjs的弊端啦  </li>\n</ol>\n<h4 id=\"那么现在前端是怎么用commonjs的呢？：\">那么现在前端是怎么用commonjs的呢？：</h4>\n<p>目前前端使用commonjs的路子是：使用webpack等打包工具，在开发时可进使用commonjs，开发完成利用模块化工具会将模块的依赖关系进行梳理优化并将依赖打包到同一个文件中，这样就没有引用的问题了，以这种曲线救国的方法让开发可以使用commonjs进行模块引用。  </p>\n<p>这点可以参看webpack的<a href=\"https://webpack.toobug.net/zh-cn/chapter2/commonjs.html\">demo</a><br><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g7z1up3quqj30b60aumxq.jpg\" alt=\"\"><br>打包生成文件<br><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g7z1vvc9tfj30np0z00xq.jpg\" alt=\"\">  </p>\n<p>ps：这也是造成当前前端难以离开webpack等打包工具的尴尬现状的原因之一，但由于es6有了自己的模块导出和引入方法，而且目前浏览器对es6支持很好，所以@pika/web等依赖安装工具出现了。  </p>\n<p>回到最开始的问题，@pika/web依赖安装工具做了什么事： </p>\n<ol>\n<li>将commonjs导出的依赖模块进行打包，打包成一个js，并用es6导出语法进行导出  </li>\n<li>将所有生成模块js放入web_modules中<br>而我们就可以直接在js中根据路径引用这些依赖，只要在html中引入根script时加上type=&quot;module&quot;属性即可（告知浏览器这是个模块js）    </li>\n</ol>\n<p><a id='AMD'></a></p>\n<h2 id=\"amd规范\">AMD规范</h2>\n<p>非同步加载模块:Asynchronous module definition<br>所以AMD的优势就是可以异步加载模块  </p>\n<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出   </p>\n<p>AMD标准中，定义了下面三个API：   </p>\n<ol>\n<li>require([module], callback)  </li>\n<li>define(id, [depends], callback)  </li>\n<li>require.config()<br>即通过define来定义一个模块，然后使用require来加载一个模块, 使用require.config()指定引用路径。  </li>\n</ol>\n<p>使用时在html引入<script data-main=\"./alert\" src=\"./require.js\"></script>，data-main指定根js文件（原理就是遍历script标签，利用dom的getAttribute函数获取标签属性）  </p>\n<p>require.js实现原理参考：<a href=\"https://www.jianshu.com/p/5a39535909e4\">https://www.jianshu.com/p/5a39535909e4</a>  </p>\n<p><strong>关键逻辑</strong><br>根据执行文件中的引用将对应模块文件利用dom操作将script标签加入html执行，然后将返回的方法进行保存，在使用的时候返回缓存的依赖方法  </p>\n<h4 id=\"amd优点：\">AMD优点：</h4>\n<ol>\n<li>相比传统script标签引入，AMD依赖无需考虑引入顺序，依赖关系也清晰多了  </li>\n<li>采用异步加载，a加载不阻塞页面渲染，b不阻塞下文js执行（用到模块的代码必须放到回调函数里）  </li>\n</ol>\n<p><a id='CMD'></a></p>\n<h2 id=\"cmd规范\">CMD规范</h2>\n<p>通用模块定义：Common Module Definition<br>CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS  </p>\n<p>CMD推崇就近依赖，不像AMD在一开始就指明依赖，CMD只有在用到某个模块的时候再去require<br>这样，CMD就可以通过逻辑判断，避免用不到的模块的加载了  </p>\n<h4 id=\"cmd优势：\">CMD优势：</h4>\n<ol>\n<li>相比AMD，可以在执行到引入模块的代码时才去加载模块（即按需加载，提升性能） </li>\n</ol>\n<h4 id=\"cmd弊端：\">CMD弊端：</h4>\n<ol>\n<li>内部引入，依赖关系就不像commonjs和AMD那样明显了</li>\n</ol>\n<p><a id='ES6'></a></p>\n<h2 id=\"es6模块化\">ES6模块化</h2>\n<p>通过 <code>exprot</code> 关键字导出模块，使用 <code>import</code> 关键字引入模块  </p>\n<pre><code>    // utils.js (导出)\n    const <span class=\"hljs-keyword\">log</span> = s=&gt;{ console.log(s) };\n    export { <span class=\"hljs-keyword\">log</span> }; \n\n    <span class=\"hljs-comment\">------------------文件分割线-----------------</span>\n\n    // <span class=\"hljs-keyword\">index</span>.js\n    <span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">log</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>\n    log(&quot;you see see you&quot;);\n</code></pre>\n<p>根脚本script标签要添加 type=module 属性来标记来告诉浏览器用es6模块来引入这个脚本  </p>\n<p>兼容就浏览器的方法：  </p>\n<pre><code>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;module&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;app.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">nomodule</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;fallback.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>新版浏览器加载第一个 script 标签，忽略第二个；旧版不支持 type=module 的浏览器则忽略第一个，加载第二个。</p>\n<h4 id=\"note：\">note：</h4>\n<ol>\n<li>脚本加载方式默认为 defer，不会因为执行拥塞页面渲染，也支持 async  </li>\n<li>同一模块（url相同，包括后缀参数）用es6引入方法多次引入只执行一次  </li>\n<li>添加type=module的script标签CORS 跨域限制会更严格，如果服务器未返回有效的 Allow-Origin 相关 CORS 头，浏览器会禁止加载改脚本 </li>\n</ol>\n<h4 id=\"es6模块化的优势：\">es6模块化的优势：</h4>\n<ol>\n<li>当然当然当然是浏览器的原生支持啦，大部分浏览器以及支持es6模块化语法，查看<a href=\"https://caniuse.com/#feat=es6-module\">can i use</a>  </li>\n<li>使用es6模块引入的js脚本不会像普通脚本一样污染全局作用域（根层变量不会被声明到window中)  </li>\n</ol>\n<p><a id='ES6CMJS'></a></p>\n<h2 id=\"commonjs和es6区别\">CommonJs和ES6区别</h2>\n<ol>\n<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用<br> commonjs在输出时一般这么操作  <pre><code><span class=\"hljs-built_in\">module</span>.<span class=\"hljs-built_in\">exports</span> = {\n  counter: counter1,\n  incCounter: incCounter,\n};\n</code></pre>\n module.exposrts.counter是非引用变量赋值来的，所以值和counter1是分离的。<br> 可以使用函数获取来动态获取最新的counter1值  <pre><code><span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title\">counter</span>() {\n    <span class=\"hljs-keyword\">return</span> counter1\n  },\n  <span class=\"hljs-attr\">incCounter</span>: incCounter,\n};\n</code></pre>\n</li>\n<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</li>\n</ol>\n"},"blog":{"path":"_blogs/JS/探讨ESM对当前开发的意义或影响/README.md","url":"/blog/JS/探讨ESM对当前开发的意义或影响","title":"探讨ESM对当前开发的意义或影响","author":"yrobot","keywords":"ESM,探讨,意义,当前,开发,影响","createTime":1571068800000,"length":1414,"content":"<p><a id='top'></a></p>\n<p><strong>本页目录：</strong><br><a href=\"#compare\">对比当前模块开发和ES6模块化开发</a><br><a href=\"#ESMinit\">ESM init 优化方案</a><br><a href=\"#All\">总的来说</a>  </p>\n<p><strong>友情连接：</strong><br>Q：浏览器遇到多个script资源的时候是怎么做的呢？<br>A：<a href=\"../%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AAdefer%E6%88%96async%E7%9A%84script%E7%9A%84\">浏览器是怎么处理多个defer或async的script的</a></p>\n<p><a id='compare'></a></p>\n<h2 id=\"对比当前模块开发和es6模块化开发\">对比当前模块开发和ES6模块化开发</h2>\n<h4 id=\"开发方式对比\">开发方式对比</h4>\n<ul>\n<li><p>commonjs的模块化流程：  </p>\n<ul>\n<li>利用commonjs的模块规范进行引入使用，而npm大部分包也是用的commonjs规范写的。前端为了解决浏览器不支持commonjs模块，利用webpack等打包工具，将模块打包到一个js文件中，最后引入html。</li>\n</ul>\n</li>\n<li><p>es6模块化开发流程：  </p>\n<ul>\n<li>保证所有依赖支持es6的模块化规范，在html利用type=“module”来引入根js（cdn的js只能使用script引入）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"资源加载对比\">资源加载对比</h4>\n<ul>\n<li><p>commonjs的模块化：  </p>\n<ul>\n<li>原来的js文件被整合到一个js文件中，请求网页时，对于这些js只需发送一个script请求即可，只是这个js文件比较大。</li>\n</ul>\n</li>\n<li><p>es6模块化开发：  </p>\n<ul>\n<li>对于es6模块，浏览器解析到<code>&lt;script type=&quot;module&quot; src=&quot;..&quot;/&gt;</code>时，因为type=&quot;module&quot;的script默认defer，所以页面会继续解析渲染不受js下载执行阻塞，但是对于依赖，浏览器只能在解析js的步骤中获取依赖然后进行请求下载，依赖下载运行后才能继续执行。</li>\n</ul>\n</li>\n</ul>\n<p><a id='ESMinit'></a></p>\n<h2 id=\"esm-init-优化方案\">ESM init 优化方案</h2>\n<ul>\n<li>当然通过服务器在请求页面时主动将依赖js一起传给浏览器来直接减少请求数量，但是这就需要服务器知道项目依赖关系，这超出了一些静态文件服务器的职能范围了。  </li>\n<li>或者服务器将依赖关系网传给浏览器，让浏览器解析当前需要的js依赖，一次性向服务器请求完，而且因为http1.1的keep alivia的存在会让项目init js的时间比单纯原生请求要少去 <strong>1.一步步解析js获取依赖再请求依赖的时间</strong> 以及 __2.浏览器多次和服务器tcp连接的时间__，但是需要维护依赖关系网作为牺牲。</li>\n</ul>\n<p><a id='All'></a></p>\n<h2 id=\"总的来说\">总的来说</h2>\n<ol>\n<li>对于一些大项目，势必会用到打包工具进行优化（代码压缩，label，eslint），然而es6原生模块支持即使在良好的关系网维护以及浏览器预解析关系网并预加载依赖的最好情况下，加载时间也不比commonjs打包成一整个js文件快多少。但是维护依赖关系网这件事也并不轻松。所以大项目使用ESM的意义目前来看并不是很大。  </li>\n<li>但是对于一些小项目，总共js依赖文件没多少的那种，使用webpack这种臃肿的大包工具并不会对项目起到多大的优化作用，那么何尝不试试直接使用ESM，开发静态网页的快感谁试谁知道，所以出现了将commonjs模块标准转换成ESM的工具<a href=\"https://github.com/pikapkg/web\">@pika/web</a>。</li>\n</ol>\n"},"next":{"path":"_blogs/JS/浏览器是怎么处理多个defer或async的script的/README.md","url":"/blog/JS/浏览器是怎么处理多个defer或async的script的","title":"浏览器是怎么处理多个defer或async的script的","author":"yrobot","keywords":"async,script,defer,浏览器,多个,处理","createTime":1571068800000,"length":315,"content":"<p><a id='top'></a></p>\n<ol>\n<li><p>浏览器下载资源可以并行，但是有上限，不同浏览器的上限不同，但都是在8以内。具体参考：<a href=\"http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/\">http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/</a></p>\n</li>\n<li><p>浏览器对于同一服务器下的资源可以利用HTTP/1.1的Keep alive，保持tcp层的连接，下个请求就无需再经过tcp连接，减少通信耗时，提高了同一服务器下资源的下载效率。</p>\n</li>\n<li><p>对于不同地址的资源浏览器还是得通过并行资源请求，而因为并行下载线程数量被控制在个位数，所以多个不同地的script势必会造成script下载的拥塞。</p>\n</li>\n</ol>\n"}},"__N_SSG":true}