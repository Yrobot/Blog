{"pageProps":{"pre":{"path":"_blogs/JS/探讨ESM对当前开发的意义或影响/README.md","url":"/blog/JS/探讨ESM对当前开发的意义或影响","title":"探讨ESM对当前开发的意义或影响","author":"yrobot","keywords":"ESM,探讨,意义,当前,开发,影响","createTime":1571068800000,"length":1414,"content":"<p><a id='top'></a></p>\n<p><strong>本页目录：</strong><br><a href=\"#compare\">对比当前模块开发和ES6模块化开发</a><br><a href=\"#ESMinit\">ESM init 优化方案</a><br><a href=\"#All\">总的来说</a>  </p>\n<p><strong>友情连接：</strong><br>Q：浏览器遇到多个script资源的时候是怎么做的呢？<br>A：<a href=\"../%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AAdefer%E6%88%96async%E7%9A%84script%E7%9A%84\">浏览器是怎么处理多个defer或async的script的</a></p>\n<p><a id='compare'></a></p>\n<h2 id=\"对比当前模块开发和es6模块化开发\">对比当前模块开发和ES6模块化开发</h2>\n<h4 id=\"开发方式对比\">开发方式对比</h4>\n<ul>\n<li><p>commonjs的模块化流程：  </p>\n<ul>\n<li>利用commonjs的模块规范进行引入使用，而npm大部分包也是用的commonjs规范写的。前端为了解决浏览器不支持commonjs模块，利用webpack等打包工具，将模块打包到一个js文件中，最后引入html。</li>\n</ul>\n</li>\n<li><p>es6模块化开发流程：  </p>\n<ul>\n<li>保证所有依赖支持es6的模块化规范，在html利用type=“module”来引入根js（cdn的js只能使用script引入）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"资源加载对比\">资源加载对比</h4>\n<ul>\n<li><p>commonjs的模块化：  </p>\n<ul>\n<li>原来的js文件被整合到一个js文件中，请求网页时，对于这些js只需发送一个script请求即可，只是这个js文件比较大。</li>\n</ul>\n</li>\n<li><p>es6模块化开发：  </p>\n<ul>\n<li>对于es6模块，浏览器解析到<code>&lt;script type=&quot;module&quot; src=&quot;..&quot;/&gt;</code>时，因为type=&quot;module&quot;的script默认defer，所以页面会继续解析渲染不受js下载执行阻塞，但是对于依赖，浏览器只能在解析js的步骤中获取依赖然后进行请求下载，依赖下载运行后才能继续执行。</li>\n</ul>\n</li>\n</ul>\n<p><a id='ESMinit'></a></p>\n<h2 id=\"esm-init-优化方案\">ESM init 优化方案</h2>\n<ul>\n<li>当然通过服务器在请求页面时主动将依赖js一起传给浏览器来直接减少请求数量，但是这就需要服务器知道项目依赖关系，这超出了一些静态文件服务器的职能范围了。  </li>\n<li>或者服务器将依赖关系网传给浏览器，让浏览器解析当前需要的js依赖，一次性向服务器请求完，而且因为http1.1的keep alivia的存在会让项目init js的时间比单纯原生请求要少去 <strong>1.一步步解析js获取依赖再请求依赖的时间</strong> 以及 __2.浏览器多次和服务器tcp连接的时间__，但是需要维护依赖关系网作为牺牲。</li>\n</ul>\n<p><a id='All'></a></p>\n<h2 id=\"总的来说\">总的来说</h2>\n<ol>\n<li>对于一些大项目，势必会用到打包工具进行优化（代码压缩，label，eslint），然而es6原生模块支持即使在良好的关系网维护以及浏览器预解析关系网并预加载依赖的最好情况下，加载时间也不比commonjs打包成一整个js文件快多少。但是维护依赖关系网这件事也并不轻松。所以大项目使用ESM的意义目前来看并不是很大。  </li>\n<li>但是对于一些小项目，总共js依赖文件没多少的那种，使用webpack这种臃肿的大包工具并不会对项目起到多大的优化作用，那么何尝不试试直接使用ESM，开发静态网页的快感谁试谁知道，所以出现了将commonjs模块标准转换成ESM的工具<a href=\"https://github.com/pikapkg/web\">@pika/web</a>。</li>\n</ol>\n"},"blog":{"path":"_blogs/JS/浏览器是怎么处理多个defer或async的script的/README.md","url":"/blog/JS/浏览器是怎么处理多个defer或async的script的","title":"浏览器是怎么处理多个defer或async的script的","author":"yrobot","keywords":"async,script,defer,浏览器,多个,处理","createTime":1571068800000,"length":315,"content":"<p><a id='top'></a></p>\n<ol>\n<li><p>浏览器下载资源可以并行，但是有上限，不同浏览器的上限不同，但都是在8以内。具体参考：<a href=\"http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/\">http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/</a></p>\n</li>\n<li><p>浏览器对于同一服务器下的资源可以利用HTTP/1.1的Keep alive，保持tcp层的连接，下个请求就无需再经过tcp连接，减少通信耗时，提高了同一服务器下资源的下载效率。</p>\n</li>\n<li><p>对于不同地址的资源浏览器还是得通过并行资源请求，而因为并行下载线程数量被控制在个位数，所以多个不同地的script势必会造成script下载的拥塞。</p>\n</li>\n</ol>\n"},"next":{"path":"_blogs/HTML&CSS/css层叠上下文/README.md","url":"/blog/HTML&CSS/css层叠上下文","title":"css层叠上下文","author":"yrobot","keywords":"css,层叠,上下文","createTime":1568649600000,"length":1371,"content":"<p><strong>本页目录：</strong><br><a href=\"#question\">元素之间有重叠，浏览器要怎么展示呢</a><br><a href=\"#how\">怎么确定元素层叠关系</a><br><a href=\"#sxw\">层叠上下文</a><br><a href=\"#xdsx\">层叠顺序</a><br><a href=\"#doit\">实操一下看</a>  </p>\n<p><a id='question'></a></p>\n<h2 id=\"元素之间有重叠，浏览器要怎么展示呢\">元素之间有重叠，浏览器要怎么展示呢</h2>\n<p>  当我们在编写html+css时，常常会遇到元素覆盖的问题，那解释器是怎么解释元素的覆盖的呢？  </p>\n<ul>\n<li>首先我们比确定的是，相邻的普通元素，都是后者覆盖前者的  </li>\n</ul>\n<p>  但是对于相对较远的元素，拥有其他css属性（例如z-index）的属性呢？  </p>\n<ul>\n<li>emmmm，z-index值越大就越靠上？？ </li>\n<li>nono，解释器不是这么简单粗暴的  </li>\n<li>下面我们就来探讨一下 层叠上下文 对元素 层叠关系的影响   </li>\n</ul>\n<p><a id='how'></a></p>\n<h2 id=\"怎么确定元素层叠关系\">怎么确定元素层叠关系</h2>\n<p>前端页面元素的覆盖关系由 <strong>所属的层叠上下文</strong> 和 <strong>元素本身的层叠顺序</strong> 决定  </p>\n<p>先看层叠上下文，再看层叠顺序  </p>\n<p><a id='sxw'></a></p>\n<h2 id=\"层叠上下文\">层叠上下文</h2>\n<ol>\n<li><p>层叠上下文是页面元素的一种属性，页面由普通元素组成，一些元素因为种种原因而带有了层叠上下文  </p>\n</li>\n<li><p>产生层叠上下文的种种原因：  </p>\n<ol>\n<li>页面根元素html天生具有层叠上下文，称之为“根层叠上下文”</li>\n<li>普通元素满足以下条件时具有层叠上下文：a.position值非static  b.z-index值非auto</li>\n<li>CSS3中的新属性也可以产生层叠上下文</li>\n</ol>\n</li>\n<li><p>所有元素的层叠关系都是相对于 最近父层叠上下文元素 来说的   </p>\n</li>\n</ol>\n<p><a id='xdsx'></a></p>\n<h2 id=\"层叠顺序\">层叠顺序</h2>\n<ol>\n<li>层叠关系要在同一个层叠上下文中比较，两元素不在同一个层叠上下文则向上寻找，直到同一个层叠上下文，比较 <code>最开始包含自己的层叠上下文（若有）|| 元素本身</code>   </li>\n<li>当将两者提升到同一个层叠上下文后，根据下图层叠顺序图来判断层叠关系 </li>\n</ol>\n<p>逻辑图如下：<br><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g72kli5irwj30hg08pmyl.jpg\" alt=\"\"></p>\n<p><a id='doit'></a></p>\n<h2 id=\"实操一下看\">实操一下看</h2>\n<p><img src=\"https://tva1.sinaimg.cn/large/006y8mN6ly1g72kpdobofj30x70guacd.jpg\" alt=\"\">  </p>\n<ul>\n<li>建议判断层叠关系时，都在脑海中画一下上图虚拟DOM树  </li>\n</ul>\n<p>比较下以下几个元素的覆盖关系：<br>B5-C3<br>B2-B5<br>C1-C2<br>C3-B5<br>C1-B1   </p>\n<p>根据<a href=\"#how\">怎么确定元素层叠关系</a>，先看层叠上下文，再看层叠顺序  </p>\n<ol>\n<li>看层叠上下文  <pre><code><span class=\"hljs-attribute\">B5</span>-C<span class=\"hljs-number\">3</span> =&gt; A<span class=\"hljs-number\">4</span>-A<span class=\"hljs-number\">3</span>   \n<span class=\"hljs-attribute\">B2</span>-B<span class=\"hljs-number\">5</span> =&gt; B<span class=\"hljs-number\">2</span>-A<span class=\"hljs-number\">4</span>   \n<span class=\"hljs-attribute\">C1</span>-C<span class=\"hljs-number\">2</span> =&gt; A<span class=\"hljs-number\">1</span>-B<span class=\"hljs-number\">3</span>   \n<span class=\"hljs-attribute\">C3</span>-B<span class=\"hljs-number\">5</span> =&gt; B<span class=\"hljs-number\">4</span>-B<span class=\"hljs-number\">5</span>   \n<span class=\"hljs-attribute\">C1</span>-B<span class=\"hljs-number\">1</span> =&gt; C<span class=\"hljs-number\">1</span>-B<span class=\"hljs-number\">1</span>   \n</code></pre>\n</li>\n<li>再根据<a href=\"#xdsx\">层叠顺序</a>的规则去判断元素的层叠关系吧！！！</li>\n</ol>\n"}},"__N_SSG":true}