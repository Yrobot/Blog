<!DOCTYPE html><html><head><link rel="icon" href="/favicon.ico"/><link rel="preload" href="//at.alicdn.com/t/font_2533274_yhzuq4j0hfr.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="stylesheet" href="//at.alicdn.com/t/font_2533274_yhzuq4j0hfr.css"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1DXREC8Y53"></script><script>
              window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments)}
              gtag('js', new Date()); gtag('config', 'G-1DXREC8Y53');
            </script><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/><meta name="keywords" content="yrobot,blog,博客,THIS,指向"/><meta name="description" content="THIS的指向"/><title>THIS的指向</title><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/886f8c3411ad1c39be9a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/886f8c3411ad1c39be9a.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-728d319af5b79ac932e2.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework-d3984ef788efc6bd8157.js" as="script"/><link rel="preload" href="/_next/static/chunks/597-9d03ea954e499bbdd7af.js" as="script"/><link rel="preload" href="/_next/static/chunks/778-1467ee0b708f5cd375c0.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-9ca82ec4d4aca520c43d.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-49d413833563c7b39a6e.js" as="script"/><link rel="preload" href="/_next/static/chunks/525-eaa095b223f3548a6266.js" as="script"/><link rel="preload" href="/_next/static/chunks/644-2d382948659572c3e3d0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5B...path%5D-20be8281364ff903a94a.js" as="script"/></head><body><div id="__next"><div class="mx-auto md:max-w-screen-lg 2xl:max-w-screen-2xl"><div class="md:flex flex-row items-start justify-between"><div class="card menu h-60px md:flex-none md:w-90px md:h-600px md:mr-20px 2xl:w-120px 2xl:h-850px 2xl: 2xl:mr-50px flex flex-row items-center justify-between md:flex-col mb-20px"><a class="iconfont iconlogo flex-none mr-auto ml-15px md:ml-0 md:mr-0 md:mt-20px md:mb-auto w-30px h-30px text-30px md:w-50px md:h-50px md:text-50px 2xl:w-60px 2xl:h-60px 2xl:text-60px"></a><a class="iconfont iconhome cursor-pointer flex-none w-20px h-20px text-20px mr-20px md:mr-0 md:mb-50px md:w-30px md:h-30px md:text-30px" href="/"></a><a class="iconfont icongithub cursor-pointer flex-none w-20px h-20px text-20px mr-20px md:mr-0 md:mb-50px md:w-30px md:h-30px md:text-30px" target="_blank" href="https://github.com/Yrobot"></a><a class="iconfont iconemail cursor-pointer flex-none w-20px h-20px text-20px  mr-20px md:mr-0 md:mb-50px md:w-30px md:h-30px md:text-30px" href="mailto:y_robot@yeah.net?subject="></a><a class="iconfont cursor-pointer flex-none w-20px h-20px text-20px mr-15px md:mr-0 md:mb-20px 2xl:mb-50px md:w-30px md:h-30px md:text-30px iconenglish"></a></div><div class="min-w-0 flex-auto 2xl:flex flex-row items-start justify-between"><div class="min-w-0 2xl:flex-auto 2xl:mr-50px 2xl:pt-30px"><div class="text-center text-xl mb-6px md:text-4xl md:font-bold md:mb-10px 2xl:text-5xl 2xl:mb-15px font-medium">THIS的指向</div><div class="text-center whitespace-pre-wrap text-gray-500 font-light text-14px leading-20px md:text-16px mb-20px">2018-08-24  |  <!-- -->2<!-- -->分钟<!-- -->  |  yrobot  |  <span class="md:hidden">
</span>THIS,指向</div><article class="prose prose-sm break-all md:prose 2xl:prose-lg mb-15px md:mb-20px"><p><strong>本页目录：</strong><br><a href="#build">this的建立</a><br><a href="#index">this指向</a><br><a href="#rule">this规则概括</a>  </p>
<p><a id='build'></a></p>
<h2 id="this的建立">this的建立</h2>
<ul>
<li>一般函数在预编译过程中生成的AO上下文  </li>
<li>AO中除了函数内的一些属性和函数参数外，还有<code>arguments</code>和<code>this</code>(箭头函数没有)。  </li>
<li>所以函数（除了箭头函数）预编译过程会生成<code>this</code>隐式对象，并 <strong>默认指向window。</strong>  </li>
</ul>
<p><a id='index'></a></p>
<h2 id="this指向">this指向</h2>
<ul>
<li>而在预编译过程中，<code>this</code>会默认指向<code>window</code>。  </li>
<li>而<code>new</code>操作时，会在函数内生成一个隐式<code>this</code>对象，而同时改变AO中<code>this</code>指向为本<code>this</code></li>
<li>用<code>obj.func()</code>调用的时候，会将<code>func()</code>内的<code>this</code>指向改为<code>obj</code>  </li>
<li><h4 id="以上this的修改是在func有this的情况下，箭头函数没有this，直接沿着作用域链向上寻找this">以上<code>this</code>的修改是在<code>func</code>有<code>this</code>的情况下，箭头函数没有this，直接沿着作用域链向上寻找this</h4>
</li>
<li><h4 id="注意函数作用域链的数据是由函数参数、函数内声明组成，funprop无法增加或更改作用域">注意函数作用域链的数据是由函数参数、函数内声明组成，fun.prop无法增加或更改作用域</h4>
</li>
</ul>
<p><a id='rule'></a></p>
<h2 id="this规则概括">this规则概括</h2>
<ol>
<li>函数编译过程中AO上下文中<code>this</code>默认指向<code>window</code>  </li>
<li>全局作用域里<code>this</code>指向<code>window</code>  </li>
<li><code>call</code>/<code>apply</code>可以利用参数改变<code>this</code>的指向  </li>
<li><code>obj.fun()</code>调用时，<code>fun()</code>AO中<code>this</code>指向obj (<code>new</code> 生成对象时默认<code>return this</code>，所以只有<code>this.xxx</code>的属性才能被访问到)  </li>
<li>html元素脚本中，函数参数中的<code>this</code>指向元素本身  </li>
</ol>
<hr>
</article><div class="overflow-hidden flex flex-row items-center justify-between pt-10px md:pt-15px border-t-1px border-gray-200 mb-20px md:mb-40px"><span class="iconfont iconleft flex-none w-14px h-14px text-14px md:w-16px md:h-16px md:text-16px md:mr-4px"></span><a href="/blog/JS/JS的三个定时器" class="flex-none w-40% text-14px leading-16px md:text-16px overflow-hidden whitespace-nowrap overflow-ellipsis">JS的三个定时器</a><div class="mx-auto"></div><a href="/blog/JS/遍历obj和array" class="flex-none w-40% text-right text-14px leading-16px md:text-16px overflow-hidden whitespace-nowrap overflow-ellipsis">遍历obj和array</a><span class="iconfont iconright flex-none w-14px h-14px text-14px md:w-16px md:h-16px md:text-16px md:ml-4px"></span></div><div class="mb-20px"><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div id="vcomments"></div></div></div><div class="2xl:flex-none 2xl:w-580px"><div class="pt-24px md:pt-24px 2xl:pt-30px mb-15px md:mb-20px"><div class="relative card pl-20px flex flex-col items-start justify-center h-96px md:h-126px 2xl:h-160px pr-120px md:pr-170px 2xl:pr-195px"><div class="text-20px md:text-26px 2xl:text-36px font-bold mb-10px md:mb-15px 2xl:mb-15px">你好！我是Yrobot</div><div class="text-14px md:text-16px 2xl:text-16px">欢迎来到我的博客，希望你在这里玩得开心！</div><img class="h-120px md:h-150px 2xl:h-190px absolute bottom-0 right-20px" src="/assets/person.svg" alt="person"/></div></div><div class="card mb-15px md:mb-20px overflow-hidden"><a href="https://github.com/Yrobot" target="_blank"><img src="https://github-readme-stats.vercel.app/api?count_private=true&amp;show_icons=true&amp;username=yrobot&amp;title_color=000000&amp;icon_color=000000&amp;text_color=000000&amp;border_color=F4F4F5&amp;bg_color=F4F4F5" alt="GithubCard"/></a></div><div class="card mb-15px md:mb-20px overflow-hidden"><a href="https://github.com/Yrobot/mina-touch" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin?repo=mina-touch&amp;username=yrobot&amp;title_color=000000&amp;icon_color=000000&amp;text_color=000000&amp;border_color=F4F4F5&amp;bg_color=F4F4F5" alt="GithubCard"/></a></div><div class="card mb-15px md:mb-20px overflow-hidden"><a href="https://github.com/Yrobot/react-mobile-table" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin?repo=react-mobile-table&amp;username=yrobot&amp;title_color=000000&amp;icon_color=000000&amp;text_color=000000&amp;border_color=F4F4F5&amp;bg_color=F4F4F5" alt="GithubCard"/></a></div><div class="card mb-15px md:mb-20px overflow-hidden"><a href="https://github.com/Yrobot/mina-popups" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin?repo=mina-popups&amp;username=yrobot&amp;title_color=000000&amp;icon_color=000000&amp;text_color=000000&amp;border_color=F4F4F5&amp;bg_color=F4F4F5" alt="GithubCard"/></a></div></div></div></div><footer class="bg-accent-1"></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"pre":{"path":"_blogs/JS/JS的三个定时器/README.md","url":"/blog/JS/JS的三个定时器","title":"JS的三个定时器","author":"yrobot","keywords":"JS,定时器,三个","createTime":1535040000000,"length":4090,"content":"\u003cp\u003e\u003cstrong\u003e本页目录：\u003c/strong\u003e\u003cbr\u003e\u003ca href=\"#setTimeout\"\u003esetTimeout\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#setInterval\"\u003esetInterval\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#requestAnimationFrame\"\u003erequestAnimationFrame\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#jsAnimation\"\u003eJS动画\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#useAnimation\"\u003e推荐使用requestAnimationFrame绘制JS动画\u003c/a\u003e   \u003c/p\u003e\n\u003cp\u003e\u003ca id='setTimeout'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"settimeout\"\u003esetTimeout\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e在执行时,是在载入后延迟指定时间后执行一次表达式（仅执行一次）  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca id='setInterval'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"setinterval\"\u003esetInterval\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e在执行时,它从载入后,每隔指定的时间就执行一次表达式  \u003c/li\u003e\n\u003cli\u003e在代码运行到间歇调用和超时调用时，定时器（浏览器中 __独立于js线程的一个线程__）会在相应的时间，将相应的代码放入宏代码队列中，所以不必考虑放代码时，js是否有程序在运行。所以这两个函数只能保证按时将代码放入队列，但具体的执行时间要看队列前的函数执行情况（什么时候轮到放入的函数）。由于这三个函数都是js异步编程的一种实现，所以详情参看\u003ca href=\"/blog/JS/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B#eventLoop\"\u003eJS异步编程 #浏览器线程和Event Loop\u003c/a\u003e\n\u003cimg src=\"https://ws1.sinaimg.cn/large/006tNbRwgy1fukmxrd5ixj30m409smxx.jpg\" alt=\"\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca id='requestAnimationFrame'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"requestanimationframe\"\u003erequestAnimationFrame\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e不能指定延迟时间，而是根据浏览器的刷新频率而定（帧），即浏览器页面刷新一次函数就执行一次，适合实现页面动画  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca id='jsAnimation'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"js动画\"\u003eJS动画\u003c/h2\u003e\n\u003cp\u003e理解了上面的概念以后，我们不难发现，setTimeout 其实就是通过设置一个间隔时间来不断的改变元素属性，从而达到动画效果的。但我们会发现，利用 seTimeout 实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003esetTimeout 的执行时间并不是确定的。在JavaScript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，所以 setTimeout 的实际执行时机一般要比其设定的时间晚一些。\u003c/li\u003e\n\u003cli\u003e刷新频率受 屏幕分辨率 和 屏幕尺寸 的影响，不同设备的屏幕绘制频率可能会不同，而 setTimeout 只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。  \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e以上两种情况都会导致 setTimeout 的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。 那为什么步调不一致就会引起丢帧呢？   \u003c/p\u003e\n\u003cp\u003e首先要明白，setTimeout 的执行只是在内存中对元素属性进行改变，这个变化必须要等到屏幕下次绘制时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素。假设屏幕每隔16.7ms刷新一次，而setTimeout 每隔10ms设置图像向左移动1px， 就会出现如下绘制过程：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第0ms：屏幕未绘制，  等待中，setTimeout 也未执行，等待中；\u003c/li\u003e\n\u003cli\u003e第10ms：屏幕未绘制，等待中，setTimeout 开始执行并设置元素属性 left=1px；\u003c/li\u003e\n\u003cli\u003e第16.7ms：屏幕开始绘制，屏幕上的元素向左移动了 1px， setTimeout 未执行，继续等待中；\u003c/li\u003e\n\u003cli\u003e第20ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=2px;\u003c/li\u003e\n\u003cli\u003e第30ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=3px;\u003c/li\u003e\n\u003cli\u003e第33.4ms：屏幕开始绘制，屏幕上的元素向左移动了 3px， setTimeout 未执行，继续等待中；\u003c/li\u003e\n\u003cli\u003e...  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e从上面的绘制过程中可以看出，屏幕没有更新 left=2px 的那一帧画面，元素直接从left=1px 的位置跳到了 left=3px 的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"\" id=\"useAnimation\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"推荐使用requestanimationframe绘制js动画\"\u003e推荐使用requestAnimationFrame绘制JS动画\u003c/h2\u003e\n\u003cp\u003e与 setTimeout 相比，requestAnimationFrame() 最大的优势是 __由系统来决定回调函数的执行时机__。具体一点讲就是，系统每次绘制之前会主动调用 requestAnimationFrame() 中的回调函数，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms。换句话说就是，requestAnimationFrame() 的执行步伐跟着系统的绘制频率走。它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。\u003c/p\u003e\n\u003cp\u003e这个API的调用很简单，如下所示：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar progress = 0;\n//回调函数\nfunction render() {\n    progress += 1; //修改图像的位置\n \n    if (progress \u0026lt; 100) {\n           //在动画没有结束前，递归渲染\n           window.requestAnimationFrame(render);\n    }\n}\n \n//第一帧渲染\nwindow.requestAnimationFrame(render);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e除此之外，requestAnimationFrame 还有以下两个优势：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e__PU节能__：使用 setTimeout 实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，而且还浪费 CPU 资源。而 rAF 则完全不同，当页面处理未激活的状态下，该页面的屏幕绘制任务也会被系统暂停，因此跟着系统步伐走的 rAF 也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e__函数节流__：在高频率事件(resize,scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，使用 rAF 可保证每个绘制间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个绘制间隔内函数执行多次时没有意义的，因为显示器每16.7ms 绘制一次，多次绘制并不会在屏幕上体现出来。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca href=\"\" id=\"suitDown\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"适配低版本\"\u003e适配低版本\u003c/h2\u003e\n\u003cp\u003e以下代码考虑到部分浏览器不支持requestAnimationFrame的情况，对requestAnimationFrame和cancelAnimationFrame进行降级适配。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif (!Date.now)\n    Date.now = function() { return new Date().getTime(); };\n \n(function() {\n    \u0026#39;use strict\u0026#39;;\n     \n    var vendors = [\u0026#39;webkit\u0026#39;, \u0026#39;moz\u0026#39;];\n    for (var i = 0; i \u0026lt; vendors.length \u0026amp;\u0026amp; !window.requestAnimationFrame; ++i) {\n        var vp = vendors[i];\n        window.requestAnimationFrame = window[vp+\u0026#39;RequestAnimationFrame\u0026#39;];\n        window.cancelAnimationFrame = (window[vp+\u0026#39;CancelAnimationFrame\u0026#39;]\n                                   || window[vp+\u0026#39;CancelRequestAnimationFrame\u0026#39;]);\n    }\n    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy\n        || !window.requestAnimationFrame || !window.cancelAnimationFrame) {\n        var lastTime = 0;\n        window.requestAnimationFrame = function(callback) {\n            var now = Date.now();\n            var nextTime = Math.max(lastTime + 16, now);\n            return setTimeout(function() { callback(lastTime = nextTime); },\n                              nextTime - now);\n        };\n        window.cancelAnimationFrame = clearTimeout;\n    }\n}());\n```---  \n*\b本章节部分参考[一像素 博客](https://www.cnblogs.com/onepixel/p/7078617.html)，在此感谢！*\n\n\u003c/code\u003e\u003c/pre\u003e\n"},"blog":{"path":"_blogs/JS/THIS的指向/README.md","url":"/blog/JS/THIS的指向","title":"THIS的指向","author":"yrobot","keywords":"THIS,指向","createTime":1535040000000,"length":807,"content":"\u003cp\u003e\u003cstrong\u003e本页目录：\u003c/strong\u003e\u003cbr\u003e\u003ca href=\"#build\"\u003ethis的建立\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#index\"\u003ethis指向\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#rule\"\u003ethis规则概括\u003c/a\u003e  \u003c/p\u003e\n\u003cp\u003e\u003ca id='build'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"this的建立\"\u003ethis的建立\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e一般函数在预编译过程中生成的AO上下文  \u003c/li\u003e\n\u003cli\u003eAO中除了函数内的一些属性和函数参数外，还有\u003ccode\u003earguments\u003c/code\u003e和\u003ccode\u003ethis\u003c/code\u003e(箭头函数没有)。  \u003c/li\u003e\n\u003cli\u003e所以函数（除了箭头函数）预编译过程会生成\u003ccode\u003ethis\u003c/code\u003e隐式对象，并 \u003cstrong\u003e默认指向window。\u003c/strong\u003e  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca id='index'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"this指向\"\u003ethis指向\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e而在预编译过程中，\u003ccode\u003ethis\u003c/code\u003e会默认指向\u003ccode\u003ewindow\u003c/code\u003e。  \u003c/li\u003e\n\u003cli\u003e而\u003ccode\u003enew\u003c/code\u003e操作时，会在函数内生成一个隐式\u003ccode\u003ethis\u003c/code\u003e对象，而同时改变AO中\u003ccode\u003ethis\u003c/code\u003e指向为本\u003ccode\u003ethis\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e用\u003ccode\u003eobj.func()\u003c/code\u003e调用的时候，会将\u003ccode\u003efunc()\u003c/code\u003e内的\u003ccode\u003ethis\u003c/code\u003e指向改为\u003ccode\u003eobj\u003c/code\u003e  \u003c/li\u003e\n\u003cli\u003e\u003ch4 id=\"以上this的修改是在func有this的情况下，箭头函数没有this，直接沿着作用域链向上寻找this\"\u003e以上\u003ccode\u003ethis\u003c/code\u003e的修改是在\u003ccode\u003efunc\u003c/code\u003e有\u003ccode\u003ethis\u003c/code\u003e的情况下，箭头函数没有this，直接沿着作用域链向上寻找this\u003c/h4\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ch4 id=\"注意函数作用域链的数据是由函数参数、函数内声明组成，funprop无法\b增加或更改作用域\"\u003e注意函数作用域链的数据是由函数参数、函数内声明组成，fun.prop无法\b增加或更改作用域\u003c/h4\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca id='rule'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"this规则概括\"\u003ethis规则概括\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e函数编译过程中AO上下文中\u003ccode\u003ethis\u003c/code\u003e默认指向\u003ccode\u003ewindow\u003c/code\u003e  \u003c/li\u003e\n\u003cli\u003e全局作用域里\u003ccode\u003ethis\u003c/code\u003e指向\u003ccode\u003ewindow\u003c/code\u003e  \u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecall\u003c/code\u003e/\u003ccode\u003eapply\u003c/code\u003e可以利用参数改变\u003ccode\u003ethis\u003c/code\u003e的指向  \u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eobj.fun()\u003c/code\u003e调用时，\u003ccode\u003efun()\u003c/code\u003eAO中\u003ccode\u003ethis\u003c/code\u003e指向obj (\u003ccode\u003enew\u003c/code\u003e 生成对象时默认\u003ccode\u003ereturn this\u003c/code\u003e，所以只有\u003ccode\u003ethis.xxx\u003c/code\u003e的属性才能被访问到)  \u003c/li\u003e\n\u003cli\u003ehtml元素脚本中，函数参数中的\u003ccode\u003ethis\u003c/code\u003e指向元素本身  \u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n"},"next":{"path":"_blogs/JS/遍历obj和array/README.md","url":"/blog/JS/遍历obj和array","title":"遍历obj和array","author":"yrobot","keywords":"array,obj,遍历","createTime":1535040000000,"length":1377,"content":"\u003cp\u003e\u003cstrong\u003e本页目录：\u003c/strong\u003e\u003cbr\u003e\u003ca href=\"#for\"\u003e基础for循环\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#forin\"\u003efor in 循环\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#forof\"\u003efor of 循环\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#foreach\"\u003earray.forEach()方法\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#summary\"\u003e总结\u003c/a\u003e  \u003c/p\u003e\n\u003cp\u003e\u003ca id='for'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"1-基础for循环\"\u003e1. 基础for循环\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003efor (var index = 0; index \u0026lt; myArray.length; index++) {\n  console.log(myArray[index]);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca id='forin'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"2-for-in-循环\"\u003e2. for in 循环\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003efor...in 语句用于对数组或者对象的属性进行循环操作。\u003cpre\u003e\u003ccode\u003efor(let i in array)  // i为数组的index：0，1，2，3.....\nfor(let i in obj)  // i为obj 的属性名\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"https://ws3.sinaimg.cn/large/006tNbRwgy1fukqtphbb9j31e60bwgmv.jpg\" alt=\"\"\u003e\n\u003ca id='forof'\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"3-for-of-循环\"\u003e3. for of 循环\u003c/h2\u003e\n\u003cp\u003e参考链接：\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of\"\u003ehttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efor (let value of iterable) {  // value为属性值\n    //statements\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003evalue\u003c/strong\u003e\u003cbr\u003e在每次迭代中，将不同属性的值分配给变量。 \u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eiterable\u003c/strong\u003e ( Array，Map，Set，String，TypedArray，arguments 对象等等) (obj不是iterable)\u003cbr\u003e被迭代枚举其属性的对象。\u003cbr\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fukqtq7vk6j31e60fqmzh.jpg\" alt=\"\"\u003e  \u003c/p\u003e\n\u003cp\u003e\u003ca id='foreach'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"4-arrayforeach方法\"\u003e4. array.forEach()方法\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003earr.forEach(function callback(value[, index[, array]]) { // value:属性值，index:当前索引，array:当前遍历数组\n    //your iterator\n}[, thisArg]);   // thisArg:作为callback函数的this值\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fukqto6spyj31ec0c0dh4.jpg\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca id='summary'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e少用for of，支持不好。性能也一般。性能基础for优化较好\u003c/li\u003e\n\u003cli\u003e遍历array，以上方法均可\u003c/li\u003e\n\u003cli\u003e遍历obj思路：\u003col\u003e\n\u003cli\u003e获取obj的keys，利用基础for遍历\u003c/li\u003e\n\u003cli\u003efor in利用属性名获取属性值\u003c/li\u003e\n\u003cli\u003e利用object.keys()方法获取keys，再用keys.forEach()遍历获取属性值\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n"}},"__N_SSG":true},"page":"/blog/[...path]","query":{"path":["JS","THIS的指向"]},"buildId":"c1We8XZrGjJ5dpdHPxQt1","isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-8683bd742a84c1edd48c.js"></script><script src="/_next/static/chunks/webpack-728d319af5b79ac932e2.js" async=""></script><script src="/_next/static/chunks/framework-d3984ef788efc6bd8157.js" async=""></script><script src="/_next/static/chunks/597-9d03ea954e499bbdd7af.js" async=""></script><script src="/_next/static/chunks/778-1467ee0b708f5cd375c0.js" async=""></script><script src="/_next/static/chunks/main-9ca82ec4d4aca520c43d.js" async=""></script><script src="/_next/static/chunks/pages/_app-49d413833563c7b39a6e.js" async=""></script><script src="/_next/static/chunks/525-eaa095b223f3548a6266.js" async=""></script><script src="/_next/static/chunks/644-2d382948659572c3e3d0.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5B...path%5D-20be8281364ff903a94a.js" async=""></script><script src="/_next/static/c1We8XZrGjJ5dpdHPxQt1/_buildManifest.js" async=""></script><script src="/_next/static/c1We8XZrGjJ5dpdHPxQt1/_ssgManifest.js" async=""></script></body></html>