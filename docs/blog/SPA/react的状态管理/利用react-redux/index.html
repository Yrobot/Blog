<!DOCTYPE html><html><head><link rel="icon" href="favicon.ico"/><link rel="preload" href="//at.alicdn.com/t/font_2533274_yhzuq4j0hfr.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="stylesheet" href="//at.alicdn.com/t/font_2533274_yhzuq4j0hfr.css"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/><meta name="keywords" content="yrobot,blog,博客,react,redux,状态管理,利用"/><meta name="description" content="react的状态管理—利用react-redux"/><title>react的状态管理—利用react-redux</title><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/0e71a3e4ef78433dbcc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0e71a3e4ef78433dbcc6.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-5f970f2ad4ea41d50dab.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework-d3984ef788efc6bd8157.js" as="script"/><link rel="preload" href="/_next/static/chunks/597-9d03ea954e499bbdd7af.js" as="script"/><link rel="preload" href="/_next/static/chunks/778-1467ee0b708f5cd375c0.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-9ca82ec4d4aca520c43d.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-d1fff168fcebfddb9829.js" as="script"/><link rel="preload" href="/_next/static/chunks/500-9a32898805276f2ba062.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5B...path%5D-b0ff53552a2952cc4827.js" as="script"/></head><body><div id="__next"><div class="mx-auto md:max-w-screen-lg 2xl:max-w-screen-2xl"><div class="md:flex flex-row items-start justify-between"><div class="card menu h-60px md:flex-none md:w-90px md:h-600px md:mr-20px 2xl:w-120px 2xl:h-850px 2xl: 2xl:mr-50px flex flex-row items-center justify-between md:flex-col mb-20px"><a class="iconfont iconlogo flex-none mr-auto ml-15px md:ml-0 md:mr-0 md:mt-20px md:mb-auto w-30px h-30px text-30px md:w-50px md:h-50px md:text-50px 2xl:w-60px 2xl:h-60px 2xl:text-60px"></a><a class="iconfont iconhome cursor-pointer flex-none w-20px h-20px text-20px mr-20px md:mr-0 md:mb-50px md:w-30px md:h-30px md:text-30px" href="/"></a><a class="iconfont icongithub cursor-pointer flex-none w-20px h-20px text-20px mr-20px md:mr-0 md:mb-50px md:w-30px md:h-30px md:text-30px" target="_blank" href="https://github.com/Yrobot"></a><a class="iconfont iconemail cursor-pointer flex-none w-20px h-20px text-20px  mr-20px md:mr-0 md:mb-50px md:w-30px md:h-30px md:text-30px" href="mailto:y_robot@yeah.net?subject="></a><a class="iconfont cursor-pointer flex-none w-20px h-20px text-20px mr-15px md:mr-0 md:mb-20px 2xl:mb-50px md:w-30px md:h-30px md:text-30px iconenglish"></a></div><div class="min-w-0 flex-auto 2xl:flex flex-row items-start justify-between"><div class="min-w-0 2xl:flex-auto 2xl:mr-50px 2xl:pt-30px"><div class="text-center text-xl mb-6px md:text-4xl md:font-bold md:mb-10px 2xl:text-5xl 2xl:mb-15px font-medium">react的状态管理—利用react-redux</div><div class="text-center whitespace-pre-wrap text-gray-500 font-light text-14px leading-20px md:text-16px mb-20px">2018-09-23  |  <!-- -->11<!-- -->分钟<!-- -->  |  yrobot  |  <span class="md:hidden">
</span>react,redux,状态管理,利用</div><article class="prose prose-sm md:prose 2xl:prose-lg mb-15px md:mb-20px"><p><strong>本页目录：</strong><br><a href="#index">场景思考</a><br><a href="#redux">利用react-redux</a><br><a href="#result">查看效果</a><br><a href="#code">查看代码</a>  </p>
<p><a id='index'></a></p>
<h2 id="场景思考">场景思考</h2>
<p>现在我们用react去写一篇博客<br>博客包含 <code>标题</code> 和 <code>内容</code><br>而我期望<code>标题</code>和<code>内容</code>的颜色可以一键修改  </p>
<p>当然最暴力的实现方式就是利用dom操作去被动的修改<br>但是有没有更优雅更可控的方式呢？  </p>
<p>首先来看看项目的组件树：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg" alt=""></p>
<p>那么有什么好的优雅的方式使<code>Title</code>和<code>Content</code>的颜色保持一致呢？<br>换句话说，怎么更好的管理<code>Title</code>和<code>Content</code>的状态呢？ </p>
<h4 id="回顾上一节">回顾上一节</h4>
<p>上一节我们使用react自带的 <a href="../%E5%88%A9%E7%94%A8context%E6%B3%A8%E5%85%A5">利用context注入</a> 方法<br>利用react的context去实现状态共享很方便<br>但是react的context还是实验性的，何时会更新无法预知<br>所以为了保证软件的稳定性，我们还是使用react推荐的第三方状态管理redux   </p>
<p><a id='redux'></a></p>
<h2 id="利用react-redux">利用react-redux</h2>
<p>redux 是一套专业解决应用状态管理的独立的通用模块<br>它不仅可以和react结合，形成react-redux，也可以和vue、angular结合  </p>
<p><strong>react-redux的作用：</strong> 类似于react的context，react-redux在顶层组件利用Provider将store注入，在需要用到状态的组件处用connect函数包裹，从组件的props中获取store  </p>
<p><strong>react-redux的使用方法：</strong>  </p>
<ol>
<li>根据全局数据，将其拆分为多个<code>reducer</code></li>
<li>对于每个<code>reducer</code>分配<code>state</code>（<code>reducers.reducer</code>）和<code>action</code>，处理对应的<code>action</code>操作，生成行的<code>state</code></li>
<li>将<code>reducer</code>合并成<code>reducers</code>,<code>reducers</code>分配传入的<code>state</code>和<code>action</code>操作到<code>reducer</code> </li>
<li><code>createStore()</code>传入<code>reducers</code>生成<code>store</code>，并用<code>Provider</code>将<code>store</code>注入顶层组件</li>
<li>在要引用<code>store</code>的组件部分用<code>connect()</code>连接，<code>connect()</code>会注册监听、将<code>dispatch()</code>[默认写入]和<code>mapStateToProps</code>的属性写入<code>props</code>，当然如果使用<code>mapDispatchToProps</code>生成的<code>action creator</code>也会写入<code>props</code>。</li>
<li>在组件中通过<code>props</code>获取5中写入<code>props</code>的数据即可使用。</li>
<li>通过<code>dispatch()</code>的参数会触发<code>reducers</code>的<code>action</code>操作，从而更新状态  </li>
</ol>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvlqv6xb3uj30yu0sagqj.jpg" alt=""></p>
<p><strong>react-redux的优势：</strong> </p>
<ol>
<li>相对于react自带的context，react-redux更加稳定成熟，并对性能进行了优化  </li>
<li>相对于props的状态提升，react-redux更加的方便简洁，整个全局状态也更加清晰   </li>
</ol>
<p><strong>老话说的好，杀鸡焉用牛刀，在简单场景直接使用状态提升即可</strong>  </p>
<p><a id='result'></a></p>
<h2 id="查看效果">查看效果</h2>
<ol>
<li><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fvhmmoieh4j31kw0nxdpk.jpg" alt=""></li>
<li><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvhmmukgfyj31kw0o2qcy.jpg" alt=""></li>
</ol>
<p><a id='code'></a></p>
<h2 id="查看代码">查看代码</h2>
<p>reducers.js生成全局状态：  </p>
<pre><code>import { combineReducers } from &#39;redux&#39;

const mainColor = (state = &#39;black&#39;,action)=&gt;{
    switch (action.type){
        case &#39;CHANGE_COLOR&#39;:
            state = action.color;
            return state;
        default:
            return state;
    }
}

export default combineReducers({
    mainColor,
})
</code></pre>
<p>BlogPage.js中生成store，并利用Provider注入顶层组件：</p>
<pre><code>import reducers from &#39;./reducers.js&#39;

const store = createStore(reducers);

class BlogPage extends Component {
    constructor(props) {
        super(props);
        this.state = {
        }
    }
    render() {
        return (
            &lt;Provider store = {store}&gt;
                &lt;div className =&quot;blogContainer&quot;&gt;
                    &lt;Header &gt;&lt;/Header&gt;
                    &lt;Main&gt;&lt;/Main&gt;
                &lt;/div&gt;
            &lt;/Provider&gt;
        );
    }
}

export default BlogPage;
</code></pre>
<p>Content.js中利用connect()函数将状态写入组件props：  </p>
<pre><code>class Content extends Component {
    constructor(props) {
        super(props);
        this.state = {}
    }
    render() {
        const {mainColor,changeMainColor} = this.props;
        return (
            &lt;div className=&quot;content&quot; style={{ color: mainColor }}&gt;
                内容...
                &lt;div className=&quot;button&quot; onClick={() =&gt; { changeMainColor(&#39;#&#39; + (Math.random() * 0xffffff &lt;&lt; 0).toString(16)) }}&gt;切换颜色&lt;/div&gt;
            &lt;/div&gt;

        );
    }
}

const mapStateToProps = state =&gt; ({  //引入状态到props，并注册监听变化
    mainColor: state.mainColor
})

const mapDispatchToProps = dispatch =&gt; ({ //引入方法到props
    changeMainColor: color =&gt; {
        dispatch({
            type:&#39;CHANGE_COLOR&#39;,
            color,
        })
    }
})

export default connect(  //绑定组件 //高阶组件:函数接受一个组件作为参数，并返回一个新的组件
    mapStateToProps,
    mapDispatchToProps
)(Content);
</code></pre>
</article><div class="overflow-hidden flex flex-row items-center justify-between pt-10px md:pt-15px border-t-1px border-gray-200 mb-20px md:mb-40px"><span class="iconfont iconleft flex-none w-14px h-14px text-14px md:w-16px md:h-16px md:text-16px md:mr-4px"></span><a href="/blog/JS/DOM操作" class="flex-none w-40% text-14px leading-16px md:text-16px overflow-hidden whitespace-nowrap overflow-ellipsis">DOM操作</a><div class="mx-auto"></div><a href="/blog/SPA/react的状态管理/利用context注入" class="flex-none w-40% text-right text-14px leading-16px md:text-16px overflow-hidden whitespace-nowrap overflow-ellipsis">react的状态管理—利用context注入</a><span class="iconfont iconright flex-none w-14px h-14px text-14px md:w-16px md:h-16px md:text-16px md:ml-4px"></span></div><div class="mb-20px"><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div id="vcomments"></div></div></div><div class="2xl:flex-none 2xl:w-580px"><div class="pt-24px md:pt-24px 2xl:pt-30px mb-15px md:mb-20px"><div class="relative card pl-20px flex flex-col items-start justify-center h-96px md:h-126px 2xl:h-160px pr-120px md:pr-170px 2xl:pr-195px"><div class="text-20px md:text-26px 2xl:text-36px font-bold mb-10px md:mb-15px 2xl:mb-15px">你好！我是Yrobot</div><div class="text-14px md:text-16px 2xl:text-16px">欢迎来到我的博客，希望你在这里玩得开心！</div><img class="h-120px md:h-150px 2xl:h-190px absolute bottom-0 right-20px" src="/assets/person.svg" alt="person"/></div></div><div class="card mb-15px md:mb-20px overflow-hidden"><a href="https://github.com/Yrobot" target="_blank"><img src="https://github-readme-stats.vercel.app/api?count_private=true&amp;show_icons=true&amp;username=yrobot&amp;title_color=000000&amp;icon_color=000000&amp;text_color=000000&amp;border_color=F4F4F5&amp;bg_color=F4F4F5" alt="GithubCard"/></a></div><div class="card mb-15px md:mb-20px overflow-hidden"><a href="https://github.com/Yrobot/mina-touch" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin?repo=mina-touch&amp;username=yrobot&amp;title_color=000000&amp;icon_color=000000&amp;text_color=000000&amp;border_color=F4F4F5&amp;bg_color=F4F4F5" alt="GithubCard"/></a></div><div class="card mb-15px md:mb-20px overflow-hidden"><a href="https://github.com/Yrobot/react-mobile-table" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin?repo=react-mobile-table&amp;username=yrobot&amp;title_color=000000&amp;icon_color=000000&amp;text_color=000000&amp;border_color=F4F4F5&amp;bg_color=F4F4F5" alt="GithubCard"/></a></div><div class="card mb-15px md:mb-20px overflow-hidden"><a href="https://github.com/Yrobot/mina-popups" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin?repo=mina-popups&amp;username=yrobot&amp;title_color=000000&amp;icon_color=000000&amp;text_color=000000&amp;border_color=F4F4F5&amp;bg_color=F4F4F5" alt="GithubCard"/></a></div></div></div></div><footer class="bg-accent-1"></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"pre":{"path":"_blogs/JS/DOM操作/README.md","url":"/blog/JS/DOM操作","title":"DOM操作","author":"yrobot","keywords":"DOM,操作","createTime":1537977600000,"length":6547,"content":"\u003cp\u003e\u003ca id='top'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e本页目录：\u003c/strong\u003e\u003cbr\u003e\u003ca href=\"#nh\"\u003eNodeList 和 HTMLCollection\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#get\"\u003e获取DOM节点的方法\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#create\"\u003e生成节点的方法\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#action\"\u003eDOM操作方法\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#near\"\u003e关系节点获取\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#props\"\u003e元素属性设置\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#style\"\u003e元素样式修改\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#position\"\u003e获取元素宽高、位置\u003c/a\u003e  \u003c/p\u003e\n\u003cp\u003e\u003ca id='nh'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"nodelist-和-htmlcollection\"\u003eNodeList 和 HTMLCollection\u003c/h2\u003e\n\u003ch4 id=\"共同点：\"\u003e共同点：\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e都是类数组对象，都有length属性\u003c/li\u003e\n\u003cli\u003e都有共同的方法：item，可以通过item(index)或者item(id)来访问返回结果中的元素\u003c/li\u003e\n\u003cli\u003e都是实时变动的（live），document上的更改会反映到相关对象上（例外：document.querySelectorAll返回的NodeList不是实时的） \u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"不同点：\"\u003e不同点：\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003eNodeList可以包含任何节点类型（包括换行、元素间的文字），HTMLCollection只包含元素节点（elementNode），elementNode就是HTML中的标签\u003c/li\u003e\n\u003cli\u003eHTMLCollection比NodeList多一项方法：namedItem，可以通过传递id或name属性来获取节点信息\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca id='get'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"获取dom节点的方法\"\u003e获取DOM节点的方法\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003edocument.getElementById\u003c/code\u003e ：根据ID查找元素，大小写敏感，如果有多个结果，只返回第一个；只能document调用\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eDOM.getElementsByClassName\u003c/code\u003e ：根据类名查找元素，多个类名用空格分隔，返回一个 HTMLCollection 。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eDOM.getElementsByTagName\u003c/code\u003e ：根据标签查找元素， * 表示查询所有标签，返回一个 HTMLCollection 。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003edocument.getElementsByName\u003c/code\u003e ：根据元素的name属性查找，返回一个 NodeList 。只能document调用\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eDOM.querySelector\u003c/code\u003e ：返回单个Node，如果匹配到多个结果，只返回第一个。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eDOM.querySelectorAll\u003c/code\u003e ：返回一个 NodeList。不是实时的。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003edocument.forms\u003c/code\u003e ：获取当前页面所有form，返回一个 HTMLCollection ；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003edocument.documentElement\u003c/code\u003e：获取html节点\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e \u003ccode\u003edocument.body\u003c/code\u003e：获取body节点\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca id='create'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"生成节点的方法\"\u003e生成节点的方法\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003edocument.createElement(\u0026quot;p\u0026quot;)\u003c/code\u003e：生成HTML节点元素，参数为节点类型\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003edocument.createTextNode(\u0026quot;text\u0026quot;)\u003c/code\u003e:文本内容（无标签包裹），节点间的文本、节点内的文本\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eDOM.cloneNode()\u003c/code\u003e：方法创建节点的拷贝，并返回该副本。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca id='action'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"dom操作方法\"\u003eDOM操作方法\u003c/h2\u003e\n\u003ch3 id=\"添加元素：\"\u003e添加元素：\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eDOM.appendChild(元素)\u003c/code\u003e：在DOM节点末尾添加元素\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eparentNode.insertBefore(newNode, refNode)\u003c/code\u003e：在redNode前添加新元素newNode\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDOM.insertAdjacentElement(position,ele)\u003c/code\u003e：在DOM指定位置添加元素\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDOM.insertAdjacentHTML(position, text)\u003c/code\u003e：同上\u003cbr\u003e \u003cstrong\u003eposition\u003c/strong\u003e\u003cbr\u003e A DOMString representing the position relative to the element; must be one of the following strings: 相对于p节点\u003cbr\u003e 取值：\u003ccode\u003e\u0026#39;beforebegin\u0026#39;\u003c/code\u003e、\u003ccode\u003e\u0026#39;afterbegin\u0026#39;\u003c/code\u003e、\u003ccode\u003e\u0026#39;beforeend\u0026#39;\u003c/code\u003e、\u003ccode\u003e\u0026#39;afterend\u0026#39;\u003c/code\u003e  \u003cpre\u003e\u003ccode\u003e    \u0026lt;!-- beforebegin --\u0026gt;\n    \u0026lt;p\u0026gt;\n        \u0026lt;!-- afterbegin --\u0026gt;\n        foo\n        \u0026lt;!-- beforeend --\u0026gt;\n    \u0026lt;/p\u0026gt;\n    \u0026lt;!-- afterend --\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n \u003cstrong\u003etext\u003c/strong\u003e\u003cbr\u003e text is the string to be parsed as HTML or XML and inserted into the tree.例如\u003ccode\u003e\u0026#39;\u0026lt;div id=\u0026quot;two\u0026quot;\u0026gt;two\u0026lt;/div\u0026gt;\u0026#39;\u003c/code\u003e\u003cbr\u003e \u003cstrong\u003eelement\u003c/strong\u003e\u003cbr\u003e 要插入到树中的元素.  \u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"删除元素：\"\u003e删除元素：\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eparentNode.removeChild(node)\u003c/code\u003e：删除parentNode下的node节点，注意是实时更新的，删除时index会时时改变\u003cpre\u003e\u003ccode\u003efunction removeNode(node)  \n{  \n    if(!node) return;  \n    if(node.parentNode) node.parentNode.removeChild(node);  \n}  \n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eparentNode.replaceChild(newChild, oldChild)\u003c/code\u003e：将oldChild替换为newChild\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca id='near'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"关系节点获取\"\u003e关系节点获取\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eparentNode\u003c/code\u003e ：返回元素的父节点。Element的父节点可能是Element，Document或DocumentFragment；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eparentElement\u003c/code\u003e ：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element元素，如果不是，则返回null；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003echildren\u003c/code\u003e ：返回一个实时的 HTMLCollection ，子节点都是Element，IE9以下浏览器不支持；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003echildNodes\u003c/code\u003e ：返回一个实时的 NodeList ，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003efirstChild\u003c/code\u003e ：返回第一个子节点，不存在返回null，与之相对应的还有一个 firstElementChild ；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003elastChild\u003c/code\u003e ：返回最后一个子节点，不存在返回null，与之相对应的还有一个 lastElementChild ；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003epreviousSibling\u003c/code\u003e ：返回节点的前一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003enextSibling\u003c/code\u003e ：返回节点的后一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e \u003ccode\u003epreviousElementSibling\u003c/code\u003e ：返回前一个element元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003enextElementSibling\u003c/code\u003e ：返回后一个element元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca id='props'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"元素属性设置\"\u003e元素属性设置\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eDOM.setAttribute(name, value)\u003c/code\u003e: name是特性名，value是特性值，如 DOM.setAttribute(\u0026#39;name\u0026#39;, \u0026#39;ele\u0026#39;);\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eDOM.getAttribute(name)\u003c/code\u003e: 返回指定的特性名相应的特性值，如果不存在，则返回nul\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eDOM.hasAttribute(name)\u003c/code\u003e: 判断DOM是否存在name的属性\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eDOM.dataset\u003c/code\u003e: 获取html data-开头的属性\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;div id=\u0026quot;user\u0026quot; data-id=\u0026quot;1234567890\u0026quot; data-user=\u0026quot;johndoe\u0026quot; data-date-of-birth\u0026gt;John Doe\u0026lt;/div\u0026gt;\n\nlet el = document.querySelector(\u0026#39;#user\u0026#39;);\n// el.id == \u0026#39;user\u0026#39;\n// el.dataset.id === \u0026#39;1234567890\u0026#39;\n// el.dataset.user === \u0026#39;johndoe\u0026#39;\n// el.dataset.dateOfBirth === \u0026#39;\u0026#39;\n\nel.dataset.dateOfBirth = \u0026#39;1960-10-03\u0026#39;; // set the DOB.\n// \u0026#39;someDataAttr\u0026#39; in el.dataset === false\n\nel.dataset.someDataAttr = \u0026#39;mydata\u0026#39;;\n// \u0026#39;someDataAttr\u0026#39; in el.dataset === true\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca id='style'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"元素样式修改\"\u003e元素样式修改\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e直接修改元素style样式： \u003cem\u003e\u003ccode\u003eelement.sytle.xxx\u003c/code\u003e只能获取到内联样式\u003c/em\u003e  \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eelem.style.color = \u0026#39;red\u0026#39;;    \nelem.style.setProperty(\u0026#39;font-size\u0026#39;, \u0026#39;16px\u0026#39;);    \nelem.style.removeProperty(\u0026#39;color\u0026#39;); \n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e动态添加样式规则：  \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar style = document.createElement(\u0026#39;style\u0026#39;);  \nstyle.innerHTML = \u0026#39;body{color:red} #top:hover{background-color: red;color: white;}\u0026#39;;  \ndocument.head.appendChild(style);  \n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eclassList获取样式class\u003cbr\u003e \u003cstrong\u003e\u003ccode\u003eDOM.classList.xxx()\u003c/code\u003e:\u003c/strong\u003e   \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eadd( String [, String] )\u003cbr\u003e添加指定的类值。如果这些类已经存在于元素的属性中，那么它们将被忽略。\u003c/li\u003e\n\u003cli\u003eremove( String [,String] )\u003cbr\u003e删除指定的类值。  \u003c/li\u003e\n\u003cli\u003eitem ( Number )\u003cbr\u003e按集合中的索引返回类值。  \u003c/li\u003e\n\u003cli\u003etoggle ( String [, force] )\u003cbr\u003e当只有一个参数时：切换 class value; 即如果类存在，则删除它并返回false，如果不存在，则添加它并返回true。\u003cbr\u003e当存在第二个参数时：如果第二个参数的计算结果为true，则添加指定的类值，如果计算结果为false，则删除它  \u003c/li\u003e\n\u003cli\u003econtains( String )\u003cbr\u003e检查元素的类属性中是否存在指定的类值。  \u003c/li\u003e\n\u003cli\u003ereplace( String, String )\u003cbr\u003e用一个新类替换已有类。   \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e使用\u003ccode\u003ewindow.getComputedStyle\u003c/code\u003e： \u003cem\u003e借助\u003ccode\u003ewindow.getComputedStyle\u003c/code\u003e可以获取应用到元素上的所有样式\u003c/em\u003e\u003cbr\u003e \u003ccode\u003elet style = window.getComputedStyle(element, [pseudoElt]);\u003c/code\u003e  \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eelement\u003cbr\u003e用于获取计算样式的Element。  \u003c/li\u003e\n\u003cli\u003epseudoElt [可选]\u003cbr\u003e指定一个要匹配的伪元素的字符串。必须对普通元素省略（或null）。 \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e 返回的style是一个实时的 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CSSStyleDeclaration\"\u003eCSSStyleDeclaration\u003c/a\u003e 对象，当元素的样式更改时，它会自动更新本身。   \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet elem = document.getElementById(\u0026quot;elem-container\u0026quot;);\nwindow.getComputedStyle(elem,null).height = \u0026#39;100px\u0026#39;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca id='position'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"获取元素宽高、位置\"\u003e获取元素宽高、位置\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003egetBoundingClientRect()\u003c/code\u003e:\u003cbr\u003e \u003ccode\u003eDOM.getBoundingClientRect()\u003c/code\u003e的属性：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eAttribute\u003c/th\u003e\n\u003cth\u003eType\u003c/th\u003e\n\u003cth\u003eDescription\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003ebottom\u003c/td\u003e\n\u003ctd\u003efloat\u003c/td\u003e\n\u003ctd\u003eY 轴，相对于视口原点（viewport origin）矩形盒子的底部。只读。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eheight\u003c/td\u003e\n\u003ctd\u003efloat\u003c/td\u003e\n\u003ctd\u003e矩形盒子的高度（等同于 bottom 减 top）。只读。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eleft\u003c/td\u003e\n\u003ctd\u003efloat\u003c/td\u003e\n\u003ctd\u003eX 轴，相对于视口原点（viewport origin）矩形盒子的左侧。只读。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eright\u003c/td\u003e\n\u003ctd\u003efloat\u003c/td\u003e\n\u003ctd\u003eX 轴，相对于视口原点（viewport origin）矩形盒子的右侧。只读。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003etop\u003c/td\u003e\n\u003ctd\u003efloat\u003c/td\u003e\n\u003ctd\u003eY 轴，相对于视口原点（viewport origin）矩形盒子的顶部。只读。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ewidth\u003c/td\u003e\n\u003ctd\u003efloat\u003c/td\u003e\n\u003ctd\u003e矩形盒子的宽度（等同于 right 减 left）。只读。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ex\u003c/td\u003e\n\u003ctd\u003efloat\u003c/td\u003e\n\u003ctd\u003eX 轴，相对于视口原点（viewport origin）矩形盒子的左侧。只读。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ey\u003c/td\u003e\n\u003ctd\u003efloat\u003c/td\u003e\n\u003ctd\u003eY 轴，相对于视口原点（viewport origin）矩形盒子的顶部。只读。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eclientRect是一个 DOMRect 对象，包含width、height、left、top、right、bottom，它是相对于窗口顶部而不是文档顶部，__滚动页面时它们的值是会发生变化的__。\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eDOM.clientWidth\u003c/code\u003e：表示元素的内部宽度，以像素计。盒模型的content+padding\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eDOM.offsetLeft\u003c/code\u003e：返回当前元素左上角相对于  HTMLElement.offsetParent (距离元素的最近的父级定位元素) 节点的左边界偏移的像素值。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eDOM.scrollLeft\u003c/code\u003e 属性可以读取或设置元素滚动条到元素左边的距离。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n"},"blog":{"path":"_blogs/SPA/react的状态管理/利用react-redux.md","url":"/blog/SPA/react的状态管理/利用react-redux","title":"react的状态管理—利用react-redux","author":"yrobot","keywords":"react,redux,状态管理,利用","createTime":1537632000000,"length":3545,"content":"\u003cp\u003e\u003cstrong\u003e本页目录：\u003c/strong\u003e\u003cbr\u003e\u003ca href=\"#index\"\u003e场景思考\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#redux\"\u003e利用react-redux\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#result\"\u003e查看效果\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#code\"\u003e查看代码\u003c/a\u003e  \u003c/p\u003e\n\u003cp\u003e\u003ca id='index'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"场景思考\"\u003e场景思考\u003c/h2\u003e\n\u003cp\u003e现在我们用react去写一篇博客\u003cbr\u003e博客包含 \u003ccode\u003e标题\u003c/code\u003e 和 \u003ccode\u003e内容\u003c/code\u003e\u003cbr\u003e而我期望\u003ccode\u003e标题\u003c/code\u003e和\u003ccode\u003e内容\u003c/code\u003e的颜色可以一键修改  \u003c/p\u003e\n\u003cp\u003e当然最暴力的实现方式就是利用dom操作去被动的修改\u003cbr\u003e但是有没有更优雅更可控的方式呢？  \u003c/p\u003e\n\u003cp\u003e首先来看看项目的组件树：\u003cbr\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e那么有什么好的优雅的方式使\u003ccode\u003eTitle\u003c/code\u003e和\u003ccode\u003eContent\u003c/code\u003e的颜色保持一致呢？\u003cbr\u003e换句话说，怎么更好的管理\u003ccode\u003eTitle\u003c/code\u003e和\u003ccode\u003eContent\u003c/code\u003e的状态呢？ \u003c/p\u003e\n\u003ch4 id=\"回顾上一节\"\u003e回顾上一节\u003c/h4\u003e\n\u003cp\u003e上一节我们使用react自带的 \u003ca href=\"../%E5%88%A9%E7%94%A8context%E6%B3%A8%E5%85%A5\"\u003e\b利用context注入\u003c/a\u003e 方法\u003cbr\u003e利用react的context去实现状态共享很方便\u003cbr\u003e但是react的context还是实验性的，何时会更新无法预知\u003cbr\u003e所以为了保证软件的稳定性，我们还是使用react推荐的第三方状态管理redux   \u003c/p\u003e\n\u003cp\u003e\u003ca id='redux'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"利用react-redux\"\u003e利用react-redux\u003c/h2\u003e\n\u003cp\u003eredux 是一套专业解决应用状态管理的独立的通用模块\b\u003cbr\u003e它不仅可以和react结合，形成react-redux，也可以和vue、angular结合  \u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ereact-redux的作用：\u003c/strong\u003e 类似于\breact的context，\breact-redux在顶层组件利用Provider将store注入，在需要用到状态的组件处用connect函数包裹，从组件的props中获取store  \u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ereact-redux的使用方法：\u003c/strong\u003e  \u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e根据全局数据，将其拆分为多个\u003ccode\u003ereducer\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e对于每个\u003ccode\u003ereducer\u003c/code\u003e分配\u003ccode\u003estate\u003c/code\u003e（\u003ccode\u003ereducers.reducer\u003c/code\u003e）和\u003ccode\u003eaction\u003c/code\u003e，处理对应的\u003ccode\u003eaction\u003c/code\u003e操作，生成行的\u003ccode\u003estate\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e将\u003ccode\u003ereducer\u003c/code\u003e合并成\u003ccode\u003ereducers\u003c/code\u003e,\u003ccode\u003ereducers\u003c/code\u003e分配传入的\u003ccode\u003estate\u003c/code\u003e和\u003ccode\u003eaction\u003c/code\u003e操作到\u003ccode\u003ereducer\u003c/code\u003e \u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecreateStore()\u003c/code\u003e传入\u003ccode\u003ereducers\u003c/code\u003e生成\u003ccode\u003estore\u003c/code\u003e，并用\u003ccode\u003eProvider\u003c/code\u003e将\u003ccode\u003estore\u003c/code\u003e注入顶层组件\u003c/li\u003e\n\u003cli\u003e在要引用\u003ccode\u003estore\u003c/code\u003e的组件部分用\u003ccode\u003econnect()\u003c/code\u003e连接，\u003ccode\u003econnect()\u003c/code\u003e会注册监听、将\u003ccode\u003edispatch()\u003c/code\u003e[默认写入]和\u003ccode\u003emapStateToProps\u003c/code\u003e的属性写入\u003ccode\u003eprops\u003c/code\u003e，当然如果使用\u003ccode\u003emapDispatchToProps\u003c/code\u003e生成的\u003ccode\u003eaction creator\u003c/code\u003e也会写入\u003ccode\u003eprops\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e在组件中通过\u003ccode\u003eprops\u003c/code\u003e获取5中写入\u003ccode\u003eprops\u003c/code\u003e的数据即可使用。\u003c/li\u003e\n\u003cli\u003e通过\u003ccode\u003edispatch()\u003c/code\u003e的参数会触发\u003ccode\u003ereducers\u003c/code\u003e的\u003ccode\u003eaction\u003c/code\u003e操作，从而更新状态  \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fvlqv6xb3uj30yu0sagqj.jpg\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ereact-redux的优势：\u003c/strong\u003e \u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e相对于react自带的context，react-redux更加稳定成熟，并对性能进行了优化  \u003c/li\u003e\n\u003cli\u003e相对于props的状态提升，react-redux更加的方便简洁，整个全局状态也更加清晰   \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e老话说的好，杀鸡焉用牛刀，在简单场景直接使用状态提升即可\u003c/strong\u003e  \u003c/p\u003e\n\u003cp\u003e\u003ca id='result'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"查看效果\"\u003e查看效果\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tNbRwgy1fvhmmoieh4j31kw0nxdpk.jpg\" alt=\"\"\u003e\u003c/li\u003e\n\u003cli\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fvhmmukgfyj31kw0o2qcy.jpg\" alt=\"\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca id='code'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"查看代码\"\u003e查看代码\u003c/h2\u003e\n\u003cp\u003ereducers.js生成全局状态：  \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport { combineReducers } from \u0026#39;redux\u0026#39;\n\nconst mainColor = (state = \u0026#39;black\u0026#39;,action)=\u0026gt;{\n    switch (action.type){\n        case \u0026#39;CHANGE_COLOR\u0026#39;:\n            state = action.color;\n            return state;\n        default:\n            return state;\n    }\n}\n\nexport default combineReducers({\n    mainColor,\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBlogPage.js中\b生成store，并利用Provider注入顶层组件：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport reducers from \u0026#39;./reducers.js\u0026#39;\n\nconst store = createStore(reducers);\n\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n        }\n    }\n    render() {\n        return (\n            \u0026lt;Provider store = {store}\u0026gt;\n                \u0026lt;div className =\u0026quot;blogContainer\u0026quot;\u0026gt;\n                    \u0026lt;Header \u0026gt;\u0026lt;/Header\u0026gt;\n                    \u0026lt;Main\u0026gt;\u0026lt;/Main\u0026gt;\n                \u0026lt;/div\u0026gt;\n            \u0026lt;/Provider\u0026gt;\n        );\n    }\n}\n\nexport default BlogPage;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eContent.js中利用connect()函数将状态写入组件props：  \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    render() {\n        const {mainColor,changeMainColor} = this.props;\n        return (\n            \u0026lt;div className=\u0026quot;content\u0026quot; style={{ color: mainColor }}\u0026gt;\n                内容...\n                \u0026lt;div className=\u0026quot;button\u0026quot; onClick={() =\u0026gt; { changeMainColor(\u0026#39;#\u0026#39; + (Math.random() * 0xffffff \u0026lt;\u0026lt; 0).toString(16)) }}\u0026gt;切换颜色\u0026lt;/div\u0026gt;\n            \u0026lt;/div\u0026gt;\n\n        );\n    }\n}\n\nconst mapStateToProps = state =\u0026gt; ({  //引入状态到props，并注册监听变化\n    mainColor: state.mainColor\n})\n\nconst mapDispatchToProps = dispatch =\u0026gt; ({ //引入方法到props\n    changeMainColor: color =\u0026gt; {\n        dispatch({\n            type:\u0026#39;CHANGE_COLOR\u0026#39;,\n            color,\n        })\n    }\n})\n\nexport default connect(  //绑定组件 //高阶组件:函数接受一个组件作为参数，并返回一个新的组件\n    mapStateToProps,\n    mapDispatchToProps\n)(Content);\n\u003c/code\u003e\u003c/pre\u003e\n"},"next":{"path":"_blogs/SPA/react的状态管理/利用context注入.md","url":"/blog/SPA/react的状态管理/利用context注入","title":"react的状态管理—利用context注入","author":"yrobot","keywords":"context,状态管理,react,注入,利用","createTime":1537545600000,"length":3383,"content":"\u003cp\u003e\u003cstrong\u003e本页目录：\u003c/strong\u003e\u003cbr\u003e\u003ca href=\"#index\"\u003e场景思考\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#context\"\u003e利用context注入\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#result\"\u003e查看效果\u003c/a\u003e\u003cbr\u003e\u003ca href=\"#code\"\u003e查看代码\u003c/a\u003e  \u003c/p\u003e\n\u003cp\u003e\u003ca id='index'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"场景思考\"\u003e场景思考\u003c/h2\u003e\n\u003cp\u003e现在我们用react去写一篇博客\u003cbr\u003e博客包含 \u003ccode\u003e标题\u003c/code\u003e 和 \u003ccode\u003e内容\u003c/code\u003e\u003cbr\u003e而我期望\u003ccode\u003e标题\u003c/code\u003e和\u003ccode\u003e内容\u003c/code\u003e的颜色可以一键修改  \u003c/p\u003e\n\u003cp\u003e当然最暴力的实现方式就是利用dom操作去被动的修改\u003cbr\u003e但是有没有更优雅更可控的方式呢？  \u003c/p\u003e\n\u003cp\u003e首先来看看项目的组件树：\u003cbr\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e那么有什么好的优雅的方式使\u003ccode\u003eTitle\u003c/code\u003e和\u003ccode\u003eContent\u003c/code\u003e的颜色保持一致呢？\u003cbr\u003e换句话说，怎么更好的管理\u003ccode\u003eTitle\u003c/code\u003e和\u003ccode\u003eContent\u003c/code\u003e的状态呢？ \u003c/p\u003e\n\u003ch4 id=\"回顾上一节\"\u003e回顾上一节\u003c/h4\u003e\n\u003cp\u003e上一节我们使用最基础的\u003ca href=\"../%E5%88%A9%E7%94%A8props%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87\"\u003eprops状态提升\u003c/a\u003e的方法\u003cbr\u003e但当组件链很长的时候，新增一个状态就必须修改每个组件的props\u003cbr\u003e那有没有跟直接的方法，搞一个共享状态，每个组件可以自由访问呢\u003cbr\u003ereact自带的context就是用来实现这一点的  \u003c/p\u003e\n\u003cp\u003e\u003ca id='context'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"利用context注入\"\u003e利用context注入\u003c/h2\u003e\n\u003cp\u003ereact的context可以代替props的传递工作  \u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003econtext的作用：\u003c/strong\u003e 将顶部\b组件的状态和方法与子组件共享  \u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003econtext的使用方法：\u003c/strong\u003e  \u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e利用\u003ccode\u003eReact.createContext()\u003c/code\u003e生成一对\u003ccode\u003e{Provider,Consumer}\u003c/code\u003e  \u003c/li\u003e\n\u003cli\u003e用生成的\u003ccode\u003eProvider\u003c/code\u003e包裹\b顶部组件，利用他props的value字段传入共享状态与方法  \u003cpre\u003e\u003ccode\u003e \u0026lt;Provider value={{状态和方法}}\u0026gt;\n     \u0026lt;顶层组件\u0026gt;\n \u0026lt;/Provider\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e用生成的\u003ccode\u003eConsumer\u003c/code\u003e包裹使用共享状态的组件，在Consumer内子组件外用函数传入共享的状态  \u003cpre\u003e\u003ccode\u003e \u0026lt;Consumer\u0026gt;\n     {value =\u0026gt; (\n         \u0026lt;子组件 使用value\u0026gt;\n     )}\n \u0026lt;/Consumer\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e保证状态位于顶层组件的\u003ccode\u003estate\u003c/code\u003e中，而共享的方法要更新状态也是利用\u003ccode\u003esetState\u003c/code\u003e，这样UI层才会刷新  \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fvhm1xim52j30yg0pqads.jpg\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003econtext的优势：\u003c/strong\u003e \u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e只需要在顶层组件和用到状态的子组件进行操作，省去了props状态提升中对中间组件的数据传递操作。代码更清晰。   \u003c/li\u003e\n\u003cli\u003e无需引入第三方状态管理，学习成本也相对较低  \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e尽管context相对于props状态提升方便很多，\b但是react官网还是 \u003cem\u003e不建议\u003c/em\u003e 使用context，因为context的API是实验性的，在未来的react版本中会被修改。\u003c/strong\u003e  \u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e在简单场景,推荐使用props状态提升\u003c/strong\u003e\u003cbr\u003e\u003cstrong\u003e在较复杂的场景，应该考虑引入第三方状态管理(如Redux、Mobx)\u003c/strong\u003e  \u003c/p\u003e\n\u003cp\u003e\u003ca id='result'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"查看效果\"\u003e查看效果\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tNbRwgy1fvhmmoieh4j31kw0nxdpk.jpg\" alt=\"\"\u003e\u003c/li\u003e\n\u003cli\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fvhmmukgfyj31kw0o2qcy.jpg\" alt=\"\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca id='code'\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"查看代码\"\u003e查看代码\u003c/h2\u003e\n\u003cp\u003emainColorContext.js暴露React.createContext：  \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport React from \u0026#39;react\u0026#39;;\n\nexport const mainColorContext = React.createContext(\n    {\n        mainColor:\u0026#39;black\u0026#39;\n    } // 默认值\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBlogPage.js中引入mainColorContext，定义全局状态mainColor和方法changeMainColor()并传入Provider： \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport {mainColorContext} from \u0026#39;./mainColorContext.js\u0026#39;\n\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            mainColor: \u0026#39;black\u0026#39;\n        }\n    }\n    changeMainColor = (color) =\u0026gt; {\n        this.setState({ //this的绑定//运行时//但是箭头函数没有this//直接沿着作用域链往上找找到BlogPage类的this //换成function就不行了，obj.func()会修改this指向为obj\n            mainColor: color\n        })\n    }\n    render() {\n        const { mainColor } = this.state;\n        return (\n            \u0026lt;mainColorContext.Provider value={{mainColor,changeMainColor:this.changeMainColor}}\u0026gt;\n                \u0026lt;div className=\u0026quot;blogContainer\u0026quot;\u0026gt;\n                    \u0026lt;Header \u0026gt;\u0026lt;/Header\u0026gt;\n                    \u0026lt;Main\u0026gt;\u0026lt;/Main\u0026gt;\n                \u0026lt;/div\u0026gt;\n            \u0026lt;/mainColorContext.Provider\u0026gt;\n        );\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eContent.js组件中获取使用Consumer传递的数据和方法：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport {mainColorContext} from \u0026#39;../../BlogPage/mainColorContext.js\u0026#39;\n\nclass Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    render() {\n        return (\n            \u0026lt;mainColorContext.Consumer\u0026gt;\n                {value =\u0026gt; (\n                    \u0026lt;div className=\u0026quot;content\u0026quot; style={{ color: value.mainColor }}\u0026gt;\n                        文本...\n                    \u0026lt;div className=\u0026quot;button\u0026quot; onClick={()=\u0026gt;{value.changeMainColor(\u0026#39;#\u0026#39; + (Math.random() * 0xffffff \u0026lt;\u0026lt; 0).toString(16))}}\u0026gt;切换颜色\u0026lt;/div\u0026gt;\n                    \u0026lt;/div\u0026gt;\n                )}\n            \u0026lt;/mainColorContext.Consumer\u0026gt;\n\n        );\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n"}},"__N_SSG":true},"page":"/blog/[...path]","query":{"path":["SPA","react的状态管理","利用react-redux"]},"buildId":"trv4pPKhEz2hyxp1vQMH6","isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-8683bd742a84c1edd48c.js"></script><script src="/_next/static/chunks/webpack-5f970f2ad4ea41d50dab.js" async=""></script><script src="/_next/static/chunks/framework-d3984ef788efc6bd8157.js" async=""></script><script src="/_next/static/chunks/597-9d03ea954e499bbdd7af.js" async=""></script><script src="/_next/static/chunks/778-1467ee0b708f5cd375c0.js" async=""></script><script src="/_next/static/chunks/main-9ca82ec4d4aca520c43d.js" async=""></script><script src="/_next/static/chunks/pages/_app-d1fff168fcebfddb9829.js" async=""></script><script src="/_next/static/chunks/500-9a32898805276f2ba062.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5B...path%5D-b0ff53552a2952cc4827.js" async=""></script><script src="/_next/static/trv4pPKhEz2hyxp1vQMH6/_buildManifest.js" async=""></script><script src="/_next/static/trv4pPKhEz2hyxp1vQMH6/_ssgManifest.js" async=""></script></body></html>