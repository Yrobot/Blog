<!DOCTYPE html><html><head><link rel="icon" href="favicon.ico"/><link rel="preload" href="//at.alicdn.com/t/font_2533274_yhzuq4j0hfr.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="stylesheet" href="//at.alicdn.com/t/font_2533274_yhzuq4j0hfr.css"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/><title>Yrobot&#x27;s Blog</title><meta name="next-head-count" content="3"/><link rel="preload" href="/docs/_next/static/css/38f07f2a72553a556357.css" as="style"/><link rel="stylesheet" href="/docs/_next/static/css/38f07f2a72553a556357.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/docs/_next/static/chunks/webpack-208e2f69f0f38c7c6e8e.js" as="script"/><link rel="preload" href="/docs/_next/static/chunks/framework-d3984ef788efc6bd8157.js" as="script"/><link rel="preload" href="/docs/_next/static/chunks/597-ebe22cee24f07ec0dbde.js" as="script"/><link rel="preload" href="/docs/_next/static/chunks/778-1467ee0b708f5cd375c0.js" as="script"/><link rel="preload" href="/docs/_next/static/chunks/main-9ca82ec4d4aca520c43d.js" as="script"/><link rel="preload" href="/docs/_next/static/chunks/pages/_app-5560dea6b09e4f77dbca.js" as="script"/><link rel="preload" href="/docs/_next/static/chunks/500-9a32898805276f2ba062.js" as="script"/><link rel="preload" href="/docs/_next/static/chunks/pages/index-467caf0c573490ef4707.js" as="script"/></head><body><div id="__next"><div class="mx-auto 2xl:max-w-screen-2xl md:max-w-screen-lg"><div class="md:flex flex-row items-start justify-between"><div class="card menu h-60px md:flex-none md:w-90px md:h-600px md:mr-20px 2xl:w-120px 2xl:h-850px 2xl: 2xl:mr-50px flex flex-row items-center justify-between md:flex-col mb-20px"><a class="iconfont iconlogo flex-none mr-auto ml-15px md:ml-0 md:mr-0 md:mt-20px md:mb-auto w-30px h-30px text-30px md:w-50px md:h-50px md:text-50px 2xl:w-60px 2xl:h-60px 2xl:text-60px"></a><a class="iconfont iconhome cursor-pointer flex-none w-20px h-20px text-20px mr-20px md:mr-0 md:mb-50px md:w-30px md:h-30px md:text-30px" href="/"></a><a class="iconfont icongithub cursor-pointer flex-none w-20px h-20px text-20px mr-20px md:mr-0 md:mb-50px md:w-30px md:h-30px md:text-30px" target="_blank" href="https://github.com/Yrobot"></a><a class="iconfont iconemail cursor-pointer flex-none w-20px h-20px text-20px  mr-20px md:mr-0 md:mb-50px md:w-30px md:h-30px md:text-30px" href="mailto:y_robot@yeah.net?subject="></a><a class="iconfont cursor-pointer flex-none w-20px h-20px text-20px mr-15px md:mr-0 md:mb-20px 2xl:mb-50px md:w-30px md:h-30px md:text-30px iconenglish"></a></div><div class="flex-auto 2xl:flex flex-row items-start justify-between"><div class="2xl:flex-auto 2xl:mr-50px 2xl:pt-30px"><div class="flex flex-row items-start justify-between mb-20px helvetica-neue"><div class="card mr-15px md:mr-20px w-0 flex-auto py-20px flex flex-row items-center justify-center"><div class="mr-15px md:mr-20px flex-none text-30px md:text-50px 2xl:text-64px">30</div><div class="flex-none text-14px md:text-16px 2xl:text-20px whitespace-pre">完成的
博客</div></div><div class="card w-0 flex-auto py-20px flex flex-row items-center justify-center"><div class="mr-15px md:mr-20px flex-none text-30px md:text-50px 2xl:text-64px">1</div><div class="flex-none text-14px md:text-16px 2xl:text-20px whitespace-pre">进行中的
博客</div></div></div><div class="text-20px md:text-24px mb-20px">博客</div><div class="text-14px md:text-16px mb-20px whitespace-nowrap overflow-x-scroll select-none"><span class="mr-40px cursor-pointer ">全部</span><span class="mr-40px cursor-pointer opacity-30">JS</span><span class="mr-40px cursor-pointer opacity-30">CSS3</span><span class="mr-40px cursor-pointer opacity-30">利用</span><span class="mr-40px cursor-pointer opacity-30">属性</span><span class="mr-40px cursor-pointer opacity-30">状态管理</span><span class="mr-40px cursor-pointer opacity-30">react</span></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">前端路由</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">路由, 前端</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">6<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2019-11-01</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">6<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2019-11-01</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">JS模块化</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">JS, 模块化</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">17<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2019-10-15</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">17<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2019-10-15</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">探讨ESM对当前开发的意义或影响</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">ESM, 探讨, 意义, 当前, 开发, 影响</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">5<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2019-10-15</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">5<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2019-10-15</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">浏览器是怎么处理多个defer或async的script的</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">async, script, defer, 浏览器, 多个, 处理</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">1<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2019-10-15</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">1<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2019-10-15</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">css层叠上下文</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">css, 层叠, 上下文</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">5<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2019-09-17</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">5<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2019-09-17</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">计网体系结构 - OSI、TCP/IP、五层协议体系</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">计网, OSI, TCP, IP, 五层协议体系, 体系结构</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">15<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-10-06</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">15<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-10-06</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">小程序的分享与传参</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">小程序, 传参, 分享</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">18<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-09-30</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">18<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-09-30</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">DOM操作</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">DOM, 操作</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">22<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-09-27</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">22<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-09-27</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">react的状态管理—利用react-redux</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">react, redux, 状态管理, 利用</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">12<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-09-23</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">12<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-09-23</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">react的状态管理—利用context注入</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">context, 状态管理, react, 注入, 利用</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">11<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-09-22</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">11<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-09-22</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">react的状态管理—利用props状态提升</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">状态管理, props, react, 状态, 提升, 利用</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">8<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-09-18</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">8<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-09-18</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">利用css绘制多边形</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">css, 多边形, 绘制, 利用</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">23<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-09-03</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">23<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-09-03</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">小程序的运行</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">小程序, 运行</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">5<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-09-03</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">5<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-09-03</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">CSS3-3D转换</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">3D, CSS3, 转换</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">18<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-31</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">18<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-31</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">CSS3-2D转换</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">2D, CSS3, 转换</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">7<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-28</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">7<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-28</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">CSS3动画</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">CSS3, 动画</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">14<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-28</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">14<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-28</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">CSS3过渡</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">CSS3, 过渡</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">5<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-28</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">5<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-28</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">CSS3新增属性</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">CSS3, 属性, 新增</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">38<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-27</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">38<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-27</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">Meta标签—Viewport</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">Meta, Viewport, 标签</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">15<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-25</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">15<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-25</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">CSS中可以和不可以继承的属性</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">CSS, 属性, 继承</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">9<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-24</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">9<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-24</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">display 属性</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">display, 属性</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-24</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-24</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">JS-DOM事件触发机制</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">DOM, JS, 触发, 机制, 事件</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">11<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-24</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">11<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-24</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">JS函数与闭包</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">闭包, JS, 函数</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">6<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-24</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">6<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-24</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">JS异步编程</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">JS, 异步, 编程</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">14<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-24</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">14<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-24</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">JS的三个定时器</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">JS, 定时器, 三个</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">14<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-24</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">14<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-24</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">THIS的指向</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">THIS, 指向</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">3<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-24</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">3<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-24</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">遍历obj和array</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">array, obj, 遍历</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">5<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-24</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">5<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-24</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">markdown注意点</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">markdown, 注意</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">1<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-24</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">1<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-24</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">JS多线程Web Worker</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">多线程, Worker, JS, Web</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">13<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-23</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">13<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-23</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div><div class="card p-15px mb-15px md:p-20px md:mb-20px md:flex flex-row items-center justify-between"><div class="flex-auto md:w-0"><div class="text-16px leading-18px font-bold mb-4px md:mb-10px overflow-hidden whitespace-nowrap overflow-ellipsis">JSON使用注意点</div><div class="text-14px leading-16px overflow-hidden whitespace-nowrap overflow-ellipsis">JSON, 注意, 使用</div></div><div class="flex flex-row items-center justify-between mt-15px md:hidden"><div class="text-16px font-bold mr-auto cursor-pointer">查看</div><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">6<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px">2018-08-23</span></div><div class="hidden md:flex flex-none items-center justify-between"><span class="iconfont icondate w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">6<!-- -->分钟</span><span class="iconfont icontime w-16px h-16px text-16px mr-4px"></span><span class="text-14px mr-15px">2018-08-23</span><div class="px-40px py-8px bg-black text-white rounded-8px cursor-pointer">查看</div></div></div></div><div class="2xl:flex-none 2xl:w-580px"><div class="pt-24px md:pt-24px 2xl:pt-30px mb-15px md:mb-20px"><div class="relative card pl-20px flex flex-col items-start justify-center h-96px md:h-126px 2xl:h-160px pr-120px md:pr-170px 2xl:pr-195px"><div class="text-20px md:text-26px 2xl:text-36px font-bold mb-10px md:mb-15px 2xl:mb-15px">你好！我是Yrobot</div><div class="text-14px md:text-16px 2xl:text-16px">欢迎来到我的博客，希望你在这里玩得开心！</div><img class="h-120px md:h-150px 2xl:h-190px absolute bottom-0 right-20px" src="/assets/person.svg" alt="person"/></div></div><div class="card mb-15px md:mb-20px overflow-hidden"><a href="https://github.com/Yrobot" target="_blank"><img src="https://github-readme-stats.vercel.app/api?count_private=true&amp;show_icons=true&amp;username=yrobot&amp;title_color=000000&amp;icon_color=000000&amp;text_color=000000&amp;border_color=F4F4F5&amp;bg_color=F4F4F5" alt="GithubCard"/></a></div><div class="card mb-15px md:mb-20px overflow-hidden"><a href="https://github.com/Yrobot/mina-touch" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin?repo=mina-touch&amp;username=yrobot&amp;title_color=000000&amp;icon_color=000000&amp;text_color=000000&amp;border_color=F4F4F5&amp;bg_color=F4F4F5" alt="GithubCard"/></a></div><div class="card mb-15px md:mb-20px overflow-hidden"><a href="https://github.com/Yrobot/react-mobile-table" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin?repo=react-mobile-table&amp;username=yrobot&amp;title_color=000000&amp;icon_color=000000&amp;text_color=000000&amp;border_color=F4F4F5&amp;bg_color=F4F4F5" alt="GithubCard"/></a></div><div class="card mb-15px md:mb-20px overflow-hidden"><a href="https://github.com/Yrobot/mina-popups" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin?repo=mina-popups&amp;username=yrobot&amp;title_color=000000&amp;icon_color=000000&amp;text_color=000000&amp;border_color=F4F4F5&amp;bg_color=F4F4F5" alt="GithubCard"/></a></div><div class="mb-20px"><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div id="vcomments"></div></div></div></div></div><footer class="bg-accent-1"></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"typePosts":[{"title":"All","list":[{"path":"_blogs/SPA/前端路由.md","title":"前端路由","author":"yrobot","keywords":"路由,前端","createTime":1572537600000,"createTimeStr":"2019年11月01日","length":1893,"content":"\u003ca id='top'\u003e\u003c/a\u003e\n\n# 前端路由 \n\u003ca href=\"#top\" style=\"position: fixed;font-size: 30px;color: rgb(88, 153, 226);right: 10px;bottom: 20px;z-index: 999;\"\u003eTOP\u003c/a\u003e\n\n__本页目录：__   \n[前世今生](#compare)  \n[前端路由需要做什么](#what)    \n[没有路由系统的SPA的弊端](#bad)    \n[前端路由的实现](#cometrue) \n\n\n\u003ca id='compare'\u003e\u003c/a\u003e\n\n## 前世今生    \n\n很久以前，一个web网站，是由很多html组成的，俗称多页面。  \n前端对于每个路由实现一个html，并将html部署到服务器作为对应路由的返回内容，这样host/a 就返回a.html,host/b 就返回b.html，修改请求url，服务器返回对应html并展示，实现项目间页面的跳转。  \n可以看出，这样的模式，前端实现很麻烦（要多写很多html，大部分内容还都是重复的，比如tabBar），部署还需要运维支持，对每个路由url请求进行对应html的配置。  \n \n然后，SPA（single page application）诞生了。  \n单页面应用，很直白的表示了，这个应用只有一个页面。而原本不同页面的内容通过修改这个页面的展示组件去操控。  \n但是SPA有个很大的问题，就是怎么控制应用展示那个页面。  \n于是乎，前端路由横空出世。  \n\n\u003ca id='what'\u003e\u003c/a\u003e\n\n## 前端路由需要做什么    \n\n正如上面说分析的，  \n前端路由最重要的就是告诉SPA应该展示什么页面，但是又不能触发后端请求。  \n简而言之  \n前端路由的核心： __改变页面视图的同时不会向后端发出请求__\n\n\u003ca id='bad'\u003e\u003c/a\u003e\n\n## 没有路由系统的SPA的弊端    \n\n1. 用户在使用过程中，url 不会发生变化，那么用户在进行多次跳转之后，如果一不小心刷新了页面，又会回到最开始的状态，用户体验极差。\n2. 由于缺乏路由，不利于 SEO（搜索引擎优化），搜索引擎进行收录。\n\n\u003ca id='cometrue'\u003e\u003c/a\u003e\n\n## 前端路由的实现    \n\n### hash路由\n__原理__：  \nurl 上的 hash 以 # 开头，原本是为了作为锚点，方便用户在文章导航到相应的位置。因为 hash 值的改变不会引起页面的刷新，于是就想到用 hash 值来做单页面应用的路由。当 url 的 hash 发生变化的时候，可以触发相应 hashchange 回调函数来控制页面内容的更新。  \n\n__优势：__  \n1. 用 hash 在做路由跳转的好处在于简单实用，便于理解  \n\n__缺点：__   \n1. url 却引入 # 号，不够美观。  \n2. 在一些调用三方登陆服务时，传回的url参数位置在#前的问题从而引起读不到hash参数的问题  \n\n### History路由\n__原理：__  \n基于 HTML5 规范，在 HTML5 规范中提供了 history.pushState、history.replaceState 来进行展示路由控制，并且不触发页面刷新和请求。  \n那么我们只要利用history API更新展示的url，同时手动更新页面内容，从而实现路由的功能。  \n而对于首次打开，只需在路由constructor里读取path并更新页面内容即可。  \n\n__pushState逻辑：__  \n假设在 `http://mozilla.org/foo.html` 中执行了以下 JavaScript 代码:\n```\nlet stateObj = {\n    foo: \"bar\",\n};\nhistory.pushState(stateObj, \"page 2\", \"bar.html\");\n```\n这将使浏览器地址栏显示为 `http://mozilla.org/bar.html` ，但并不会导致浏览器加载 bar.html ，甚至不会检查bar.html 是否存在。  \n\n__优势：__  \n1. url简洁美观  \n\n__缺点：__  \n1. 刷新时，会用对应路由url请求服务器，如果服务器不做处理，就会报404\n\n\n"},{"path":"_blogs/JS/JS模块化/README.md","title":"JS模块化","author":"yrobot","keywords":"JS,模块化","createTime":1571068800000,"createTimeStr":"2019年10月15日","length":5233,"content":"\u003ca id='top'\u003e\u003c/a\u003e\n\n# JS模块化  \n\u003ca href=\"#top\" style=\"position: fixed;font-size: 30px;color: rgb(88, 153, 226);right: 10px;bottom: 20px;z-index: 999;\"\u003eTOP\u003c/a\u003e\n\n__本页目录：__   \n[前言](#pre)  \n[无模块化](#none)  \n[CommonJS规范](#commonjs)  \n[AMD规范](#AMD)  \n[CMD规范](#CMD)  \n[ES6模块化](#ES6)  \n[CommonJs和ES6区别](#ES6CMJS)  \n\n__友情连接：__  \nQ：那么新的ES6模块化对我们前端开发有什么意义呢？webpack就没有用了嘛？  \nA：[探讨ESM对当前开发的意义或影响](../探讨ESM对当前开发的意义或影响/README.md)\n\n\u003ca id='pre'\u003e\u003c/a\u003e\n\n## 前言  \n其实一直以来我在前端开发中都会用到模块化的相关知识，但是我总是一知半解的。  \n而且目前完善的构建工具让我无需深入的了解前端模块的知识（用就得了，莽就行了）。  \n但是有一天，我的后端室友发给我了一篇 [《愿未来没有 Webpack》](https://juejin.im/post/5d4bcdb7e51d453b386a62c6)\n\n读完我不禁陷入了沉思。。。  \n不知道是什么时候开始接收了webpack作为前端开发必备工具这件事了。  \n而为什么要用webpack这件事，却从来没有问过自己。  \n而文中提到的[@pika/web](https://github.com/pikapkg/web)，又是一个什么神奇的操作？\n\n经过一段时间的学习理解，发现这原来是JS模块化造成的，总结成一句话就是：  \n`浏览器无法支持commonjs模块化，所以需要打包工具将所有依赖和自写代码打包到一个文件中；而因为浏览器渐渐开始原生支持ESM，所以只要将commonjs规范转换成ESM规范，就可以直接在浏览器中静态引用了`  \n\n所以在这探索的过程中，就不得不好好学习JS模块化的知识，本文就是对JS模块的一个学习总结 \n\nby the way, 以下讲的是一些规范（用于模块化的理论而已），具体实现参看具体实现框架/库  \n\n\n\u003ca id='none'\u003e\u003c/a\u003e\n\n## 无模块化  \n表现形式：\n```\n    \u003cscript src=\"jquery.js\"\u003e\u003c/script\u003e\n    \u003cscript src=\"main.js\"\u003e\u003c/script\u003e\n    \u003cscript src=\"other.js\"\u003e\u003c/script\u003e\n```\n直接在html中利用script标签引入js文件，并按照引入顺序一个一个执行，每个js都是用window全局作用域  \n\n#### 无模块化的问题：\n1. 文件有依赖关系时，被依赖的文件必须在依赖文件前利用script标签引入并执行\n2. js引入文件声明的全局变量等会 __污染全局作用域__ ，如果两个文件的全局变量重名，还会出现报错（甚至出现因为变量共用导致逻辑出错而发现不了的问题）\n3. 维护时， __模块之间的依赖关系隐蔽__ ，直接通过全局变量使用，而不是声明式的\n\n\u003ca id='commonjs'\u003e\u003c/a\u003e\n\n## CommonJS规范  \n表现形式：\n```\n    // utils.js (导出)\n    const log = s=\u003e{ console.log(s) };\n    module.exports={ log };  //exports 是对 module.exports 的引用,注意js对象引用使用（直接对exports赋值无法修改module.exports）\n\n    ------------------文件分割线-----------------\n\n    // index.js\n    const {log} = require('./utils.js');\n    log(\"you see see you\");\n```\n\n#### commonjs解决：  \n1. 声明依赖关系：利用exports和require声明暴露和引入，将模块的依赖关系展示出来\n2. 可避免全局作用域的变量污染：打包完的模块代码在新的函数作用域中，所以可以避免同名变量的全局污染。\nPS：由于js遇到未声明变量的赋值操作会将该变量将被自动作为全局变量声明([点击此查看](https://www.iteye.com/blog/huangqiqing123-1788646))，使用严格模式可以避免这种情况的发生\n\n#### commonjs弊端：  \n1. 当然最主要的弊端是浏览器并不原生支持commonjs模块化  \n2. 对于网上说的网络问题造成的模块引入慢，其实任何模块规范遇到网上模块引入到会有这个问题（从请求到执行很慢，多引用就多请求），所以也不算commonjs的弊端啦  \n\n#### 那么现在前端是怎么用commonjs的呢？：  \n目前前端使用commonjs的路子是：使用webpack等打包工具，在开发时可进使用commonjs，开发完成利用模块化工具会将模块的依赖关系进行梳理优化并将依赖打包到同一个文件中，这样就没有引用的问题了，以这种曲线救国的方法让开发可以使用commonjs进行模块引用。  \n \n这点可以参看webpack的[demo](https://webpack.toobug.net/zh-cn/chapter2/commonjs.html)  \n![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z1up3quqj30b60aumxq.jpg)   \n打包生成文件  \n![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z1vvc9tfj30np0z00xq.jpg)  \n\nps：这也是造成当前前端难以离开webpack等打包工具的尴尬现状的原因之一，但由于es6有了自己的模块导出和引入方法，而且目前浏览器对es6支持很好，所以@pika/web等依赖安装工具出现了。  \n\n回到最开始的问题，@pika/web依赖安装工具做了什么事： \n1. 将commonjs导出的依赖模块进行打包，打包成一个js，并用es6导出语法进行导出  \n2. 将所有生成模块js放入web_modules中  \n而我们就可以直接在js中根据路径引用这些依赖，只要在html中引入根script时加上type=\"module\"属性即可（告知浏览器这是个模块js）    \n\n\n\u003ca id='AMD'\u003e\u003c/a\u003e\n\n## AMD规范  \n非同步加载模块:Asynchronous module definition  \n所以AMD的优势就是可以异步加载模块  \n\nAMD 是 RequireJS 在推广过程中对模块定义的规范化产出   \n\nAMD标准中，定义了下面三个API：   \n1. require([module], callback)  \n2. define(id, [depends], callback)  \n3. require.config()  \n即通过define来定义一个模块，然后使用require来加载一个模块, 使用require.config()指定引用路径。  \n\n使用时在html引入\u003cscript data-main=\"./alert\" src=\"./require.js\"\u003e\u003c/script\u003e，data-main指定根js文件（原理就是遍历script标签，利用dom的getAttribute函数获取标签属性）  \n\nrequire.js实现原理参考：https://www.jianshu.com/p/5a39535909e4  \n\n__关键逻辑__   \n根据执行文件中的引用将对应模块文件利用dom操作将script标签加入html执行，然后将返回的方法进行保存，在使用的时候返回缓存的依赖方法  \n\n\n#### AMD优点：  \n1. 相比传统script标签引入，AMD依赖无需考虑引入顺序，依赖关系也清晰多了  \n2. 采用异步加载，a加载不阻塞页面渲染，b不阻塞下文js执行（用到模块的代码必须放到回调函数里）  \n\n\n\u003ca id='CMD'\u003e\u003c/a\u003e\n\n## CMD规范  \n通用模块定义：Common Module Definition   \nCMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS  \n\nCMD推崇就近依赖，不像AMD在一开始就指明依赖，CMD只有在用到某个模块的时候再去require  \n这样，CMD就可以通过逻辑判断，避免用不到的模块的加载了  \n\n#### CMD优势： \n1. 相比AMD，可以在执行到引入模块的代码时才去加载模块（即按需加载，提升性能） \n\n#### CMD弊端： \n1. 内部引入，依赖关系就不像commonjs和AMD那样明显了\n\n\u003ca id='ES6'\u003e\u003c/a\u003e\n\n## ES6模块化  \n通过 `exprot` 关键字导出模块，使用 `import` 关键字引入模块  \n```\n    // utils.js (导出)\n    const log = s=\u003e{ console.log(s) };\n    export { log }; \n\n    ------------------文件分割线-----------------\n\n    // index.js\n    import { log } from './utils.js'\n    log(\"you see see you\");\n```\n根脚本script标签要添加 type=module 属性来标记来告诉浏览器用es6模块来引入这个脚本  \n\n兼容就浏览器的方法：  \n```\n    \u003cscript type=\"module\" src=\"app.js\"\u003e\u003c/script\u003e\n    \u003cscript nomodule src=\"fallback.js\"\u003e\u003c/script\u003e\n```\n新版浏览器加载第一个 script 标签，忽略第二个；旧版不支持 type=module 的浏览器则忽略第一个，加载第二个。\n\n#### note： \n1. 脚本加载方式默认为 defer，不会因为执行拥塞页面渲染，也支持 async  \n2. 同一模块（url相同，包括后缀参数）用es6引入方法多次引入只执行一次  \n3. 添加type=module的script标签CORS 跨域限制会更严格，如果服务器未返回有效的 Allow-Origin 相关 CORS 头，浏览器会禁止加载改脚本 \n\n#### es6模块化的优势： \n1. 当然当然当然是浏览器的原生支持啦，大部分浏览器以及支持es6模块化语法，查看[can i use](https://caniuse.com/#feat=es6-module)  \n2. 使用es6模块引入的js脚本不会像普通脚本一样污染全局作用域（根层变量不会被声明到window中)  \n\n\n\u003ca id='ES6CMJS'\u003e\u003c/a\u003e\n\n## CommonJs和ES6区别  \n1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用  \n    commonjs在输出时一般这么操作  \n    ```\n    module.exports = {\n      counter: counter1,\n      incCounter: incCounter,\n    };\n    ```\n    module.exposrts.counter是非引用变量赋值来的，所以值和counter1是分离的。  \n    可以使用函数获取来动态获取最新的counter1值  \n    ```\n    module.exports = {\n      get counter() {\n        return counter1\n      },\n      incCounter: incCounter,\n    };\n    ```\n2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口\n\n"},{"path":"_blogs/JS/探讨ESM对当前开发的意义或影响/README.md","title":"探讨ESM对当前开发的意义或影响","author":"yrobot","keywords":"ESM,探讨,意义,当前,开发,影响","createTime":1571068800000,"createTimeStr":"2019年10月15日","length":1634,"content":"\u003ca id='top'\u003e\u003c/a\u003e\n\n# 探讨ESM对当前开发的意义或影响  \n\u003ca href=\"#top\" style=\"position: fixed;font-size: 30px;color: rgb(88, 153, 226);right: 10px;bottom: 20px;z-index: 999;\"\u003eTOP\u003c/a\u003e\n\n__本页目录：__   \n[对比当前模块开发和ES6模块化开发](#compare)  \n[ESM init 优化方案](#ESMinit)  \n[总的来说](#All)  \n\n__友情连接：__  \nQ：浏览器遇到多个script资源的时候是怎么做的呢？  \nA：[浏览器是怎么处理多个defer或async的script的](../浏览器是怎么处理多个defer或async的script的/README.md)\n\n\u003ca id='compare'\u003e\u003c/a\u003e\n\n## 对比当前模块开发和ES6模块化开发  \n#### 开发方式对比  \n- commonjs的模块化流程：  \n  - 利用commonjs的模块规范进行引入使用，而npm大部分包也是用的commonjs规范写的。前端为了解决浏览器不支持commonjs模块，利用webpack等打包工具，将模块打包到一个js文件中，最后引入html。\n\n- es6模块化开发流程：  \n  - 保证所有依赖支持es6的模块化规范，在html利用type=“module”来引入根js（cdn的js只能使用script引入）\n\n#### 资源加载对比  \n- commonjs的模块化：  \n  - 原来的js文件被整合到一个js文件中，请求网页时，对于这些js只需发送一个script请求即可，只是这个js文件比较大。\n\n- es6模块化开发：  \n  - 对于es6模块，浏览器解析到`\u003cscript type=\"module\" src=\"..\"/\u003e`时，因为type=\"module\"的script默认defer，所以页面会继续解析渲染不受js下载执行阻塞，但是对于依赖，浏览器只能在解析js的步骤中获取依赖然后进行请求下载，依赖下载运行后才能继续执行。\n\n\n\u003ca id='ESMinit'\u003e\u003c/a\u003e\n\n## ESM init 优化方案   \n- 当然通过服务器在请求页面时主动将依赖js一起传给浏览器来直接减少请求数量，但是这就需要服务器知道项目依赖关系，这超出了一些静态文件服务器的职能范围了。  \n- 或者服务器将依赖关系网传给浏览器，让浏览器解析当前需要的js依赖，一次性向服务器请求完，而且因为http1.1的keep alivia的存在会让项目init js的时间比单纯原生请求要少去 __1.一步步解析js获取依赖再请求依赖的时间__ 以及 __2.浏览器多次和服务器tcp连接的时间__，但是需要维护依赖关系网作为牺牲。\n\n\u003ca id='All'\u003e\u003c/a\u003e\n\n## 总的来说  \n1. 对于一些大项目，势必会用到打包工具进行优化（代码压缩，label，eslint），然而es6原生模块支持即使在良好的关系网维护以及浏览器预解析关系网并预加载依赖的最好情况下，加载时间也不比commonjs打包成一整个js文件快多少。但是维护依赖关系网这件事也并不轻松。所以大项目使用ESM的意义目前来看并不是很大。  \n2. 但是对于一些小项目，总共js依赖文件没多少的那种，使用webpack这种臃肿的大包工具并不会对项目起到多大的优化作用，那么何尝不试试直接使用ESM，开发静态网页的快感谁试谁知道，所以出现了将commonjs模块标准转换成ESM的工具[@pika/web](https://github.com/pikapkg/web)。\n\n"},{"path":"_blogs/JS/浏览器是怎么处理多个defer或async的script的/README.md","title":"浏览器是怎么处理多个defer或async的script的","author":"yrobot","keywords":"async,script,defer,浏览器,多个,处理","createTime":1571068800000,"createTimeStr":"2019年10月15日","length":538,"content":"\u003ca id='top'\u003e\u003c/a\u003e\n\n# 浏览器是怎么处理多个defer或async的script的  \n\u003ca href=\"#top\" style=\"position: fixed;font-size: 30px;color: rgb(88, 153, 226);right: 10px;bottom: 20px;z-index: 999;\"\u003eTOP\u003c/a\u003e\n\n1. 浏览器下载资源可以并行，但是有上限，不同浏览器的上限不同，但都是在8以内。具体参考：http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/\n\n2. 浏览器对于同一服务器下的资源可以利用HTTP/1.1的Keep alive，保持tcp层的连接，下个请求就无需再经过tcp连接，减少通信耗时，提高了同一服务器下资源的下载效率。\n\n3. 对于不同地址的资源浏览器还是得通过并行资源请求，而因为并行下载线程数量被控制在个位数，所以多个不同地的script势必会造成script下载的拥塞。\n\n"},{"path":"_blogs/HTML\u0026CSS/css层叠上下文/README.md","title":"css层叠上下文","author":"yrobot","keywords":"css,层叠,上下文","createTime":1568649600000,"createTimeStr":"2019年09月17日","length":1515,"content":"# css层叠上下文 \n__本页目录：__   \n[元素之间有重叠，浏览器要怎么展示呢](#question)  \n[怎么确定元素层叠关系](#how)  \n[层叠上下文](#sxw)  \n[层叠顺序](#xdsx)  \n[实操一下看](#doit)  \n\n\u003ca id='question'\u003e\u003c/a\u003e\n\n## 元素之间有重叠，浏览器要怎么展示呢\n\n  当我们在编写html+css时，常常会遇到元素覆盖的问题，那解释器是怎么解释元素的覆盖的呢？  \n\n  - 首先我们比确定的是，相邻的普通元素，都是后者覆盖前者的  \n\n  但是对于相对较远的元素，拥有其他css属性（例如z-index）的属性呢？  \n\n  - emmmm，z-index值越大就越靠上？？ \n  - nono，解释器不是这么简单粗暴的  \n  - 下面我们就来探讨一下 层叠上下文 对元素 层叠关系的影响   \n\n\n\u003ca id='how'\u003e\u003c/a\u003e\n\n## 怎么确定元素层叠关系\n\n前端页面元素的覆盖关系由 __所属的层叠上下文__ 和 __元素本身的层叠顺序__ 决定  \n\n先看层叠上下文，再看层叠顺序  \n\n\u003ca id='sxw'\u003e\u003c/a\u003e\n\n## 层叠上下文  \n\n1. 层叠上下文是页面元素的一种属性，页面由普通元素组成，一些元素因为种种原因而带有了层叠上下文  \n\n2. 产生层叠上下文的种种原因：  \n    1. 页面根元素html天生具有层叠上下文，称之为“根层叠上下文”\n    2. 普通元素满足以下条件时具有层叠上下文：a.position值非static  b.z-index值非auto\n    3. CSS3中的新属性也可以产生层叠上下文\n\n3. 所有元素的层叠关系都是相对于 最近父层叠上下文元素 来说的   \n\n\u003ca id='xdsx'\u003e\u003c/a\u003e\n\n## 层叠顺序  \n\n1. 层叠关系要在同一个层叠上下文中比较，两元素不在同一个层叠上下文则向上寻找，直到同一个层叠上下文，比较 `最开始包含自己的层叠上下文（若有）|| 元素本身`   \n2. 当将两者提升到同一个层叠上下文后，根据下图层叠顺序图来判断层叠关系 \n\n\n逻辑图如下：  \n![](https://tva1.sinaimg.cn/large/006y8mN6ly1g72kli5irwj30hg08pmyl.jpg)\n\n\n\n\u003ca id='doit'\u003e\u003c/a\u003e\n\n## 实操一下看  \n\n![](https://tva1.sinaimg.cn/large/006y8mN6ly1g72kpdobofj30x70guacd.jpg)  \n* 建议判断层叠关系时，都在脑海中画一下上图虚拟DOM树  \n\n比较下以下几个元素的覆盖关系：  \nB5-C3  \nB2-B5  \nC1-C2  \nC3-B5  \nC1-B1   \n\n根据[怎么确定元素层叠关系](#how)，先看层叠上下文，再看层叠顺序  \n\n1. 看层叠上下文  \n```\nB5-C3 =\u003e A4-A3   \nB2-B5 =\u003e B2-A4   \nC1-C2 =\u003e A1-B3   \nC3-B5 =\u003e B4-B5   \nC1-B1 =\u003e C1-B1   \n```\n2. 再根据[层叠顺序](#xdsx)的规则去判断元素的层叠关系吧！！！\n\n\n"},{"path":"_blogs/计算机网络/计网体系结构.md","title":"计网体系结构 - OSI、TCP/IP、五层协议体系","author":"yrobot","keywords":"计网,OSI,TCP,IP,五层协议体系,体系结构","createTime":1538755200000,"createTimeStr":"2018年10月06日","length":4502,"content":"\n# 计网体系结构 - OSI、TCP/IP、五层协议体系  \n  \n\n\n__本页目录：__   \n[简而言之](#inall)  \n[OSI 的体系结构](#osi)  \n[TCP/IP 的结构体系](#tcpip)  \n[五层体系结构](#five)  \n\n\u003ca id='inall'\u003e\u003c/a\u003e\n\n## 简而言之\n总的来说，计网结构体系分成三种：  \n1. OSI 的体系结构\n2. TCP/IP 的结构体系\n3. [五层体系结构](#five) [着重学习]\n\n`OSI的体系结构` 是由国际标准化组织ISO提出的一种标准框架，他有7层体系，但是由于 1.OSI缺乏商业驱动 2.协议较复杂，运行效率低   3.OSI层次划分不合理，功能出现重复。\b导致OSI止步于理论层面。  \n\n`TCP/IP的结构体系` 是由于OSI的复杂不实用，TCP/IP就应运而生了，他在ISO发表之前就出现了。TCP/IP只有4层体系，并且得到了市场的肯定。  \n\n`五层体系结构` 是因为OSI概念清除体系完整，而TCP/IP更具实用价值，所以我们学习的时候会学习较为折中的 五层协议的体系结构。\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fvygqapt6bj30g108yti3.jpg)\n\n| OSI参考层编号 | 等效的OSI层      | 五层协议体系 | TCP/IP协议体系 | TCP/IP协议示例                                                                       |\n| ------------- | ---------------- | ------------ | -------------- | ------------------------------------------------------------------------------------ |\n| 7、6、5       | 应用、表示、会话 | 应用         | 应用层         | HTTP、HTTPS、NFS、NIS、DNS、LDAP、telnet、ftp、rlogin、rsh、rcp、RIP、RDISC、SNMP 等 |\n| 4             | 传输             | 传输         | 运输层         | TCP、UDP、SCTP                                                                       |\n| 3             | 网络             | 网络         | 网际层IP       | IPv4、IPv6、ARP、ICMP                                                                |\n| 2             | 数据链路         | 数据链路     | 网络接口层     | PPP、IEEE 802.2                                                                      |\n| 1             | 物理             | 物理网络     | 网络接口层     | 以太网 (IEEE 802.3)、令牌环、RS-232、FDDI 等等                                       |\n\u003ca id='osi'\u003e\u003c/a\u003e\n\n## OSI 的体系结构\nOSI体系结构，意为开放式系统互联。  \n国际标准组织（国际标准化组织）制定了OSI模型。这个模型把网络通信的工作分为7层  \n分别是 `物理层, 数据链路层, 网络层, 传输层, 会话层, 表示层 和 应用层`。  \n\n__OSI体系从上到下解析：__  \n\n1. 应用层（Application Layer）提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。\n\n2. 表达层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。\n\n3. 会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。\n\n4. 传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。\n\n5. 网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据。例如:互联网协议（IP）等。\n\n6. 数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。  \n分为两个子层：逻辑链路控制（logic link control，LLC）子层和介质访问控制（media access control，MAC）子层。\n\n7. 物理层（Physical Layer）在局部局域网上传送数据帧（data frame），它负责管理计算机通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器等。\n\n\u003ca id='tcpip'\u003e\u003c/a\u003e\n\n## TCP/IP 的结构体系\n__1. 本机内TCP/IP体系结构展示：__  \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fvzspp8fp6j30d9073n1n.jpg)  \n   \n__2. 网络间TCP/IP体系结构展示：__  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvytqvroucj30fu09045j.jpg)  \n\n\u003ca id='from5'\u003e\u003c/a\u003e  \n\n__3. TCP/IP 体系\b从上到下解析__  \n1. __应用层：__\n应用层是体系结构中的最高层，它直接为用户的应用程序提供服务，在因特网中应用层的协议很多，如支持万维网应用的http协议，支持电邮的smtp协议，支持文件传输的ftp协议等等。  \n我们将应用层交互的数据单元称为 __报文__。 \n\n2. __运输层：__ 它为两个主机中的进程间提供通用的传输服务。主要有复用(向下传)和分用(向上传)两个功能。  \n    运输层主要使用以下两种协议：TCP和UDP   \n    - TCP：_Transmission Contol Protocol_，传输控制协议，面向连接的，数据传输的单位是报文段，能够提供可靠地交付。  \n    - UDP：_User Datagram Protocol_，用户数据报协议，无连接的，数据传输的单位是用户数据报，不保证提供可靠地交付。\n\n3. __网络层：__\n    负责为分组交换网上的不同主机提供通信服务。  \n    (作用1)在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。  \n    在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，简称数据报。  \n    (作用2)网络层的另一个任务就是要选择合适的路由，  \n    使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。  \n\n4. __网络接口层：__ 对于TCP/IP结构体系，的这一层主要包含 五层协议 的数据链路层和物理层    \n    - 数据链路层：  \n    链路层将网络层交下来的IP数据报组装成帧，在两个相邻结点之间的链路上透明地传送帧中的数据。控制端在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。控制信息还使得接收端能够检测到所收到的帧中有无差错。如果发现有差错，数据链路层就简单地丢弃这个出错的帧，以免传下去白白浪费网络资源。如果需要改正错误，就由运输层的TCP协议来完成。(数据信息的确认交给更高层的网络层或者应用层实现)\n\n    - 物理层：在物理层上所传数据的单位是比特。物理层的任务就是透明地传送比特流。\n\n\u003ca id='five'\u003e\u003c/a\u003e\n\n## 五层体系结构\n五层体系结构主要是将TCP/IP体系拆分成5层，便于学习：  \n1. __应用层__：应用层定义的是 应用间通信和交互的规则，如HTTP、FTP等\n   \n2. __运输层__：它为两个主机中的进程间提供通用的传输服务。主要有复用(向下传)和分用(向上传)两个功能。运输方式分为TCP、UDP两种协议\n3. __网络层__：为运输层的数据包选择合适的路由协议(TCP/IP中用的是IP协议)，地址解析 和 路由 是网络层的重要目的。\n4. __数据链路层__：数据链路层在不可靠的物理介质上提供可靠的传输。作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。\n5. __物理层__：物理层主要负责 数据 和 物理信号 之间的互相转换。(比如0和1转换为电信号分别用几伏表示传输)\n\n具体每层的内容参看[TCP/IP 体系\b从上到下解析](#from5)  \n\n五层体系结构的数据传输 __图解__ ：  \n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fw0ndnh4hzj30rs0d4qiu.jpg)\n\n"},{"path":"_blogs/微信小程序/小程序的分享与传参.md","title":"小程序的分享与传参","author":"yrobot","keywords":"小程序,传参,分享","createTime":1538236800000,"createTimeStr":"2018年09月30日","length":5569,"content":"\n# 小程序的分享与传参  \n  \n\n\n\n\n__本页目录：__   \n[事先说明](#before)  \n[分享方法概括](#share)  \n\n分享传参\n- [利用URL参数](#url)  \n- [二维码传参](#qrcode)  \n- [shareTicket](#st)  \n- [剪切板传参](#cb)  \n  \n[分享的注意点](#note)  \n\n\u003ca id='before'\u003e\u003c/a\u003e\n\n## 事先说明\n首先要说的就是   \n微信仗着自己的生态圈日益完善，随随便便就可以废弃或者改动API`(比如这次的分享回调函数)`  \n所以本文只能做到说，对于目前`2018年09月30日`这个时间结点，我所做的总结是没有问题的   \n\n再说一下做本次总结的初衷，或者是出发点  \n\n最近要负责一个信用卡的小程序项目  \n我主要负责的就是项目的前端开发  \n那么一系列关于分享的问题就来了  \n- 什么这个页面能不能生成链接放群里啊\n- 小程序能不能分享到朋友圈啊\n- 分享对接到个人，进而引入任务机制啊\n- 能不能查看每个人发展了几个新用户啊\n- 朋友圈分享加入参数怎么实现啊\n- 巴拉巴拉\n  \n呼~  \n\n索性做一次比较系统的总结吧  \n看你们谁敢再提一些xx的需求  \n\n\u003ca id='share'\u003e\u003c/a\u003e\n\n## 分享方法概括\n1. 利用page生命周期onShareAppMessage()\n2. 基于\b二维码图片进行分享\n3. 通过剪切板分享   \n   \n\n### 1. 利用page生命周期onShareAppMessage()\n只有设置了onShareAppMessage()函数  \n点击小程序右上角才会有分享选项  \nbutton方式的分享才会成功  \n\n具体API使用参考[官网-页面事件处理函数](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0)\n\n__优点：__  \n这个方法好的地方就是可以直接分享给用户和群  \n用户点击链接直接跳转小程序  \n非常方便，转化率也高  \n\n__缺点：__  \n不支持以链接形式分享到朋友圈  \n\n### 2. \b基于\b二维码图片进行分享\n生成小程序二维码需要获取access_token  \n然后利用[官方的接口](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/qr-code.html)去获取二维码  \n接口返回数据为二维码的二进制数据  \n\n__需要注意的是：__  \n官方的接口有3个  \n但是1、3的接口生成个数总和不得超过100000，但参数长度够长  \n2接口不限制总个数，生成频率也很大，但是2号接口的参数整体不得多于32个可见字符  \n这需要开发的取舍，或者进行适当的转换了  \n\n__优点：__  \n方法各种场景通用，可以对用户、对朋友圈、甚至支持以其他媒体介质传播  \n\n__缺点：__  \n方法操作复杂，转换率比较低  \n对于老年用户。可能不是很智能  \n参数可能还需要压缩  \n### 3. 通过剪切板分享\n这个方法适用的场景很单一  \n主要是\b各方都在用小程序的情况下  \n不是用来推广小程序的  \n而是用来分享具体内容的（前提是都已经在用小程序了） \n\n目前淘宝、支付宝这种方式的分享很多  \n\n__需要注意的是：__\n由于是明文分享，需要做好防修改操作  \n最好就是以签名的方式进行判断  \n\n__优点：__  \n分享途径不受限制   \n分享方法也很简单  \n\n__缺点：__  \n不适用小程序的推广，单纯的内部分享   \n打开小程序后才能被监听  \n\n\u003ca id='url'\u003e\u003c/a\u003e\n\n## 利用URL参数\n#### 方法简述\n就是前段最朴素的传参，在url后添加?name=value的形式，然后利用路由或者小程序自带的方法读取参数   \n#### 方法步骤\n1. 在页面onShareAppMessage()配置返回的url，以path?name=value的形式  \n2. 获取参数：  \n    1. 在Page的onLoad生命周期的参数 `option.参数名` 获取参数值\n    2. 还可以在APP的onLaunch生命周期的参数 `options.query.参数名` 获取\n   \n#### 注意点\n- 关于参数的问题，onShareAppMessage()没有指明是否可以在tab页面的url带参数，但是wx路由API指明只能在跳转非tab页时带参数 。  \n- 必须触发Page的onLoad或者APP的onLaunch才获取的到参数  \n#### 测试结果：\n直接打开：\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fvrmzyjpbkj30v80jignm.jpg)\n从分享链接打开：\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fvrn0kxyohj30ve0m0tax.jpg)\n\u003ca id='qrcode'\u003e\u003c/a\u003e\n\n## 二维码传参\n#### 方法简述\n利用小程序生成二维码的API生成二维码，让用户直接分享二维码  \n\n#### 方法步骤\n1. 利用appID和appSECRET获取access_token\n2. 利用access_token作为参数请求二维码API\n3. 接口返回二维码的二进制数据，处理成url\n4. 利用wx接口下载url并保存\n\n#### 注意点\n官方二维码生成接口有3种方法，具体参考[官方API](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/qr-code.html)      \n三种方式的参数和url，data格式都不一样，具体可以参考[博客链接](https://www.jianshu.com/p/441882c67b6a)   \n\n注意1、3一共只能生成10000个二维码，2的参数长度不能那个超过32个字符   \n接口返回的图片二进制，最好是在服务端储存然后返回链接给前端。   \n\u003ca id='st'\u003e\u003c/a\u003e\n\n## shareTicket\n#### 方法简述\nshareTicket的作用是用来换取 群的openID  \n\n#### 方法步骤\n1. 在showSHareMenu()或者updateShareMenu()中设置shareTicket为true\n2. 将小程序分享到群中\n3. 有用户打开此链接后,即可在App.onLaunch 或 App.onShow 获取到一个 shareTicket\n4. 利用wx.getShareInfo将shareTicket转化成加密数据\n5. 加密数据解密后获得 群openID \n\n#### 注意点\n1. 18年10月10号，微信关闭分享回调函数，所以无法再用户分享会后立刻获得shareTicket\n2. 使用App.onLaunch获取要注意，App.onLaunch只在小程序初始化时触发，即当已经打开小程序，再去群里点击链接，是不会触发App.onLaunch的。推荐使用App.onShow\n#### 代码演示\ndemo7.js:\n```\nonShareAppMessage: function (res) {\n    return {\n        title: 'Yrobot test share',\n        path: 'pages/demo7/index?shareID=Yrobot7'\n    }\n},\nonShow: function () {\n    // setTimeout(() =\u003e {\n    //     wx.redirectTo({\n    //         url: '../demo5/index'\n    //     }) \n    // }, 6000);\n    wx.showShareMenu({\n        withShareTicket: true,\n    });\n},\n```\nApp.js:\n```\nonShow: options =\u003e {\n    console.log('App.onShow');\n    console.log('shareID: ' + options.query.shareID);\n    wx.getShareInfo({\n      shareTicket: options.shareTicket,\n      success: res =\u003e {\n        console.log('wx.getShareInfo:success:');\n        console.log(res);\n      },\n      fail: res =\u003e {\n        console.log('wx.getShareInfo:fail');\n        console.log(res);\n      }\n    });\n  },\n```\n#### 效果展示\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fvro07yrz1j30ws0m0wsy.jpg)\n\u003ca id='cb'\u003e\u003c/a\u003e\n\n## 剪切板传参\n#### 方法简述\n利用剪切板监听的方式，获取页面和参数   \n功能类似于淘宝、支付宝的分享   \n\n#### 方法内容\n- 利用wx.setClipboardData设置剪切板内容  \n- 利用wx.getClipboardData获取剪切内容  \n- 监听到剪切板时当前小程序的分享字符串时，进行解析、跳转  \n\n#### 注意点\n注意传参的话最好进行加密混淆、否则明码容易被用户手动替换   \n最好就是对整体进行签名，签名认证不一致(用户修改过)就不进行解析   \n\n#### 效果展示：  \n初始进入：  \n    ![](https://ws4.sinaimg.cn/large/006tNc79gy1fvrkc3incyj30gg0ncwfg.jpg)   \n复制指令后进入：  \n    ![](https://ws4.sinaimg.cn/large/006tNc79gy1fvrkbv5lqlj30gm0nc3zb.jpg)   \n\n\n\u003ca id='note'\u003e\u003c/a\u003e\n\n## 分享的注意点 \n由于7月5日微信更新API，减少“强制分享至不同群”等滥用分享能力，将不再支持onShareAppMessage()中获取分享状态(即那三个回调函数)，所以也无法在分享后立刻获得群id，而改为用户打开后利用shareTicket换取群id   \n\n具体参考微信公众平台公告：10月10日起新提交发布的版本，不再支持分享回调参数 success 、fail 、complete\n\n[微信公共平台 - 分享功能调整及小程序组件更新](https://mp.weixin.qq.com/s?__biz=MjM5NDAwMTA2MA==\u0026mid=2695730124\u0026idx=1\u0026sn=666a448b047d657350de7684798f48d3\u0026chksm=83d74a07b4a0c311569a748f4d11a5ebcce3ba8f6bd5a4b3183a4fea0b3442634a1c71d3cdd0\u0026scene=21#wechat_redirect)[时间不准确]  \n[微信公共平台 - 分享功能调整](https://mp.weixin.qq.com/cgi-bin/announce?action=getannouncement\u0026announce_id=11526372695t90Dn\u0026version=\u0026lang=zh_CN)[时间不准确]    \n[微信开放社区 - “分享监听”能力调整](https://developers.weixin.qq.com/community/develop/doc/0000447a5b431807af57249a551408?highLine=%25E5%2588%2586%25E4%25BA%25AB%25E5%259B%259E%25E8%25B0%2583%25E6%2588%2590%25E5%258A%259F)[时间准确]\n\n"},{"path":"_blogs/JS/DOM操作/README.md","title":"DOM操作","author":"yrobot","keywords":"DOM,操作","createTime":1537977600000,"createTimeStr":"2018年09月27日","length":6747,"content":"\u003ca id='top'\u003e\u003c/a\u003e\n# DOM操作  \n\u003ca href=\"#top\" style=\"position: fixed;font-size: 30px;color: rgb(88, 153, 226);right: 10px;bottom: 20px;z-index: 999;\"\u003eTOP\u003c/a\u003e\n\n__本页目录：__   \n[NodeList 和 HTMLCollection](#nh)  \n[获取DOM节点的方法](#get)  \n[生成节点的方法](#create)  \n[DOM操作方法](#action)  \n[关系节点获取](#near)  \n[元素属性设置](#props)  \n[元素样式修改](#style)  \n[获取元素宽高、位置](#position)  \n\n\u003ca id='nh'\u003e\u003c/a\u003e\n\n## NodeList 和 HTMLCollection\n\n#### 共同点：\n  1. 都是类数组对象，都有length属性\n  2. 都有共同的方法：item，可以通过item(index)或者item(id)来访问返回结果中的元素\n  3. 都是实时变动的（live），document上的更改会反映到相关对象上（例外：document.querySelectorAll返回的NodeList不是实时的） \n\n#### 不同点：\n  1. NodeList可以包含任何节点类型（包括换行、元素间的文字），HTMLCollection只包含元素节点（elementNode），elementNode就是HTML中的标签\n  2. HTMLCollection比NodeList多一项方法：namedItem，可以通过传递id或name属性来获取节点信息\n\n\u003ca id='get'\u003e\u003c/a\u003e\n\n## 获取DOM节点的方法\n1. `document.getElementById` ：根据ID查找元素，大小写敏感，如果有多个结果，只返回第一个；只能document调用\n\n2. `DOM.getElementsByClassName` ：根据类名查找元素，多个类名用空格分隔，返回一个 HTMLCollection 。\n3. `DOM.getElementsByTagName` ：根据标签查找元素， * 表示查询所有标签，返回一个 HTMLCollection 。\n4. `document.getElementsByName` ：根据元素的name属性查找，返回一个 NodeList 。只能document调用\n5. `DOM.querySelector` ：返回单个Node，如果匹配到多个结果，只返回第一个。\n6. `DOM.querySelectorAll` ：返回一个 NodeList。不是实时的。\n7. `document.forms` ：获取当前页面所有form，返回一个 HTMLCollection ；\n8. `document.documentElement`：获取html节点\n9.  `document.body`：获取body节点\n\n\u003ca id='create'\u003e\u003c/a\u003e\n\n## 生成节点的方法\n1. `document.createElement(\"p\")`：生成HTML节点元素，参数为节点类型\n\n2. `document.createTextNode(\"text\")`:文本内容（无标签包裹），节点间的文本、节点内的文本\n3. `DOM.cloneNode()`：方法创建节点的拷贝，并返回该副本。\n\n\n\u003ca id='action'\u003e\u003c/a\u003e\n\n## DOM操作方法\n### 添加元素：\n1. `DOM.appendChild(元素)`：在DOM节点末尾添加元素\n2. `parentNode.insertBefore(newNode, refNode)`：在redNode前添加新元素newNode\n3. `DOM.insertAdjacentElement(position,ele)`：在DOM指定位置添加元素\n4. `DOM.insertAdjacentHTML(position, text)`：同上   \n    __position__  \n    A DOMString representing the position relative to the element; must be one of the following strings: 相对于p节点  \n    取值：`'beforebegin'`、`'afterbegin'`、`'beforeend'`、`'afterend'`  \n    ```    \n        \u003c!-- beforebegin --\u003e\n        \u003cp\u003e\n            \u003c!-- afterbegin --\u003e\n            foo\n            \u003c!-- beforeend --\u003e\n        \u003c/p\u003e\n        \u003c!-- afterend --\u003e\n    ```\n    __text__  \n    text is the string to be parsed as HTML or XML and inserted into the tree.例如`'\u003cdiv id=\"two\"\u003etwo\u003c/div\u003e'`  \n    __element__  \n    要插入到树中的元素.  \n\n### 删除元素：\n1. `parentNode.removeChild(node)`：删除parentNode下的node节点，注意是实时更新的，删除时index会时时改变\n    ```\n    function removeNode(node)  \n    {  \n        if(!node) return;  \n        if(node.parentNode) node.parentNode.removeChild(node);  \n    }  \n    ```\n2. `parentNode.replaceChild(newChild, oldChild)`：将oldChild替换为newChild\n\n\u003ca id='near'\u003e\u003c/a\u003e\n\n## 关系节点获取\n1. `parentNode` ：返回元素的父节点。Element的父节点可能是Element，Document或DocumentFragment；\n\n2. `parentElement` ：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element元素，如果不是，则返回null；\n3. `children` ：返回一个实时的 HTMLCollection ，子节点都是Element，IE9以下浏览器不支持；\n4. `childNodes` ：返回一个实时的 NodeList ，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等；\n5. `firstChild` ：返回第一个子节点，不存在返回null，与之相对应的还有一个 firstElementChild ；\n6. `lastChild` ：返回最后一个子节点，不存在返回null，与之相对应的还有一个 lastElementChild ；\n7. `previousSibling` ：返回节点的前一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点。\n8. `nextSibling` ：返回节点的后一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点。\n9.  `previousElementSibling` ：返回前一个element元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。\n10. `nextElementSibling` ：返回后一个element元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。\n\n\n\u003ca id='props'\u003e\u003c/a\u003e\n\n## 元素属性设置\n1. `DOM.setAttribute(name, value)`: name是特性名，value是特性值，如 DOM.setAttribute('name', 'ele');\n\n2. `DOM.getAttribute(name)`: 返回指定的特性名相应的特性值，如果不存在，则返回nul\n3. `DOM.hasAttribute(name)`: 判断DOM是否存在name的属性\n4. `DOM.dataset`: 获取html data-开头的属性\n    ```\n    \u003cdiv id=\"user\" data-id=\"1234567890\" data-user=\"johndoe\" data-date-of-birth\u003eJohn Doe\u003c/div\u003e\n\n    let el = document.querySelector('#user');\n    // el.id == 'user'\n    // el.dataset.id === '1234567890'\n    // el.dataset.user === 'johndoe'\n    // el.dataset.dateOfBirth === ''\n\n    el.dataset.dateOfBirth = '1960-10-03'; // set the DOB.\n    // 'someDataAttr' in el.dataset === false\n\n    el.dataset.someDataAttr = 'mydata';\n    // 'someDataAttr' in el.dataset === true\n    ```\n\n\u003ca id='style'\u003e\u003c/a\u003e\n\n## 元素样式修改\n1. 直接修改元素style样式： _`element.sytle.xxx`只能获取到内联样式_  \n    ```\n    elem.style.color = 'red';    \n    elem.style.setProperty('font-size', '16px');    \n    elem.style.removeProperty('color'); \n    ```  \n2. 动态添加样式规则：  \n    ```\n    var style = document.createElement('style');  \n    style.innerHTML = 'body{color:red} #top:hover{background-color: red;color: white;}';  \n    document.head.appendChild(style);  \n    ```\n3. classList获取样式class  \n    __`DOM.classList.xxx()`:__   \n    - add( String [, String] )  \n    添加指定的类值。如果这些类已经存在于元素的属性中，那么它们将被忽略。\n      \n    - remove( String [,String] )  \n    删除指定的类值。  \n    - item ( Number )  \n    按集合中的索引返回类值。  \n    - toggle ( String [, force] )  \n    当只有一个参数时：切换 class value; 即如果类存在，则删除它并返回false，如果不存在，则添加它并返回true。  \n    当存在第二个参数时：如果第二个参数的计算结果为true，则添加指定的类值，如果计算结果为false，则删除它  \n    - contains( String )  \n    检查元素的类属性中是否存在指定的类值。  \n    - replace( String, String )  \n    用一个新类替换已有类。   \n4. 使用`window.getComputedStyle`： _借助`window.getComputedStyle`可以获取应用到元素上的所有样式_   \n    `let style = window.getComputedStyle(element, [pseudoElt]);`  \n    - element   \n    用于获取计算样式的Element。  \n    - pseudoElt [可选]  \n    指定一个要匹配的伪元素的字符串。必须对普通元素省略（或null）。 \n\n    返回的style是一个实时的 [CSSStyleDeclaration](https://developer.mozilla.org/zh-CN/docs/Web/API/CSSStyleDeclaration) 对象，当元素的样式更改时，它会自动更新本身。   \n    ```\n    let elem = document.getElementById(\"elem-container\");\n    window.getComputedStyle(elem,null).height = '100px';\n    ```\n\n\u003ca id='position'\u003e\u003c/a\u003e\n\n## 获取元素宽高、位置\n1. `getBoundingClientRect()`:  \n    `DOM.getBoundingClientRect()`的属性：\n    | Attribute | Type  | Description                                                   |\n    | --------- | ----- | ------------------------------------------------------------- |\n    | bottom    | float | Y 轴，相对于视口原点（viewport origin）矩形盒子的底部。只读。 |\n    | height    | float | 矩形盒子的高度（等同于 bottom 减 top）。只读。                |\n    | left      | float | X 轴，相对于视口原点（viewport origin）矩形盒子的左侧。只读。 |\n    | right     | float | X 轴，相对于视口原点（viewport origin）矩形盒子的右侧。只读。 |\n    | top       | float | Y 轴，相对于视口原点（viewport origin）矩形盒子的顶部。只读。 |\n    | width     | float | 矩形盒子的宽度（等同于 right 减 left）。只读。                |\n    | x         | float | X 轴，相对于视口原点（viewport origin）矩形盒子的左侧。只读。 |\n    | y         | float | Y 轴，相对于视口原点（viewport origin）矩形盒子的顶部。只读。 |\n    clientRect是一个 DOMRect 对象，包含width、height、left、top、right、bottom，它是相对于窗口顶部而不是文档顶部，__滚动页面时它们的值是会发生变化的__。\n\n1. `DOM.clientWidth`：表示元素的内部宽度，以像素计。盒模型的content+padding\n2. `DOM.offsetLeft`：返回当前元素左上角相对于  HTMLElement.offsetParent (距离元素的最近的父级定位元素) 节点的左边界偏移的像素值。\n3. `DOM.scrollLeft` 属性可以读取或设置元素滚动条到元素左边的距离。\n\n\n"},{"path":"_blogs/SPA/react的状态管理/利用react-redux.md","title":"react的状态管理—利用react-redux","author":"yrobot","keywords":"react,redux,状态管理,利用","createTime":1537632000000,"createTimeStr":"2018年09月23日","length":3707,"content":"# react的状态管理—利用react-redux \n__本页目录：__   \n[场景思考](#index)  \n[利用react-redux](#redux)  \n[查看效果](#result)  \n[查看代码](#code)  \n\n\u003ca id='index'\u003e\u003c/a\u003e\n\n## 场景思考\n现在我们用react去写一篇博客  \n博客包含 `标题` 和 `内容`  \n而我期望`标题`和`内容`的颜色可以一键修改  \n\n当然最暴力的实现方式就是利用dom操作去被动的修改  \n但是有没有更优雅更可控的方式呢？  \n\n首先来看看项目的组件树：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg)\n\n那么有什么好的优雅的方式使`Title`和`Content`的颜色保持一致呢？  \n换句话说，怎么更好的管理`Title`和`Content`的状态呢？ \n\n#### 回顾上一节  \n上一节我们使用react自带的 [\b利用context注入](./利用context注入.md) 方法   \n利用react的context去实现状态共享很方便  \n但是react的context还是实验性的，何时会更新无法预知  \n所以为了保证软件的稳定性，我们还是使用react推荐的第三方状态管理redux   \n\n\u003ca id='redux'\u003e\u003c/a\u003e\n\n## 利用react-redux\nredux 是一套专业解决应用状态管理的独立的通用模块\b  \n它不仅可以和react结合，形成react-redux，也可以和vue、angular结合  \n\n__react-redux的作用：__ 类似于\breact的context，\breact-redux在顶层组件利用Provider将store注入，在需要用到状态的组件处用connect函数包裹，从组件的props中获取store  \n\n__react-redux的使用方法：__  \n1. 根据全局数据，将其拆分为多个`reducer`\n2. 对于每个`reducer`分配`state`（`reducers.reducer`）和`action`，处理对应的`action`操作，生成行的`state`\n3. 将`reducer`合并成`reducers`,`reducers`分配传入的`state`和`action`操作到`reducer` \n4. `createStore()`传入`reducers`生成`store`，并用`Provider`将`store`注入顶层组件\n5. 在要引用`store`的组件部分用`connect()`连接，`connect()`会注册监听、将`dispatch()`[默认写入]和`mapStateToProps`的属性写入`props`，当然如果使用`mapDispatchToProps`生成的`action creator`也会写入`props`。\n6. 在组件中通过`props`获取5中写入`props`的数据即可使用。\n7. 通过`dispatch()`的参数会触发`reducers`的`action`操作，从而更新状态  \n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fvlqv6xb3uj30yu0sagqj.jpg)\n\n__react-redux的优势：__ \n1. 相对于react自带的context，react-redux更加稳定成熟，并对性能进行了优化  \n2. 相对于props的状态提升，react-redux更加的方便简洁，整个全局状态也更加清晰   \n\n__老话说的好，杀鸡焉用牛刀，在简单场景直接使用状态提升即可__  \n\n\u003ca id='result'\u003e\u003c/a\u003e\n\n## 查看效果\n1. \n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fvhmmoieh4j31kw0nxdpk.jpg)\n2. \n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fvhmmukgfyj31kw0o2qcy.jpg)\n\n\n\u003ca id='code'\u003e\u003c/a\u003e\n\n## 查看代码\nreducers.js生成全局状态：  \n```\nimport { combineReducers } from 'redux'\n\nconst mainColor = (state = 'black',action)=\u003e{\n    switch (action.type){\n        case 'CHANGE_COLOR':\n            state = action.color;\n            return state;\n        default:\n            return state;\n    }\n}\n\nexport default combineReducers({\n    mainColor,\n})\n```\n\nBlogPage.js中\b生成store，并利用Provider注入顶层组件：\n```\nimport reducers from './reducers.js'\n\nconst store = createStore(reducers);\n\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n        }\n    }\n    render() {\n        return (\n            \u003cProvider store = {store}\u003e\n                \u003cdiv className =\"blogContainer\"\u003e\n                    \u003cHeader \u003e\u003c/Header\u003e\n                    \u003cMain\u003e\u003c/Main\u003e\n                \u003c/div\u003e\n            \u003c/Provider\u003e\n        );\n    }\n}\n\nexport default BlogPage;\n```\n\nContent.js中利用connect()函数将状态写入组件props：  \n```\nclass Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    render() {\n        const {mainColor,changeMainColor} = this.props;\n        return (\n            \u003cdiv className=\"content\" style={{ color: mainColor }}\u003e\n                内容...\n                \u003cdiv className=\"button\" onClick={() =\u003e { changeMainColor('#' + (Math.random() * 0xffffff \u003c\u003c 0).toString(16)) }}\u003e切换颜色\u003c/div\u003e\n            \u003c/div\u003e\n\n        );\n    }\n}\n\nconst mapStateToProps = state =\u003e ({  //引入状态到props，并注册监听变化\n    mainColor: state.mainColor\n})\n\nconst mapDispatchToProps = dispatch =\u003e ({ //引入方法到props\n    changeMainColor: color =\u003e {\n        dispatch({\n            type:'CHANGE_COLOR',\n            color,\n        })\n    }\n})\n\nexport default connect(  //绑定组件 //高阶组件:函数接受一个组件作为参数，并返回一个新的组件\n    mapStateToProps,\n    mapDispatchToProps\n)(Content);\n```\n\n\n"},{"path":"_blogs/SPA/react的状态管理/利用context注入.md","title":"react的状态管理—利用context注入","author":"yrobot","keywords":"context,状态管理,react,注入,利用","createTime":1537545600000,"createTimeStr":"2018年09月22日","length":3544,"content":"# react的状态管理—利用context注入  \n__本页目录：__   \n[场景思考](#index)  \n[利用context注入](#context)  \n[查看效果](#result)  \n[查看代码](#code)  \n\n\u003ca id='index'\u003e\u003c/a\u003e\n\n## 场景思考\n现在我们用react去写一篇博客  \n博客包含 `标题` 和 `内容`  \n而我期望`标题`和`内容`的颜色可以一键修改  \n\n当然最暴力的实现方式就是利用dom操作去被动的修改  \n但是有没有更优雅更可控的方式呢？  \n\n首先来看看项目的组件树：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg)\n\n那么有什么好的优雅的方式使`Title`和`Content`的颜色保持一致呢？  \n换句话说，怎么更好的管理`Title`和`Content`的状态呢？ \n\n#### 回顾上一节  \n上一节我们使用最基础的[props状态提升](./利用props状态提升.md)的方法   \n但当组件链很长的时候，新增一个状态就必须修改每个组件的props  \n那有没有跟直接的方法，搞一个共享状态，每个组件可以自由访问呢  \nreact自带的context就是用来实现这一点的  \n\n\u003ca id='context'\u003e\u003c/a\u003e\n\n## 利用context注入\nreact的context可以代替props的传递工作  \n\n__context的作用：__ 将顶部\b组件的状态和方法与子组件共享  \n\n__context的使用方法：__  \n1. 利用`React.createContext()`生成一对`{Provider,Consumer}`  \n2. 用生成的`Provider`包裹\b顶部组件，利用他props的value字段传入共享状态与方法  \n   ```\n    \u003cProvider value={{状态和方法}}\u003e\n        \u003c顶层组件\u003e\n    \u003c/Provider\u003e\n   ```\n3. 用生成的`Consumer`包裹使用共享状态的组件，在Consumer内子组件外用函数传入共享的状态  \n   ```\n    \u003cConsumer\u003e\n        {value =\u003e (\n            \u003c子组件 使用value\u003e\n        )}\n    \u003c/Consumer\u003e\n   ```\n4. 保证状态位于顶层组件的`state`中，而共享的方法要更新状态也是利用`setState`，这样UI层才会刷新  \n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fvhm1xim52j30yg0pqads.jpg)\n\n__context的优势：__ \n1. 只需要在顶层组件和用到状态的子组件进行操作，省去了props状态提升中对中间组件的数据传递操作。代码更清晰。   \n2. 无需引入第三方状态管理，学习成本也相对较低  \n\n__尽管context相对于props状态提升方便很多，\b但是react官网还是 _不建议_ 使用context，因为context的API是实验性的，在未来的react版本中会被修改。__  \n\n__在简单场景,推荐使用props状态提升__  \n__在较复杂的场景，应该考虑引入第三方状态管理(如Redux、Mobx)__  \n\n\u003ca id='result'\u003e\u003c/a\u003e\n\n## 查看效果\n1. \n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fvhmmoieh4j31kw0nxdpk.jpg)\n2. \n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fvhmmukgfyj31kw0o2qcy.jpg)\n\n\n\n\u003ca id='code'\u003e\u003c/a\u003e\n\n## 查看代码\nmainColorContext.js暴露React.createContext：  \n```\nimport React from 'react';\n\nexport const mainColorContext = React.createContext(\n    {\n        mainColor:'black'\n    } // 默认值\n);\n```\n\nBlogPage.js中引入mainColorContext，定义全局状态mainColor和方法changeMainColor()并传入Provider： \n```\nimport {mainColorContext} from './mainColorContext.js'\n\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            mainColor: 'black'\n        }\n    }\n    changeMainColor = (color) =\u003e {\n        this.setState({ //this的绑定//运行时//但是箭头函数没有this//直接沿着作用域链往上找找到BlogPage类的this //换成function就不行了，obj.func()会修改this指向为obj\n            mainColor: color\n        })\n    }\n    render() {\n        const { mainColor } = this.state;\n        return (\n            \u003cmainColorContext.Provider value={{mainColor,changeMainColor:this.changeMainColor}}\u003e\n                \u003cdiv className=\"blogContainer\"\u003e\n                    \u003cHeader \u003e\u003c/Header\u003e\n                    \u003cMain\u003e\u003c/Main\u003e\n                \u003c/div\u003e\n            \u003c/mainColorContext.Provider\u003e\n        );\n    }\n}\n```\nContent.js组件中获取使用Consumer传递的数据和方法：\n```\nimport {mainColorContext} from '../../BlogPage/mainColorContext.js'\n\nclass Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    render() {\n        return (\n            \u003cmainColorContext.Consumer\u003e\n                {value =\u003e (\n                    \u003cdiv className=\"content\" style={{ color: value.mainColor }}\u003e\n                        文本...\n                    \u003cdiv className=\"button\" onClick={()=\u003e{value.changeMainColor('#' + (Math.random() * 0xffffff \u003c\u003c 0).toString(16))}}\u003e切换颜色\u003c/div\u003e\n                    \u003c/div\u003e\n                )}\n            \u003c/mainColorContext.Consumer\u003e\n\n        );\n    }\n}\n```\n\n\n"},{"path":"_blogs/SPA/react的状态管理/利用props状态提升.md","title":"react的状态管理—利用props状态提升","author":"yrobot","keywords":"状态管理,props,react,状态,提升,利用","createTime":1537200000000,"createTimeStr":"2018年09月18日","length":2494,"content":"# react的状态管理—利用props状态提升  \n__本页目录：__   \n[场景思考](#index)  \n[利用props状态提升](#props)  \n[查看效果](#result)  \n[查看代码](#code)  \n\n\u003ca id='index'\u003e\u003c/a\u003e\n\n## 场景思考\n现在我们用react去写一篇博客  \n博客包含 `标题` 和 `内容`  \n而我期望`标题`和`内容`的颜色可以一键修改  \n\n当然最暴力的实现方式就是利用dom操作去被动的修改  \n但是有没有更优雅更可控的方式呢？  \n\n首先来看看项目的组件树：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg)\n\n那么有什么好的优雅的方式使`Title`和`Content`的颜色保持一致呢？  \n换句话说，怎么更好的管理`Title`和`Content`的状态呢？  \n\n\n\u003ca id='props'\u003e\u003c/a\u003e\n\n## 利用props状态提升\n学习了react，就知道组件间数据交互最普遍的方式就是利用props传递  \n而目我们要做的就是Title和Content引用的是同一个颜色变量，而且在变量改变时组件自动重新渲染  \n利用react最基础的方法就是利用状态提升:  \n把一些共享的状态放在最顶端的组件中，子组件通过props去访问和修改这些状态  \n\n本场景中需要共享的状态只有一个`mainColor`和一个修改mainColor的函数`changeMainColor()`  \n具体流程如下图：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvexnc4cbcj30ss0poacx.jpg)\n\b可以看到，需要在content和title中用mainColor，需要通过组件props层层传递到需要用状态的组件，函数也是同理  \n\n\u003ca id='result'\u003e\u003c/a\u003e\n\n## 查看效果\n1. \n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fvey3e0sw6j31kw0lmdoe.jpg)\n2. \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvey3n6qu4j31kw0n1aju.jpg)\n3. \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fvey3xqxwpj31kw0nntin.jpg)\n\n\n\u003ca id='code'\u003e\u003c/a\u003e\n\n## 查看代码\n\nBlogPage中定义全局状态mainColor和方法changeMainColor()并传递： \n```\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            mainColor: 'black'\n        }\n    }\n    changeMainColor = (color) =\u003e {\n        this.setState({\n            mainColor: color\n        })\n    }\n    render() {\n        const { mainColor } = this.state;\n        return (\n            \u003cdiv className=\"blogContainer\"\u003e\n                \u003cHeader mainColor={mainColor}\u003e\u003c/Header\u003e\n                \u003cMain mainColor={mainColor} changeMainColor={this.changeMainColor}\u003e\u003c/Main\u003e\n            \u003c/div\u003e\n        );\n    }\n}\n```\nContent组件中使用props传递的数据和方法：\n```\nclass Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    randomColor = () =\u003e {\n        this.props.changeMainColor('#' + (Math.random() * 0xffffff \u003c\u003c 0).toString(16));\n    }\n    render() {\n        const {mainColor}=this.props;\n        return (\n            \u003cdiv className=\"content\" style={{color:mainColor}}\u003e\n                内容...\n                \u003cdiv className=\"button\" onClick={this.randomColor}\u003e切换颜色\u003c/div\u003e\n            \u003c/div\u003e\n        );\n    }\n}\n```\n\n\n--- \n*\b本章节部分参考[React.js 小书](http://huziketang.mangojuice.top/books/react/lesson29)，在此感谢！*\n\n\n"},{"path":"_blogs/HTML\u0026CSS/利用css绘制多边形/README.md","title":"利用css绘制多边形","author":"yrobot","keywords":"css,多边形,绘制,利用","createTime":1535904000000,"createTimeStr":"2018年09月03日","length":7151,"content":"# 利用css绘制多边形  \n本文主要讲解内容：  \n1. css绘制多边形的原理(一定要理解)  \n2. 一些简单多边形的绘制示例  \n\n__本页目录：__   \n[css绘制多边形的原理](#id1)  \n- [首先我们要知道css盒模型是什么样的](#id11)\n- [然后我们还要理解border](#id12)\n- [还要会用css伪元素](#id13)\n\n[css绘制正四边形](#id2)  \n[css绘制非正四边形](#id3)  \n[css绘制三角形](#id4)  \n[css绘制圆形](#id5)  \n[css绘制梯形](#id6)  \n[css绘制正五边形](#id7)  \n[css绘制正七边形](#id8)  \n\n\u003ca id='id1'\u003e\u003c/a\u003e\n\n## css绘制多边形的原理\n\n\u003ca href=\"\" id=\"id11\"\u003e\u003c/a\u003e\n\n### __首先我们要知道css盒模型是什么样的__  \n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuw4xid010j30a809aq38.jpg)  \n所谓的盒模型，可以理解为元素的表现内容，看上图可以发现：  \n```\n盒模型 = 内容 + padding + border + margin    \n```\n组成理解(_简单介绍_ )：  \n`内容` 元素内 文本、内元素 所包含的区域  \n`padding` \b 内容 与 border 之间的距离，用于处理border和内容的表现关系  \n`border`  边框，将内容包围的轮廓  \n`margin`  元素 与 其他元素之间的距离，用于处理元素间的表现关系，位置样式  \n\n一般理解的 元素 由 内容、padding、border 组成，因为这3个影响到元素的表现样式。  \ncss2中`width`的默认指向是内容宽度，而不是元素(包括padding、border)的宽度。  \n\b可以 利用 `box-sizing` 去修改width的指向：  \n- `box-sizing: content-box;` width、height指向内容  \n    ![](https://ws2.sinaimg.cn/large/0069RVTdgy1fuw5olkw8wj303o010mx2.jpg)\n- `box-sizing: border-box;` width、height指向一般元素  \n    ![](https://ws1.sinaimg.cn/large/0069RVTdgy1fuw5p6zb80j305q04wdgb.jpg)\n\n看下结果：_语言:stylus_    \n```\n.boxsize1\n    width 100px\n    height 80px\n    background-color #393\n    border 20px solid #999\n.boxsize2\n    width 100px\n    height 80px\n    background-color #393\n    border 20px solid #999\n    box-sizing border-box  //默认元素宽高指定，内容宽高自适应\n```\n![](https://ws4.sinaimg.cn/large/0069RVTdgy1fuw6rtydjoj30ci0egweo.jpg)  \n\n本章我们就要利用元素的表现样式(内容、padding、border  )进行图形绘制  \n\u003ca href=\"\" id=\"id12\"\u003e\u003c/a\u003e\n\n### __然后我们还要理解border__  \n我们先来看一段有趣的代码：  \n```\n.square1 {\n  width: 0px;\n  height: 0px;\n  border-width: 40px 50px;\n  border-style: solid;\n  border-color: #f00 #008000 #808080 #00f;\n}\n```\n想想一下，这段代码的渲染效果是什么样的?  \ncss是怎么处理border重叠的部分的？ \n好了，想清楚了，就来看一下结果吧。  \n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuw65nqy85j309001u0sr.jpg)  \n![](https://ws4.sinaimg.cn/large/0069RVTdgy1fuw60spn4lj306i05g0sm.jpg)  \n他的盒模型：  \n![](https://ws4.sinaimg.cn/large/0069RVTdgy1fuw62e6752j307y05umxa.jpg)  \n可以得出规律：\n1. border的长 = 盒模型对应的长或宽  \n2. 相邻方向border冲突时，进行等比均分。 \n\n在接下来的很多例子中都会用到border的这个规律  \n\u003ca href=\"\" id=\"id13\"\u003e\u003c/a\u003e\n\n### __还要会用css伪元素__ \n__css的伪元素：__ 之所以被称为伪元素，是因为他们不是真正的页面元素，html没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的css样式，表面上看上去貌似是页面的某些元素来展现，实际上是css样式展现的行为，因此被称为伪元素。   \n\n我们在绘制图形发现需要进行元素组装时，就可以利用伪元素 来减少对HTML元素的使用。 \n \n[css伪元素的用法](https://www.cnblogs.com/wonyun/p/5807191.html)\n\n\u003ca id='id2'\u003e\u003c/a\u003e\n\n## css绘制正四边形\n绘制正四边形最简单的方法就是利用内容，直接使用width、height  \n```\n.square2 {\n  width: 80px;\n  height: 80px;\n  background-color: #393;\n}\n```\n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuw6wmpdi1j309w092q31.jpg)\n\n当然利用border也可以  \n```\n.square3 {\n  width: 0px;\n  height: 0px;\n  border-width: 40px;\n  border-style: solid;\n  border-color: #008000;\n}\n```\n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuw6ypx233j30a208s74d.jpg)\n\n\u003ca id='id3'\u003e\u003c/a\u003e\n\n## css绘制非正四边形\n#### 绘制平行四边形  \n平行四边形利用[css3的倾斜函数skew()](/CSS3/CSS3-2D转换/README.md#14)比较方便  \n```\n.parallelogram {\n  width: 100px;\n  height: 80px;\n  background: #393;\n  -webkit-transform: skew(-30deg);\n  -moz-transform: skew(-30deg);\n  -o-transform: skew(-30deg);\n  transform: skew(-30deg);\n}\n```\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fuw79w9e6dj30bk08cweo.jpg)   \n\n当然使用 `border` + `:after`伪类也是可以的  \n```\n.parallelogram2 {\n  width: 0px;\n  height: 0px;\n  border-bottom: 80px solid #393;\n  border-left: 80px solid transparent;\n}\n.parallelogram2:after {\n  display: block;\n  content: '';\n  width: 0px;\n  height: 0px;\n  border-top: 80px solid #393;\n  border-right: 80px solid transparent;\n}\n```\n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuw7opf0mhj30bq06qwee.jpg)  \n\n#### 绘制菱形  \n思路：绘制两个等边三角形，进行拼接（`height = sqr(3)*width/2`）\n```\n.rhombus {\n  width: 0px;\n  height: 0px;\n  border-bottom: 69.3px solid #393;\n  border-left: 40px solid transparent;\n  border-right: 40px solid transparent;\n}\n.rhombus:after {\n  display: block;\n  content: '';\n  width: 0px;\n  width: 0px;\n  border-top: 69.3px solid #393;\n  border-left: 40px solid transparent;\n  border-right: 40px solid transparent;\n}\n```\n![](https://ws4.sinaimg.cn/large/0069RVTdgy1fuwb07zx8zj308605o748.jpg)\n\n\u003ca id='id4'\u003e\u003c/a\u003e\n\n## css绘制三角形 \n#### 绘制直角三角形  \n```\n.rightTriangle\n    width 0px\n    height 0px\n    border-bottom 80px solid #393 \n    border-left 80px solid transparent\n```\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fuwcpx6dhfj306s06aa9x.jpg)  \n\n#### 绘制等边三角形  \n等边三角形的宽高比为 1 : sqr(3)/2  \n所以\b可以根据底边长计算三角形高`height = sqr(3)*width/2`  \n本例中左右border宽为40，所以底边长为80，从而计算出底部border宽应为69.3  \n```\n.triangle\n    width 0px\n    height 0px\n    border-bottom 69.3px solid #393 \n    border-left 40px solid transparent\n    border-right 40px solid transparent\n```\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fuwb2kyyzqj306g064746.jpg)\n\n\u003ca id='id5'\u003e\u003c/a\u003e\n\n## css绘制圆形 \n圆形最简单的方式就是设置`border-radius`为50%  \n```\n.circle1\n    width 80px\n    height 80px\n    border-radius 50%\n    background-color #393\n```\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fuwcsqggv5j306c068a9z.jpg)\n\n也可以使用border实现  \n```\n.circle2\n    width 0px\n    height 0px\n    border 40px solid #393 \n    border-radius 50%\n```\n\n\b哎？猜猜这时候设置padding是什么样子的\n```\n.circle3\n    width 0px\n    height 0px\n    border 40px solid #393 \n    border-radius 50%\n    padding 20px\n```\n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuwcyjhdw6j308408874b.jpg)  \n看来border-radius把内外角度都设置了 \n\n\u003ca id='id6'\u003e\u003c/a\u003e\n\n## css绘制梯形 \n```\n.trapezoid\n    width 40px\n    height 0px\n    border-top 40px solid #393 \n    border-left 20px solid transparent\n    border-right 20px solid transparent\n```\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fuwd59x6bsj306w04gwec.jpg)\n\n\u003ca id='id7'\u003e\u003c/a\u003e\n\n## css绘制正五边形 \n正五边形可以拆分成上下两个部分：上边一个等腰三角形，下面一个等腰梯形，具体长宽计算这里不做介绍  \n```\n.pentagon {\n  width: 0px;\n  height: 0px;\n  border-top: 0px;\n  border-right: 81px solid transparent;\n  border-left: 81px solid transparent;\n  border-bottom: 59px solid #393;\n}\n.pentagon:after {\n  position: relative;\n  left: -81px;\n  top: 59px;\n  display: block;\n  content: '';\n  width: 100px;\n  height: 0px;\n  border-top: 95px solid #393;\n  border-left: 31px solid transparent;\n  border-right: 31px solid transparent;\n}\n```\n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuwdlbgoi3j30be0a8t8r.jpg)\n\n\u003ca id='id8'\u003e\u003c/a\u003e\n\n## css绘制正七边形 \n正七边形比较复杂，需要将整个图形分成3份来做  \n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fuwdo5l0qrj307s07974m.jpg)  \n上：等腰三角形  \n中：等腰梯形  \n下：等腰梯形  \n```\n.heptagon {\n  height: 0px;\n  width: 180px;\n  border-left: 22px solid transparent;\n  border-right: 22px solid transparent;\n  border-bottom: 97px solid #393;\n  margin-top: 63px;\n}\n.heptagon:before {\n  display: block;\n  content: '';\n  width: 0px;\n  height: 0px;\n  border-right: 90px solid transparent;\n  border-left: 90px solid transparent;\n  border-bottom: 43px solid #393;\n  position: relative;\n  top: -43px;\n}\n.heptagon:after {\n  width: 100px;\n  height: 0px;\n  content: '';\n  display: block;\n  border-top: 78px solid #393;\n  border-left: 62px solid transparent;\n  border-right: 62px solid transparent;\n  position: relative;\n  left: -22px;\n  bottom: -54px;\n}\n```\n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuwe4xtv6lj30ec0dowen.jpg)\n"},{"path":"_blogs/微信小程序/小程序的运行.md","title":"小程序的运行","author":"yrobot","keywords":"小程序,运行","createTime":1535904000000,"createTimeStr":"2018年09月03日","length":1503,"content":"# 小程序的运行  \n__本页目录：__   \n[小程序的运行环境](#id1)  \n[小程序目录结](#id2)  \n[小程序运行机制](#id3)  \n\n\u003ca id='id1'\u003e\u003c/a\u003e\n\n## 小程序的运行环境\n微信小程序运行在三端：iOS、Android 和 用于调试的开发者工具。\n\n三端的脚本执行环境以及用于渲染非原生组件的环境是各不相同的：\n- 在 iOS 上，小程序的 javascript 代码是运行在 JavaScriptCore 中，是由 WKWebView 来渲染的，环境有 - iOS8、iOS9、iOS10  \n- 在 Android 上，小程序的 javascript 代码是通过 X5 JSCore来解析，是由 X5 基于 Mobile Chrome 53/57 内- 核来渲染的  \n- 在 开发工具上， 小程序的 javascript 代码是运行在 nwjs 中，是由 Chrome Webview 来渲染的  \n\n尽管三端的环境是十分相似的，但是还是有些许区别：  \n1. ES6 语法支持不一致：语法上开发者可以通过开启 ES6 转 ES5 的功能来规避。详情\n2. wxss 渲染表现不一致：尽管可以通过开启样式补全来规避大部分的问题 详情，还是建议开发者需要在 iOS 和 Android 上分别检查小程序的真实表现。\n\n\u003ca id='id2'\u003e\u003c/a\u003e\n\n## 小程序目录结\n```\nproject\n├── pages\n|   ├── index\n|   |   ├── index.json  index 页面配置\n|   |   ├── index.js    index 页面逻辑\n|   |   ├── index.wxml  index 页面结构\n|   |   └── index.wxss  index 页面样式表\n|   └── log\n|       ├── log.json    log 页面配置\n|       ├── log.wxml    log 页面逻辑\n|       ├── log.js      log 页面结构\n|       └── log.wxss    log 页面样式表·\n├── app.js              小程序逻辑\n├── app.json            小程序公共设置\n└── app.wxss            小程序公共样式表\n```\n\n\u003ca id='id3'\u003e\u003c/a\u003e\n\n## 小程序运行机制\n- 小程序没有重启的概念\n- __前台、后台定义：__ 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。\n- 当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁\n- 当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁\n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuwgqm9y1oj30my0bxgmx.jpg)\n\n\n"},{"path":"_blogs/CSS3/CSS3-3D转换/README.md","title":"CSS3-3D转换","author":"yrobot","keywords":"3D,CSS3,转换","createTime":1535644800000,"createTimeStr":"2018年08月31日","length":5674,"content":"# CSS3-3D转换  \n__本页目录：__    \n[3D\b元素的属性](#id1)  \n- [transform](#id11)\n- [transform-origin](#id12)\n- [transform-style](#id13)\n- [perspective](#id14)\n- [perspective-origin](#id15)  \n- [backface-visibility](#id16)  \n\n[3D元素的方法](#id2)  \n\n__CSS3新增的3D变换属性：__  CSS3 3D 转换支持开发者在css代码中利用css3的3D函数，在页面里开发出一些简单的3D效果。  \n\n__本节内容要点：__  \n- 利用transform改变各个元素位置  \n- 利用transition增加动态效果  \n- 利用perspective属性改变视角  \n\n\n\u003ca href=\"\" id=\"id1\"\u003e\u003c/a\u003e\n\n## 3D\b元素的属性\n\u003ca href=\"\" id=\"id11\"\u003e\u003c/a\u003e\n\n1. __transform__：利用一些方法对元素进行2D或者3D转换。具体\b转换方法参看 [3D元素的方法](#id2)    \n   __语法：__ `transform: none|transform-functions;`  \n   - `none` 定义不进行转换。  \n   - `transform-functions` 使用[3D元素的方法](#id2)  \n  \n\u003ca href=\"\" id=\"id12\"\u003e\u003c/a\u003e\n\n2. __transform-origin__：设置元素坐标系原点的位置，影响到2D、3D的旋转效果    \n   __语法：__ `transform-origin: x-axis y-axis z-axis;`      \n   - x-axis\t定义视图被置于 X 轴的何处。可能的值：  \n    _left_  \n    _center_  \n    _right_  \n    _length_  \n    _%_  \n   - y-axis\t定义视图被置于 Y 轴的何处。可能的值：  \n    _top_  \n    _center_  \n    _bottom_  \n    _length_  \n    _%_  \n   - z-axis\t定义视图被置于 Z 轴的何处。可能的值：  \n    _length_\n\n   __示例：__ `-webkit-transform-origin:20% 40%;\t/* Safari 和 Chrome */`   \n\n   __取值对比：__  1.数字和百分比相对于左上角 2.关键字相对于整个元素  \n   ```\n    top = top center = center top = 50% 0  \n    right = right center = center right = 100%或(100% 50%)  \n    bottom = bottom center = center bottom = 50% 100%  \n    left = left center = center left = 0或(0 50%)   \n    center = center center = 50%或（50% 50%）  \n    top left = left top = 0 0  \n    right top = top right = 100% 0  \n    bottom right = right bottom = 100% 100%  \n    bottom left = left bottom = 0 100%  \n   ```\n   __浏览器支持__  \n  ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fut27g9rczj30v806oabn.jpg)\n  Internet Explorer 10、Firefox、Opera 支持 transform-origin 属性。  \n  Internet Explorer 9 支持替代的 -ms-transform-origin 属性（仅适用于 2D 转换）。  \n  Safari 和 Chrome 支持替代的 -webkit-transform-origin 属性（3D 和 2D 转换）。  \n  Opera 只支持 2D 转换。  \n\n\u003ca href=\"\" id=\"id13\"\u003e\u003c/a\u003e   \n\n3. __transform-style__：规定如何在 3D 空间中呈现被嵌套的元素  \n   __语法：__ `transform-style: flat|preserve-3d;`  \b   \n   - `flat`\t所有子元素在 2D 平面呈现。  \n      沿着X轴或Y轴方向旋转该元素将导致位于正或负Z轴位置的子元素显示在该元素的平面上，而不是它的前面或者后面。著作权归作者所有。  \n   - `preserve-3d`\t子元素将保留其 3D 位置。    \n  \n   __示例：__ `-webkit-transform-style: preserve-3d;\t/* Safari 和 Chrome */`  \n  \n   __浏览器支持__  \n  ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fut2ohsc19j30v006mtae.jpg)\n  Firefox 支持 transform-style 属性。  \n  Chrome、Safari 和 Opera 支持替代的 -webkit-transform-style 属性。 \n   \n\u003ca href=\"\" id=\"id14\"\u003e\u003c/a\u003e\n\n4. __perspective__：perspective 属性定义 3D 元素距视图的距离，以像素计。（改变视角距离）  \n   - 提示：请与 perspective-origin 属性一同使用该属性，这样您就能够改变 3D 元素的底部位置。   \n   \n   __语法：__ `perspective: number|none;`  \n   - `number`\t元素距离视图的距离，以像素计。  \n   - `none`\t默认值。与 0 相同。不设置透视。  \n      \n   __示例：__ \n    ```\n    div\n    {\n    perspective: 500;\n    -webkit-perspective: 500; /* Safari 和 Chrome */\n    }\n    ``` \n    __浏览器支持__  \n  目前浏览器都不支持 perspective 属性。  \n  Chrome 和 Safari 支持替代的 -webkit-perspective 属性。  \n   \n\u003ca href=\"\" id=\"id15\"\u003e\u003c/a\u003e\n\n5. __perspective-origin__：改变 3D 元素的底部位置（改变视角的朝向）  \n   __语法：__ `perspective-origin: x-axis y-axis;` 数字和百分比相对于左上角   \n   - x-axis\t定义视图被置于 X 轴的何处。可能的值：  \n    _left_  \n    _center_  \n    _right_  \n    _length_  \n    _%_  \n   - y-axis\t定义视图被置于 Y 轴的何处。可能的值：  \n    _top_  \n    _center_  \n    _bottom_  \n    _length_  \n    _%_  \n\n   __示例：__ \n   ```\n   div\n    {\n    perspective:150;\n    perspective-origin: 10% 10%;\n    -webkit-perspective:150;\t/* Safari 和 Chrome */\n    -webkit-perspective-origin: 10% 10%;\t/* Safari 和 Chrome */\n    }\n   ```\n   __浏览器支持__  \n  目前浏览器都不支持 perspective-origin 属性。  \n  Chrome 和 Safari 支持替代的 -webkit-perspecitve-origin 属性。  \n\n\u003ca href=\"\" id=\"id16\"\u003e\u003c/a\u003e\n\n6. __backface-visibility__：backface-visibility 属性定义当元素不面向屏幕时是否可见。  \n   __语法：__ `backface-visibility 属性定义当元素不面向屏幕时是否可见。`   \n   - `visible`\t背面是可见的。  \n   - `hidden`\t背面是不可见的。  \n\n   __示例：__   \n   ```\n   div\n    {\n    backface-visibility:hidden;\n    -webkit-backface-visibility:hidden;\t/* Chrome 和 Safari */\n    -moz-backface-visibility:hidden; \t/* Firefox */\n    -ms-backface-visibility:hidden; \t/* Internet Explorer */\n    }\n   ```\n   __浏览器支持__   \n  只有 Internet Explorer 10+ 和 Firefox 支持 backface-visibility 属性。  \n  Opera 15+、Safari 和 Chrome 支持替代的 -webkit-backface-visibility 属性。  \n\u003ca id='id2'\u003e\u003c/a\u003e\n\n## 3D元素的方法  \n__语法：__ `transform: none|transform-functions;` 方法使用应该加`transform:`前缀   \n   - `none`\t定义不进行转换。  \n   - `transform-functions`\t3D变换函数。具体函数及功能如下：  \n      - _matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)_\t定义 3D 转换，使用 16 个值的 4x4 矩阵。  \n      - _translate3d(x,y,z)_\t定义 3D 转化。  \n      - _translateX(x)_\t定义 3D 转化，仅使用用于 X 轴的值。  \n      - _translateY(y)_\t定义 3D 转化，仅使用用于 Y 轴的值。  \n      - _translateZ(z)_\t定义 3D 转化，仅使用用于 Z 轴的值。  \n      - _scale3d(x,y,z)_\t定义 3D 缩放转换。  \n      - _scaleX(x)_\t定义 3D 缩放转换，通过给定一个 X 轴的值。  \n      - _scaleY(y)_\t定义 3D 缩放转换，通过给定一个 Y 轴的值。  \n      - _scaleZ(z)_\t定义 3D 缩放转换，通过给定一个 Z 轴的值。  \n      - _rotate3d(x,y,z,angle)_\t定义 3D 旋转。  \n      - _rotateX(angle)_\t定义沿 X 轴的 3D 旋转。  \n      - _rotateY(angle)_\t定义沿 Y 轴的 3D 旋转。  \n      - _rotateZ(angle)_\t定义沿 Z 轴的 3D 旋转。  \n      - _perspective(n)_\t定义 3D 转换元素的透视视图。  \n  \n__示例：__   \n```\ndiv\n{\ntransform:rotate(7deg);\n-ms-transform:rotate(7deg); \t/* IE 9 */\n-moz-transform:rotate(7deg); \t/* Firefox */\n-webkit-transform:rotate(7deg); /* Safari 和 Chrome */\n-o-transform:rotate(7deg); \t/* Opera */\n}\n```\n\n__浏览器支持__   \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuqf7u1vz0j30u204ot9y.jpg)\nInternet Explorer 10、Firefox、Opera 支持 transform 属性。  \nInternet Explorer 9 支持替代的 -ms-transform 属性（仅适用于 2D 转换）。  \nSafari 和 Chrome 支持替代的 -webkit-transform 属性（3D 和 2D 转换）。  \nOpera 只支持 2D 转换。\n\n"},{"path":"_blogs/CSS3/CSS3-2D转换/README.md","title":"CSS3-2D转换","author":"yrobot","keywords":"2D,CSS3,转换","createTime":1535385600000,"createTimeStr":"2018年08月28日","length":2284,"content":"# CSS3-2D转换  \n__本页目录：__    \n[怎么使用](#id1)  \n- [平移函数translate()](#id11)\n- [旋转函数rotate()](#id12)\n- [缩放函数scale()](#id13)\n- [倾斜函数skew()](#id14)\n- [矩阵操作matrix()](#id15)  \n\n[浏览器支持](#id2)  \n\n__CSS3新增的2D变换属性：__   通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。\n\n\u003ca href=\"\" id=\"id1\"\u003e\u003c/a\u003e\n\n## 怎么使用\n\u003ca href=\"\" id=\"id11\"\u003e\u003c/a\u003e\n\n1. __translate()__：设置元素相对于当前的位置。  \n   __语法：__ `transform: translate(length,length);`  \n   - 设置元素基于当前位置向右向下偏移。\b   \n   - `length` 偏离的距离数据。  \n   __示例：__ `transform: translate(50px,100px);`  \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuockbel15j30ai0euwey.jpg) \n\u003ca href=\"\" id=\"id12\"\u003e\u003c/a\u003e\n\n2. __rotate()__：将元素进行顺时针旋转，旋转中心`transform-origin`进行设置，默认为元素中心  \n   __语法：__ `transform: rotate(rot);`     \n   - `rot` 元素顺时针转动的角度数据。   \n   __示例：__ `transform: rotate(30deg);`   \n   ![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuockq1b1rj308i0aggmc.jpg)\n\u003ca href=\"\" id=\"id13\"\u003e\u003c/a\u003e   \n\n3. __scale()__：使用scale方法来实现文字或图像的缩放处理  \n   __语法：__ `transform: scale(times);`  \b   \n   - `times` 数字，表示相对于当前元素缩放的倍数。可以有两个参数，表示长宽。  \n   __示例：__ `transform: scale(0.5, 2);`   \n   ![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuoclaoa1uj30fa0lqjsf.jpg)\n\u003ca href=\"\" id=\"14\"\u003e\u003c/a\u003e\n\n4. __skew()__：使用skew方法来实现文字或图像的倾斜处理，默认坐标中心在元素中心   \n   __语法：__ `transform: skew(rot);`  \n   - 参数中分布指定水平方向上的倾斜角度与垂直方向上的倾斜角度。第一个围绕X轴，第二个围绕Y轴    \n   - `rot` 一方向的倾斜角度。  \n   __示例：__ `transform: skew(30deg, 30deg);`   \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuocmattrhj30880a4jrw.jpg)\n\u003ca href=\"\" id=\"15\"\u003e\u003c/a\u003e\n\n5. __matrix()__：矩阵操作。matrix() 方法可以把所有 2D 转换方法组合在一起  \n   __语法：__ `transform: matrix(a,b,c,d,e,f);`  \n   - 实际上，这6参数，对应的矩阵如下： _注意书写方向是竖着的\b_   \n     ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuoak0zwuhj304302kq2w.jpg)  \n   - 进行运算：  \n     ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuoaq82zpxj30cm02xwep.jpg)  \n     坐标就从[x,y]变成了[ax+cy+e,bx+dy+f]  \n   - 关于为什么要`3*3`的矩阵？   \n     主要是为了统一用矩阵乘的操作，其实平移只需要`2*2`，为了统一利用`3*3`乘法变相实现加法(平移)效果。具体思想参考计算机图形学    \n   __示例：__ `transform: matrix(1, 0, 0, 1, 30, 30);`根据运算，可以得出此矩阵可以将元素向右下平移[30,30]   \n\n\u003ca id='id2'\u003e\u003c/a\u003e\n\n## 浏览器支持\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuo7z8j9byj318s04s3zs.jpg)  \nChrome 和 Safari 需要前缀 -webkit-  \nInternet Explorer 9 需要前缀 -ms-  \n\n"},{"path":"_blogs/CSS3/CSS3动画/README.md","title":"CSS3动画","author":"yrobot","keywords":"CSS3,动画","createTime":1535385600000,"createTimeStr":"2018年08月28日","length":4452,"content":"# CSS3动画  \n__本页目录：__   \n[怎么使用](#id1)  \n- [定义动画](#id11)\n- [引用动画，设定参数](#id12)  \n\n[浏览器支持](#id3)  \n\n__CSS3新增的动画属性：__  通过CSS3动画，我们能够创建动画，这可以在许多网页中取代动画图片、Flash动画 以及 JavaScript。作为页面切换的交互动画。\n\n__NOTE：__  \n1. \b\b一个元素要使用多个动画时（比如前一秒动画1，后面动画2），可以在css属性中用一个animation表示，动画之间用逗号相隔。例子：`animation: animation1 1s, animation2 1s 1s infinite alternate ;`\n\n\u003ca id='id1'\u003e\u003c/a\u003e\n\n## 怎么使用\n首先用我的话来大致概括一下css3动画的使用流程：\n1. 首先定义一个动画，使用`@keyframes`来定义动画(包括动画名、动画过程状态)\n2. 在一个元素的class中引用刚定义的动画，设定相关参数(动画时长、动画线性、动画延迟、元素开始和结束的状态、动画是否暂停\b)    \n\n这样一个css3动画就被定义和使用了。\n\n\u003ca href=\"\" id=\"id11\"\u003e\u003c/a\u003e\n\n#### 1. 定义动画  \n#### __语法：__   \n- `@keyframes`  @keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能作为动画中某一帧的状态。   \n    __示例：__ 规定一个名叫``myAnimation``的动画   \n    ```\n    @keyframes myAnimation\n    {\n    0%   {background: red;}\n    25%  {background: yellow;}\n    50%  {background: blue;}\n    100% {background: green;}\n    }\n\n    @-moz-keyframes myAnimation /* Firefox */\n    {\n    0%   {background: red;}\n    25%  {background: yellow;}\n    50%  {background: blue;}\n    100% {background: green;}\n    }\n\n    @-webkit-keyframes myAnimation /* Safari 和 Chrome */\n    {\n    0%   {background: red;}\n    25%  {background: yellow;}\n    50%  {background: blue;}\n    100% {background: green;}\n    }\n\n    @-o-keyframes myAnimation /* Opera */\n    {\n    0%   {background: red;}\n    25%  {background: yellow;}\n    50%  {background: blue;}\n    100% {background: green;}\n    }\n    ```  \n\n\u003ca href=\"\" id=\"id12\"\u003e\u003c/a\u003e\n\n#### 2. 引用动画，设定参数  \n在要设定动画的元素class上使用  \n#### __语法：__   \n- `animation`\t所有动画属性的简写属性，除了 animation-play-state 和 animation-fill-mode 属性。  \n    __语法：__ `animation: name duration timing-function delay iteration-count direction;`   \n    语法参数含义参看后面的语法解析。   \n    __示例：__ \n    ```\n    div\n    {\n    animation: myAnimation 5s infinite;\n    -webkit-animation: myAnimation 5s infinite; /* Safari 和 Chrome */\n    }\n    ```   \n- `animation-name`\t要引用 @keyframes 动画的名称。  \n    \n- `animation-duration`\t规定动画完成一个周期所花费的秒或毫秒。默认是 0。\n     \n- `animation-timing-function`\t规定动画的速度曲线。默认是 \"ease\"。  \n    __语法：__ `animation-timing-function: value;`     \n    _linear_：\t动画从头到尾的速度是相同的。  \n    _ease_：\t默认。动画以低速开始，然后加快，在结束前变慢。  \n    _ease-in_：\t动画以低速开始。  \n    _ease-out_：\t动画以低速结束。  \n    _ease-in-out_：\t动画以低速开始和结束。  \n    _cubic-bezier(n,n,n,n)_： 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。   \n    __示例：__   \n    ```\n    /* W3C 和 Opera: */\n    #div1 {animation-timing-function: linear;}\n\n    /* Firefox: */\n    #div1 {-moz-animation-timing-function: linear;}\n\n    /* Safari 和 Chrome: */\n    #div1 {-webkit-animation-timing-function: linear;}\n    ```\n- `animation-delay`\t规定动画何时开始。默认是 0。  \n  \n- `animation-iteration-count`\t规定动画被播放的次数。默认是 1。    \n    __语法：__ `animation-iteration-count: value;`       \n    _n_：\t 定义动画播放次数的数值。  \n    _infinite_：\t规定动画应该无限次播放。    \n    __示例：__   \n    ```\n    div\n    {\n    animation-iteration-count: 3;\n    -webkit-animation-iteration-count: 3; /* Safari 和 Chrome */\n    }\n    ```\n- `animation-direction`\t规定动画是否在下一周期逆向地播放。默认是 \"normal\"。  \n    __语法：__ `animation-direction: normal|alternate;`       \n    _normal_：\t默认值。动画应该正常播放。  \n    _alternate_：\t动画应该轮流反向播放。      \n    __示例：__   \n    ```\n    div\n    {\n    animation-direction: alternate;\n    -webkit-animation-direction: alternate; /* Safari 和 Chrome */\n    }\n    ```\n- `animation-play-state`\t规定动画是否正在运行或暂停。默认是 \"running\"。  \n   __语法：__ `animation-play-state: paused|running;`       \n    _paused_： 规定动画已暂停。  \n    _running_：\t规定动画正在播放。       \n    __示例：__   \n    ```\n    div\n    {\n    animation-play-state: paused;\n    -webkit-animation-play-state: paused; /* Safari 和 Chrome */\n    }\n    ```\n- `animation-fill-mode`\t规定对象动画时间之外的状态。     \n   __语法：__ `animation-fill-mode : none | forwards | backwards | both;`       \n    _none_： 不改变默认行为。   \n    _forwards_： 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。  \n    _backwards_： 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。  \n    _both_： 向前和向后填充模式都被应用。         \n    __示例：__   \n    ```\n    div\n    {\n    animation-fill-mode: forwards;\n    -webkit-animation-fill-mode: forwards; /* Safari 和 Chrome */\n    }\n    ``` \n\n#### __效果：__\n[\b参考W3school的demo](http://www.w3school.com.cn/tiy/t.asp?f=css3_animation4)\n\n\u003ca href=\"\" id=\"id3\"\u003e\u003c/a\u003e\n\n## 浏览器支持\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fupd51aiv4j30u209k76w.jpg)  \nInternet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。  \nChrome 和 Safari 需要前缀 -webkit-。\n\n"},{"path":"_blogs/CSS3/CSS3过渡/README.md","title":"CSS3过渡","author":"yrobot","keywords":"CSS3,过渡","createTime":1535385600000,"createTimeStr":"2018年08月28日","length":1599,"content":"# CSS3过渡  \n__本页目录：__   \n[用前思考](#id1)  \n[怎么使用](#id2)  \n[浏览器支持](#id3)  \n\n__CSS3的过渡属性：__  过渡属性可以设定元素在某些属性改变时，对变化过程填充逐渐变换的动画，类似于flash的补间动画\n\n\u003ca id='id1'\u003e\u003c/a\u003e\n\n## 用前思考\nCSS3 过渡是元素从一种样式逐渐改变为另一种的效果  \n那么我们仔细来分析一下，机器需要哪些数据来控制这个补间动画\n首先我们问问自己，如果别人要求我们来实现一种补间动画，我们会问要求人哪些问题呢？\n1. 是对哪些变化进行\b补间动画效果？- what  \n2. 是怎么变的？补间时长、补间线性(渐入渐出|平滑变化) - how  \n3. \b\b补间是马上就开始吗？ - when  \n\n好了，有了这些的问题，看下面的内容也就顺多了。    \n\n\u003ca id='id2'\u003e\u003c/a\u003e\n\n## 怎么使用  \n#### __语法：__   \n- `transition`  简写属性，用于在一个属性中设置下面\b四个过渡属性。   \n    __示例：__   `transition: width 1s linear 2s;`  \n- `transition-property` all/propertys/none  规定应用过渡的 CSS 属性的名称。propertys间用逗号分隔。\n    __示例：__   `transition-property: width,margin;`  \n- `transition-duration` Number 定义过渡效果花费的时间。默认是 0。  \n- `transition-timing-function`  规定过渡效果的时间曲线。默认是 \"ease\"。  \n_linear_ ： 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。  \n_ease_ ： 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。  \n_ease-in_ ： 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。  \n_ease-out_ ： 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。  \n_ease-in-out_ ： 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。  \n_cubic-bezier(n,n,n,n)_ ： 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。  \n- `transition-delay` 规定过渡效果何时开始。默认是 0。     \n\n#### __效果：__\n[\b参考W3school的demo](http://www.w3school.com.cn/tiy/t.asp?f=css3_transition1)\n\n\u003ca id='id3'\u003e\u003c/a\u003e\n\n## 浏览器支持\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fup7uarmc3j30u204sjsn.jpg)  \nInternet Explorer 10、Firefox、Chrome 以及 Opera 支持 transition 属性。  \nSafari 需要前缀 -webkit-。\n\n"},{"path":"_blogs/CSS3/CSS3新增属性/README.md","title":"CSS3新增属性","author":"yrobot","keywords":"CSS3,属性,新增","createTime":1535299200000,"createTimeStr":"2018年08月27日","length":11420,"content":"# CSS3新增属性  \n__本页目录：__   \n[CSS3 边框](#id1)  \n[CSS3 背景](#id2)  \n[CSS3 文本效果](#id3)  \n[CSS3 字体](#id4)  \n[CSS3 2D 转换](#id5)  \n[CSS3 3D 转换](#id6)  \n[CSS3 过渡](#id7)  \n[CSS3 动画](#id8)  \n[CSS3 多列](#id9)  \n[CSS3 用户界面](#id10)  \n\n本文框架主要参考[W3school的CSS教程](http://www.w3school.com.cn/css3/index.asp)，在此感谢!\n\n\u003ca id='id1'\u003e\u003c/a\u003e\n\n## CSS3 边框\n__CSS3新增的边框属性：__  \n1. __border-radius__：设置元素的圆角，还支持单个圆角设置，`border-top(bottom)-left(right)-radius`。  \n   __语法：__ `border-radius: 1-4 length|% / 1-4 length|%;`  \n   - 按此顺序设置每个 radii 的四个值(类似margin属性设置，\b对边相同可简写)。\b   \n   - `ength` 定义圆角的形状。    \n   - `%` 以百分比定义圆角的形状。  \n   __示例：__ `border-radius:2em;`  \n   __示例：__ `border-radius: 2em 1em 4em 3em;`  \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuocgpiov7j30hg0380su.jpg)  \n2. __box-shadow__：设置元素方框阴影  \n   __语法：__`box-shadow: h-shadow v-shadow blur spread color inset;`   \n   - `h-shadow` 必需。水平阴影的位置。允许负值    \t\n   - `v-shadow` 必需。垂直阴影的位置。允许负值    \n   - `blur` 可选。模糊距离    \n   - `spread` 可选。阴影的尺寸     \n   - `color` 可选。阴影的颜色   \n   - `inset` 可选。将外部阴影 (outset) 改为内部阴影   \n   __示例：__ `box-shadow: 10px 10px 5px #888888;`   \n   ![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuoch950z7j30j007kglk.jpg)  \n3. __border-image__：设置元素的边框为图片   \n   __语法：__   border-image 属性是一个简写属性   \n   - `border-image-source` 用在边框的图片的路径。\t  \n   - `border-image-slice` 图片边框向内偏移。\t  \n   - `border-image-width` 图片边框的宽度。\t  \n   - `border-image-outset` 边框图像区域超出边框的量。\t  \n   - `border-image-repeat` 图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。    \n   __示例：__   `border-image: url(/i/border_image_button.png) 0 14 0 14 stretch;`  \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuochr5fydj30lo04i0tb.jpg)\n\n__浏览器支持：__\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuo2czkkuaj318w0eidkx.jpg)\n\n\u003ca id='id2'\u003e\u003c/a\u003e\n\n## CSS3 背景\n__CSS3新增的背景属性：__  \n1. __background-size__:  规定背景图像的尺寸  \n   __语法：__   `background-size: length|percentage|cover|contain; `  \n   - `length` 设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 \"auto\"。     \n   - `percentage` 以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 \"auto\"。   \n   - __`cover`__ 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。  \n   - __`contain`__ 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。     \n   __示例：__   `border-radius:50%;`  \n2. __background-origin__:  background-origin 属性规定 background-position 属性相对于什么位置来定位  \n   __语法：__   `background-origin: padding-box|border-box|content-box; `    \n   - `padding-box` 背景图像相对于内边距框来定位。\t  \n   - `border-box` 背景图像相对于边框盒来定位。 \t  \n   - `content-box` 背景图像相对于内容框来定位。\t  \n   __示例：__   `background-origin:content-box;`\n\n__浏览器支持：__\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuo7a1mn2mj318w09q77m.jpg)\n\n\u003ca id='id3'\u003e\u003c/a\u003e\n\n## CSS3 文本效果\n__CSS3新增的文本效果属性：__  \n1. __text-shadow__:  text-shadow 属性向文本设置阴影   \n   __语法：__   `text-shadow: h-shadow v-shadow blur color;`  \n   - `h-shadow`\t必需。水平阴影的位置。允许负值。  \n   - `v-shadow`\t必需。垂直阴影的位置。允许负值。   \n   - `blur`\t可选。模糊的距离。  \n   - `color` 可选。阴影的颜色。  \n   __示例：__   `text-shadow:2px 2px 8px #FF0000;`  \n   ![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuocifrqvpj30eo03odgz.jpg)\n2. __word-wrap__:  word-wrap 属性允许长单词或 URL 地址换行到下一行  \n   __语法：__   `word-wrap: normal|break-word;`  \n   - `normal` 只在允许的断字点换行（浏览器保持默认处理）。 \n   - `break-word` 在长单词或 URL 地址内部进行换行。   \n   __示例：__   `word-wrap:break-word;`  \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuocjavfcdj313y0mogpb.jpg)\n\n__浏览器支持：__\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuo7ays4aaj318s09iada.jpg)\n\n\u003ca id='id4'\u003e\u003c/a\u003e\n\n## CSS3 字体\n__CSS3新增的字体属性：__  \n1. __@font-face__:  它允许网页开发者为其网页指定在线字体,便于在后面font-family中调用   \n   __语法：__   \n   ```\n    @font-face {\n    [ font-family: \u003cfamily-name\u003e; ] ||\n    [ src: [ \u003curl\u003e [ format(\u003cstring\u003e#) ]? | \u003cfont-face-name\u003e ]#; ] ||\n    [ unicode-range: \u003curange\u003e#; ] ||\n    [ font-variant: \u003cfont-variant\u003e; ] ||\n    [ font-feature-settings: normal | \u003cfeature-tag-value\u003e#; ] ||\n    [ font-variation-settings: normal | [ \u003cstring\u003e \u003cnumber\u003e] # ||\n    [ font-stretch: \u003cfont-stretch\u003e; ] ||\n    [ font-weight: \u003cweight\u003e; ] ||\n    [ font-style: \u003cstyle\u003e; ]\n    }\n   ```\n   - `font-family` name 必需。规定字体的名称。  \n   - `src` URL 必需。定义字体文件的 URL。  \n   - `font-stretch`  可选。定义如何拉伸字体。默认是 \"normal\"。  \n        normal  \n        condensed  \n        ultra-condensed  \n        extra-condensed  \n        semi-condensed  \n        expanded  \n        semi-expanded  \n        extra-expanded  \n        ultra-expanded  \n   - `font-style`\t可选。定义字体的样式。默认是 \"normal\"。  \n        ormal  \n        italic  \n        oblique  \n   - `font-weight` 可选。定义字体的粗细。默认是 \"normal\"。  \n        normal  \n        bold  \n        100  \n        200  \n        300  \n        400  \n        500  \n        600  \n        700  \n        800  \n        900  \n   - `unicode-range` unicode-range 可选。定义字体支持的 UNICODE 字符范围。默认是 \"U+0-10FFFF\"。    \n   __示例：__   \n   ```\n    @font-face {\n        font-family: \"Bitstream Vera Serif Bold\";\n        src: url(\"http://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf\");\n        }\n    \n    body { font-family: \"Bitstream Vera Serif Bold\", serif }\n   ``` \n\n__浏览器支持：__\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuo7ituu00j318q04odhc.jpg)\n\n\n\u003ca id='id5'\u003e\u003c/a\u003e\n\n## CSS3 2D 转换\n__CSS3新增的2D变换属性：__   通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。\n\n跳转 [CSS3-2D转换/RAEDME.md](../CSS3-2D转换/README.md)\n\n__浏览器支持：__\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuo7z8j9byj318s04s3zs.jpg)  \nChrome 和 Safari 需要前缀 -webkit-  \nInternet Explorer 9 需要前缀 -ms-  \n\n\u003ca id='id6'\u003e\u003c/a\u003e\n\n## CSS3 3D 转换\n__CSS3新增的3D变换属性：__  CSS3 3D 转换支持开发者在css代码中利用css3的3D函数，在页面里开发出一些简单的3D效果。  \n\n跳转 [CSS3-3D转换/RAEDME.md](../CSS3-3D转换/README.md)\n\n__浏览器支持：__\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuqf7u1vz0j30u204ot9y.jpg)\nInternet Explorer 10 和 Firefox 支持 3D 转换。  \nChrome 和 Safari 需要前缀 -webkit-。  \nOpera 仍然不支持 3D 转换（它只支持 2D 转换）。\n\n\u003ca id='id7'\u003e\u003c/a\u003e\n\n## CSS3 过渡\n__CSS3的过渡属性：__  过渡属性可以设定元素在某些属性改变时，对变化过程填充逐渐变换的动画，类似于flash的补间动画  \n\n跳转 [CSS3过渡/RAEDME.md](../CSS3过渡/README.md)\n\n__浏览器支持：__\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fup7uarmc3j30u204sjsn.jpg)\n\n\u003ca id='id8'\u003e\u003c/a\u003e\n\n## CSS3 动画\n__CSS3新增的动画属性：__  通过CSS3动画，我们能够创建动画，这可以在许多网页中取代动画图片、Flash动画 以及 JavaScript。作为页面切换的交互动画。  \n\n跳转 [CSS3动画/RAEDME.md](../CSS3动画/README.md)\n\n__浏览器支持：__\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fupd51aiv4j30u209k76w.jpg)  \nInternet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。  \nChrome 和 Safari 需要前缀 -webkit-。\n\n\n\u003ca id='id9'\u003e\u003c/a\u003e\n\n## CSS3 多列\n__CSS3新增的多列属性：__ 使用css3多列属性，可以将内容\b分成几列，类似报纸中文章的形式。   \n1. __column-count__: 规定元素应该被分隔的列数。  \n   __语法：__   `column-count: number|auto;`  \n   - `number` 元素内容将被划分的最佳列数。   \n   - `auto` 由其他属性决定列数，比如 \"column-width\"。      \n   __示例：__   \n   ```\n    div\n    {\n    -moz-column-count: 3; /* Firefox */\n    -webkit-column-count: 3; /* Safari 和 Chrome */\n    column-count: 3;\n    }\n   ``` \n   ![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuqrbczw9jj30x80d679n.jpg)\n\n2. __column-fill__: 规定如何填充列。  \n   __语法：__   `column-fill: balance|auto;`  \n   - `balance` 对列进行协调。浏览器应对列长度的差异进行最小化处理。   \n   - `auto` 按顺序对列进行填充，列长度会各有不同。      \n   __示例：__   \n   ```\n    div\n    {\n    column-fill:auto;\n    }\n   ``` \n\n3. __column-gap__: 规定列之间的间隔。  \n   __语法：__   `column-gap: length|normal;`  \n   - `length` 把列间的间隔设置为指定的长度。   \n   - `normal` 规定列间间隔为一个常规的间隔。W3C 建议的值是 1em。      \n   __示例：__   \n   ```\n    div\n    {\n    -moz-column-gap:40px; /* Firefox */\n    -webkit-column-gap:40px; /* Safari 和 Chrome */\n    column-gap:40px;\n    }\n   ``` \n   ![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuqrjcfhi9j30xi08wdiy.jpg)\n   \n4. __column-rule__: 设置所有 column-rule-* 属性的简写属性。包括 列之间 的 颜色、样式、宽度    \n   __语法：__   `column-rule: column-rule-width column-rule-style column-rule-color;`  \n   - __`column-rule-width`__\t设置列之间的宽度规则。 \n        - __语法：__   `column-rule-width: thin|medium|thick|length;`   \n        - `thin`\t定义纤细规则。  \n        - `medium`\t定义中等规则。  \n        - `thick`\t定义宽厚规则。    \n        - `length`\t规定规则的宽度。\n   - __`column-rule-style`__\t设置列之间的样式规则。  \n        - __语法：__   `column-rule-style: none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset;`   \n        - `none`\t定义没有规则。\t  \n        - `hidden`\t定义隐藏规则。\t  \n        - `dotted`\t定义点状规则。\t  \n        - `dashed`\t定义虚线规则。\t  \n        - `solid`\t定义实线规则。\t  \n        - `double`\t定义双线规则。\t  \n        - `groove`\t定义 3D grooved 规则。该效果取决于宽度和颜色值。\t  \n        - `ridge`\t定义 3D ridged 规则。该效果取决于宽度和颜色值。\t  \n        - `inset`\t定义 3D inset 规则。该效果取决于宽度和颜色值。\t  \n        - `outset`\t定义 3D outset 规则。该效果取决于宽度和颜色值。\t  \n\n   - __`column-rule-color`__\t设置列之间的颜色规则。   \n        - __语法：__   `column-rule-color: color;`   \n        - `color`\t规定颜色规则。请参阅 [CSS 颜色值](http://www.w3school.com.cn/cssref/css_colors_legal.asp)。  \n  \n   __示例：__   \n   ```\n    div\n    {\n    -moz-column-rule:3px outset #ff0000;\t/* Firefox */\n    -webkit-column-rule:3px outset #ff0000;\t/* Safari and Chrome */\n    column-rule:3px outset #ff0000;\n    }\n   ``` \n   ![](https://ws2.sinaimg.cn/large/006tNbRwgy1fusmomdnszj30xg09mgpn.jpg)\n   \n__浏览器支持：__\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuqqzk5gl6j30u20eewi4.jpg) \nInternet Explorer 10 和 Opera 支持多列属性。  \nFirefox 需要前缀 -moz-。  \nChrome 和 Safari 需要前缀 -webkit-。  \n\n\u003ca id='id10'\u003e\u003c/a\u003e\n\n## CSS3 用户界面\n__CSS3新增的用户界面属性：__ 利用css3的用户界面属性，可以重设元素尺寸、盒尺寸以及轮廓等。  \n\n__先看所有的用户界面属性__   \n- `appearance`\t允许您将元素设置为标准用户界面元素的外观  \n- `box-sizing`\t允许您以确切的方式定义适应某个区域的具体内容。  \n- `icon`\t为创作者提供使用图标化等价物来设置元素样式的能力。  \n- `nav-down`\t规定在使用 arrow-down 导航键时向何处导航。  \n- `nav-index`\t设置元素的 tab 键控制次序。\t  \n- `nav-left`\t规定在使用 arrow-left 导航键时向何处导航。\t  \n- `nav-right`\t规定在使用 arrow-right 导航键时向何处导航。\t  \n- `nav-up`\t规定在使用 arrow-up 导航键时向何处导航。\t  \n- `outline-offset`\t对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。\t  \n- `resize`\t规定是否可由用户对元素的尺寸进行调整。\t  \n\n__\b我这边简单介绍一下 浏览器支持比较好的 几个属性__  \n1. __box-sizing__: 改变css 的 width、height 在盒模型中的指向。  \n   - 因为css默认width指向的是盒模型的内容宽度(图中蓝色部分)，而 整个盒模型的宽度 = padding + border + 内容width，整个盒模型所占据文本流的位置还要包括其margin值。  \n   - 而一般我们所想的，我们设置的width值，应该是 整个\b盒模型的宽度，所以问题就产生了。  \n   - 那么这个`box-sizing`，就是用来解决\bwidth、height 在盒模型中的指向问题的。  \n   ![](https://ws4.sinaimg.cn/large/006tNbRwgy1fusoa0l7n5j30ak0aa74j.jpg)  \n\n   __语法：__   `box-sizing: content-box|border-box|inherit;`  \n   - `content-box` 默认，CSS2.1 规定的宽度高度行为。将width、height指向内容宽度，padding、border不被包括在内。  \n    _width、height指向如下图：_  \n    ![](https://ws3.sinaimg.cn/large/006tNbRwgy1fusob65rl6j30au0aeaam.jpg) \n   - `border-box` width指向 内容宽度+padding+border，内容宽度根据减法自适应。height同理。  \n    _width、height指向如下图：_  \n    ![](https://ws2.sinaimg.cn/large/006tNbRwgy1fusob3mmr2j30au0aeq3i.jpg)\n   - `inherit`   继承 父元素 box-sizing属性的值。  \n   \n   __示例：__   \n   ```\n    div\n    {\n    box-sizing:border-box;\n    -moz-box-sizing:border-box; /* Firefox */\n    -webkit-box-sizing:border-box; /* Safari */\n    }\n   ``` \n   __浏览器支持：__\n    ![](https://ws4.sinaimg.cn/large/006tNbRwgy1fusofkoju7j30vc06oabn.jpg)\n    Internet Explorer、Opera 以及 Chrome 支持 box-sizing 属性。  \n    Firefox 支持替代的 -moz-box-sizing 属性。   \n\n2. __outline-offset__: 此属性对轮廓进行偏移。  \n   __语法：__   `outline-offset: length|inherit;`  \n   - `length`\t轮廓与边框边缘的距离。  \n   - `inherit`\t规定应从父元素继承 outline-offset 属性的值。  \n   \n   __示例：__   \n   ```\n    div\n    {\n    border:2px solid black;\n    outline:2px solid red;\n    outline-offset:15px;\n    }\n   ```  \n   __使用对比：__ _后者为使用了`outline-offset:15px;`_   \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuson2ha9gj30ck07mwev.jpg)\n   ![](https://ws2.sinaimg.cn/large/006tNbRwgy1fusomvlpg6j30cs08ajrs.jpg)  \n   __浏览器支持：__   \n    所有主流浏览器都支持 outline-offset 属性，除了 Internet Explorer。  \n\n__\b其余几个属性只有小部分浏览器支持__   \n[__参看所有转换属性的使用__](http://www.w3school.com.cn/css3/css3_user_interface.asp)  \n\n\n"},{"path":"_blogs/HTML\u0026CSS/HTML的meta标签/Meta标签—Viewport/README.md","title":"Meta标签—Viewport","author":"yrobot","keywords":"Meta,Viewport,标签","createTime":1535126400000,"createTimeStr":"2018年08月25日","length":4561,"content":"# Meta标签—Viewport  \n__本页目录：__   \n[Viewport概念](#id1)  \n[看下效果](#id2)  \n[关于缩放](#id3)  \n[布局视口的大小](#id4)  \n[javascript相关](#id5)  \n[总结](#id6)  \n\n\u003ca id='id1'\u003e\u003c/a\u003e\n\n## Viewport概念  \n\n#### 三个视口\n\n1. 布局视口  \n   - 本文的重点，meta属性设置的对象。\n   - 布局视口 可以理解为\b\b\b包含整个页面的区域，所以布局视口可能比可视区域还要大。\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fun61b567vj317g0wan4b.jpg)\n1. 视觉视口\n   - 视觉视口 是用户正在看到的网站的区域。用户可以通过缩放来操作视觉视口，同时不会影响布局视口，布局视口仍保持原来的宽度。\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fun62jqutdj317c0w8gsh.jpg)\n\u003ca href=\"\" id=\"ideal-viewport\"\u003e\u003c/a\u003e\n3. 理想视口\n   - 移动端浏览器还有一个理想视口的概念。其宽度就是\b下文提到的 __理想视口宽度__\n   - 布局视口的默认宽度并不是一个理想的宽度，大家从上面的图就可以看出来了，所以苹果公司就引进了理想窗口这个概念。\n   - 理想视口就是\b最理想的布局视口的尺寸。将布局视口设置成理想视口，页面就能够适应到合适的尺寸，用户就不再需要自己去缩放和拖动网页了。\n   - 在\b移动端，只有布局视口和理想视口一样大时，移动端显示在和PC预期一样，否则浏览器会缩放(不是修改布局视口，而是将整个内容缩小或放大)，以适应移动端显示。从而导致了移动端字体过小等问题。\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fun6qqa0xrj30my04s3z4.jpg)\n  \n### __以下viewport默认指的是布局视口__  \n- 通俗的讲，viewport就是html的\b外层区域，在使用百分比布局时，html设置width：100%就是根据viewport宽度来的，所以viewport可以\b理解为html的父素。\n\u003ca href=\"\" id=\"default\"\u003e\u003c/a\u003e\n\n#### 默认viewport的宽度\n- 下图列出了一些设备上浏览器的默认viewport的宽度。\n- 要注意的是在PC浏览器中，布局视口和视觉视口是相同的，布局视口默认视口宽度会被覆盖。\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fun4nndiqkj30r304caar.jpg)\n\u003ca href=\"\" id=\"initial-scale\"\u003e\u003c/a\u003e\n\n#### initial-scale\n- 而viewport还有一个initial-scale的概念，这个initial-scale是一个数值，用于记录 [理想视口宽度](#ideal-viewport) / viewport宽度 的值。即 initial-scale = 理想视口宽度 / viewport宽度 。\n- 而每个设备的 理想视口宽度 又是固定的，所以通过设置initial-scale就可确定viewport的值。以下是一些设备 理想视口宽度 的\b值：\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fun4n9lduzj30pw04cgme.jpg)\n\n\u003ca id='id2'\u003e\u003c/a\u003e\n\n## 看下效果  \n#### 代码：\n```\n\u003cbody\u003e\n    \u003cp class=\"title\"\u003eMy Title\u003c/p\u003e\n    \u003cp class=\"content\"\u003eApple documentation: Using the Viewport Meta Tag\n        Mozilla: Using the viewport meta tag to control layout on mobile browsers\n        quirksmode.org: A tale of two viewports\n        w3.org Mobile Web Application Best Practices: Use Meta Viewport Element To Identify Desired Screen Size\n        Quick Tip: Never use maximum-scale=1.0 on the A11y Project\n        Tim Kadlec explains IE10 Snap Mode and Responsive Design\n        The @viewport rule proposal\u003c/p\u003e\n\u003c/body\u003e\n```\n#### PC端Chrome显示效果：\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fum93ooxmzj31720j6q7b.jpg)\n- width：775px\n#### 移动端不加meta的Viewport标签：\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fum9642gi8j30ie0fgdil.jpg)\n- width：980px（iPhone6的[viewport的默认宽度](#default)为980px）\n#### 移动端加meta的Viewport标签：\n- head添加\b标签\b：`\u003cmeta name=\"viewport\" content=\"initial-scale=1.0\"\u003e`\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fum9bgbjjgj30ig0so78a.jpg)\n- width：375px (iphone6设备的 理想视口宽度 为375px，所以`viewport = 375px / 1`, 参考[initial-scale](#initial-scale))\n#### 差别\n- 使用了`initial-scale=1.0`之后，浏览器的viewport从默认的980px变为\b理想视口宽度375px的1：1关系的宽度375px\n- \b设置`initial-scale=2.0`后viewport变为`375px/2=187px`\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fumb1i32fjj30i60gimy4.jpg)\n- 可见 __`viewport宽度 = 理想视口宽度 / initial-scale值`__\n\n\u003ca id='id3'\u003e\u003c/a\u003e\n\n## 关于缩放\n- 手机上放大，视觉视口缩小，布局视口不变，所以我们看到的css布局是不变的。  \n- PC上放大，视觉视口缩小，由于PC的布局视口和视觉视口是相同的，所以布局视口也变小，这就是我们在桌面端缩放的时候样式有时候会错乱的原因。  \n\n- 据说移动端css布局不改变也是因为移动端进行重绘的成本太高  \n\n\u003ca id='id4'\u003e\u003c/a\u003e\n\n## 布局视口的大小\n下面根据页面的解析过程来说明一下，浏览器在页面布局时的计算viewport的流程：   \n\n__没有viewport__  \n- 当页面没有声明viewport时，手机浏览器会取980px作为默认viewport的width值（IE/BlackBerry：1024px），然后全部显示，所以 默认的scale值 = 理想视口宽度  / 默认viewport宽度 。  \n\n__存在viewport__  \n当页面声明了viewport标签时，存在以下情况：  \n- 仅对于`width=device-width`，则viewport的宽高采用 理想视口 的尺寸(iPhone，iPad横屏时宽度是 理想视口 的宽度，而非高度)\n- 仅对于`initial-scale=1`，则viewport的宽高采用 理想视口 的尺寸( IE横屏时宽度是 理想视口 的宽度，而非高度)\n- 单独设置`width=x`或者`initial-scale=x`时，可以通过width直接获得或者通过initial-scale（理想视口宽度/initial-scale）计算出viewport的尺寸，需要注意的是viewport是有范围的(最小: 1/5 * 理想视口宽度)，所以当超出尺寸范围时，浏览器会选择相应的最大值或者最小值。\n- 如果width和initial-scale都存在时，会根据initial-scale计算出来的结果（理想视口宽度/initial-scale）与width值进行比较，取较大的值。（而Android Webkit则采用width值，IE永远认为`initial-scale=1`，但是需要注意layout的取值范围）。\n\n\u003ca id='id5'\u003e\u003c/a\u003e\n\n## javascript相关\n厂商间基本遵循的规范：  \n- `document.documentElement.clientWidth`： 表示 __布局窗口宽度__，可进行类似媒体查询；\n- `window.innerWidth`：表示 __视觉窗口宽度__，一般不会用； \n- `screen.width`: 表示 __理想窗口宽度__，兼容性据说差别很大；一般没啥用； \n- `orientationchange`事件，只要设备改变了方向都会触发，兼容性好；  \n- 移动端最好不要用`resize`事件，支持很差;  \n\n可以通过js模拟类似media查询的功能，在布局足够宽的时候才加载某些第三方组件：  \n```\nif(document.documentElement.clientWidth \u003e=600) {\n    // 加载组件\n}\n```\n\u003ca id='id6'\u003e\u003c/a\u003e\n\n## 总结\n\n1. 影响显示排版的是布局视口，布局视口变了，整个页面排版位置才会改变。\n2. 一般移动端进行适配：`\u003cmeta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,userscalable=no\"\u003e`\n3. 当然还可以\b利用js获取布局视口大小，进一步设置，适配出自己想要的效果。\n\n\n\n"},{"path":"_blogs/HTML\u0026CSS/CSS中可以和不可以继承的属性/README.md","title":"CSS中可以和不可以继承的属性","author":"yrobot","keywords":"CSS,属性,继承","createTime":1535040000000,"createTimeStr":"2018年08月24日","length":2705,"content":"# CSS中可以和不可以继承的属性    \n    \n   \n  \n__本页目录：__     \n[无继承性的属性](#id1)    \n[有继承性的属性](#id2)    \n[所有元素可以继承的属性](#id3)    \n[内联元素可以继承的属性](#id4)    \n[块级元素可以继承的属性](#id5)    \n  \n\u003ca id='id1'\u003e\u003c/a\u003e  \n  \n## 无继承性的属性  \n1. display：规定元素应该生成的框的类型  \n2. 文本属性：  \nvertical-align：垂直文本对齐  \ntext-decoration：规定添加到文本的装饰  \ntext-shadow：文本阴影效果  \nwhite-space：空白符的处理  \nunicode-bidi：设置文本的方向  \n3. 盒子模型的属性：width. height. margin . margin-top. margin-right. margin-bottom. margin-left. border. border-style. border-top-style. border-right-style. border-bottom-style. border-left-style. border-width. border-top-width. border-right-right. border-bottom-width. border-left-width. border-color. border-top-color. border-right-color. border-bottom-color. border-left-color. border-top. border-right. border-bottom. border-left. padding. padding-top. padding-right. padding-bottom. padding-left  \n4. 背景属性：background. background-color. background-image. background-repeat. background-position. background-attachment  \n5. 定位属性：float. clear. position. top. right. bottom. left. min-width. min-height. max-width. max-height. overflow. clip. z-index  \n6. 生成内容属性：content. counter-reset. counter-increment  \n7. 轮廓样式属性：outline-style. outline-width. outline-color. outline  \n8. 页面样式属性：size. page-break-before. page-break-after  \n9. 声音样式属性：pause-before. pause-after. pause. cue-before. cue-after. cue. play-during  \n  \n\u003ca id='id2'\u003e\u003c/a\u003e  \n  \n## 有继承性的属性  \n1. 字体系列属性  \nfont：组合字体  \nfont-family：规定元素的字体系列  \nfont-weight：设置字体的粗细  \nfont-size：设置字体的尺寸  \nfont-style：定义字体的风格  \nfont-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。  \nfont-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。  \nfont-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。  \n2. 文本系列属性  \ntext-indent：文本缩进  \ntext-align：文本水平对齐  \nline-height：行高  \nword-spacing：增加或减少单词间的空白（即字间隔）  \nletter-spacing：增加或减少字符间的空白（字符间距）  \ntext-transform：控制文本大小写  \ndirection：规定文本的书写方向  \ncolor：文本颜色  \n3. 元素可见性：visibility  \n4. 表格布局属性：caption-side. border-collapse. border-spacing. empty-cells. table-layout  \n5. 列表布局属性：list-style-type. list-style-image. list-style-position. list-style  \n6. 生成内容属性：quotes  \n7. 光标属性：cursor  \n8. 页面样式属性：page. page-break-inside. windows. orphans  \n9. 声音样式属性：speak. speak-punctuation. speak-numeral. speak-header. speech-rate. volume. voice-family. pitch. pitch-range. stress. richness. . azimuth. elevation  \n  \n\u003ca id='id3'\u003e\u003c/a\u003e  \n  \n## 所有元素可以继承的属性  \n\n1. 元素可见性：visibility\n2. 光标属性：cursor  \n\n\u003ca id='id4'\u003e\u003c/a\u003e  \n  \n## 内联元素可以继承的属性  \n1. 字体系列属性\n2. 除text-indent、text-align之外的文本系列属性  \n\n\u003ca id='id5'\u003e\u003c/a\u003e  \n  \n## 块级元素可以继承的属性  \n1. text-indent、text-align\n  \n---   \n\n  \n"},{"path":"_blogs/HTML\u0026CSS/display属性/README.md","title":"display 属性","author":"yrobot","keywords":"display,属性","createTime":1535040000000,"createTimeStr":"2018年08月24日","length":809,"content":"# display 属性  \n__本页目录：__   \n[display有哪些值,以及作用](#display)  \n[html元素嵌套规则](#nest)  \n\n\u003ca id='display'\u003e\u003c/a\u003e\n\n## display有哪些值,以及作用\n\n  - block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。\n  - none 缺省值。像行内元素类型一样显示。\n  - inline 行内元素类型。默认宽度为内容宽度，__不可设置宽高、margin上下、padding上下__，同行显示。\n  - inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。__元素间会有间隙__（HTML 中的换行符、空格符、制表符等合并为空白符，字体大小不为 0 的情况下，空白符自然占据一定的宽度，使用inline-block 会产生元素间的空隙）\n  - list-item 像块类型元素一样显示，并添加样式列表标记。\n  - table 此元素会作为块级表格来显示。\n  - inherit 规定应该从父元素继承display属性的值\n\n\u003ca id='nest'\u003e\u003c/a\u003e\n\n## html元素嵌套规则\n\n1. 块级元素可以包含内联元素或某些块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。\n2. 块级元素不能放在p里面。\n3. 有几个特殊的块级元素只能包含内联元素，不能包含块级元素。如h1,h2,h3,h4,h5,h6,p,dt\n4. li内可以包含div\n5. 块级元素与块级元素并列、内联元素与内联元素并列。\n\n"},{"path":"_blogs/JS/JS-DOM事件触发机制/README.md","title":"JS-DOM事件触发机制","author":"yrobot","keywords":"DOM,JS,触发,机制,事件","createTime":1535040000000,"createTimeStr":"2018年08月24日","length":3416,"content":"# JS-DOM事件触发机制  \n__本页目录：__   \n[问题的起因](#id1)  \n[事件冒泡](#id2)  \n[事件捕获](#id3)  \n[addEventListener的第三个参数](#id4)  \n[事件捕获先还是事件冒泡先？](#id5)  \n\n---\n\n\u003ca id='id'\u003e\u003c/a\u003e\n\n## 问题的起因\n- 事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。  \n- 考虑下面这段代码，就不写html-\u003ehead,body之类的代码了，自行脑补  \n    ```\n    \u003cdiv id=\"outer\"\u003e\n        \u003cp id=\"inner\"\u003eClick me!\u003c/p\u003e\n    \u003c/div\u003e\n    ```\n- 上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？  \n- 为了解决这个问题微软和网景提出了两种几乎完全相反的概念：__事件冒泡 和 事件捕获__。 \n\n\u003ca id='id2'\u003e\u003c/a\u003e\n\n## 事件冒泡\n- 微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。  \n\n- 因此在事件冒泡的概念下在p元素上发生click事件的顺序应该是 __p -\u003e div -\u003e body -\u003e html -\u003e document__ \n\u003ca id='id3'\u003e\u003c/a\u003e\n\n## 事件捕获\n- 网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。\n\n- 因此在事件捕获的概念下在p元素上发生click事件的顺序应该是 __document -\u003e html -\u003e body -\u003e div -\u003e p__\n\n\u003ca id='id4'\u003e\u003c/a\u003e\n\n## addEventListener的第三个参数\n- 网景 和 微软 曾经的战争还是比较火热的，当时， 网景主张捕获方式，微软主张冒泡方式。后来 w3c 采用折中的方式，平息了战火，制定了统一的标准—— __先捕获再冒泡__。 \n- __document -\u003e html -\u003e body -\u003e div -\u003e p -\u003e div -\u003e body -\u003e html -\u003e document__\n   \naddEventListener的第三个参数就是为冒泡和捕获准备的.   \n\n`element.addEventListener(event, function, useCapture)`\n\n第一个参数`event`是需要绑定的事件(string,例：'click')  \n第二个参数`function`是触发事件后要执行的函数  \n第三个参数`useCapture`默认值是false，表示在事件冒泡阶段调用事件处理函数; 如果参数为true，则表示在事件捕获阶段调用处理函数。  \n \n\u003ca id='id5'\u003e\u003c/a\u003e\n\n## 事件捕获先还是事件冒泡先？\n- 当事件捕获和事件冒泡一起存在的情况，事件又是如何触发呢？  \n \n- 这里记被点击的DOM节点为`target`节点：  \n    1. `document` 往 `target`节点，捕获前进，遇到注册的捕获事件立即触发执行  \n\n    2. 到达`target`节点，触发事件（对于`target`节点上，是先捕获还是先冒泡则捕获事件和冒泡事件的注册顺序，先注册先执行）  \n\n    3. `target`节点 往 `document `方向，冒泡前进，遇到注册的冒泡事件立即触发\n\n- __总结__ :  \n1. 对于非target节点则先执行捕获在执行冒泡  \n2. 对于target节点则是先执行先注册的事件，无论冒泡还是捕获\n\n#### 例子\n```\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003ctitle\u003eTestJSevent\u003c/title\u003e\n    \u003cstyle\u003e\n        #son {\n            width: 100px;\n            height: 100px;\n            background-color: #0f0;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n    \u003cdiv id=\"father\"\u003e\n        \u003cdiv id=\"mather\"\u003e\n            \u003cdiv id=\"son\"\u003e\u003c/div\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cdiv id=\"text\"\u003e\u003c/div\u003e\n    \u003cscript\u003e  \n        var Son = document.getElementById(\"son\");\n        var Father = document.getElementById(\"father\");\n        function Click(Id, Type) {\n            document.getElementById(\"text\").innerHTML += Id + \"  \" + Type + \" clicked  ||   \";\n        }\n        Son.addEventListener(\"click\", function () { Click(\"son\", \"false\") }, false);\n        Son.addEventListener(\"click\", function () { Click(\"son\", \"true\") }, true);\n        Father.addEventListener(\"click\", function () { Click(\"father\", \"true\") }, true);\n        Father.addEventListener(\"click\", function () { Click(\"father\", \"false\") }, false);\n        mather.addEventListener(\"click\", function () { Click(\"mather\", \"true\") }, true);\n        mather.addEventListener(\"click\", function () { Click(\"mather\", \"false\") }, false);  \n    \u003c/script\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n输出：\nfather true clicked || mather true clicked || son false clicked || son true clicked || mather false clicked || father false clicked ||\n\u003cbr\u003e\u003cbr\u003e\n#### IE浏览器兼容  \nIE浏览器对addEventListener兼容性并不算太好，只有IE9以上可以使用。要兼容旧版本的IE浏览器，可以使用IE的attachEvent函数\n\n`object.attachEvent(event, function)`\n\n两个参数与`addEventListener`相似，分别是事件和处理函数，默认是事件冒泡阶段调用处理函数，要注意的是，写事件名时候要加上\"`on`\"前缀（\"`onload`\"、\"`onclick`\"等）。\n\n"},{"path":"_blogs/JS/JS函数与闭包/README.md","title":"JS函数与闭包","author":"yrobot","keywords":"闭包,JS,函数","createTime":1535040000000,"createTimeStr":"2018年08月24日","length":2063,"content":"# JS函数与闭包  \n__本页目录：__   \n[JS函数](#func)  \n[闭包](#bibao)  \n\n\u003ca id='func'\u003e\u003c/a\u003e\n\n## JS函数\n\n#### 1. __js函数的[[scope]]__  \n- 每个javascript函数都是一个对象，对象中有些属性我们可以访问，但有些仅供javascript引擎存取，比如[[scope]]，他就是我们所指的作用域，其中储存了 __运行期上下文的集合__。\n- 可以将[[scope]]理解为函数仓库链，函数寻找变量的时候就根据这个链来查找。  \n\n#### 2. __运行期上下文__  \n- 函数执行前创建的对象（AO=运行期上下文：理解为本函数自带的仓库），用于定义函数运行时的环境。函数被多次调用时，会创建多个运行期上下文。\n- 当函数执行完毕，其运行期上下文引用被自动销毁（只是切断引用，其AO仍然存在，AO只有在没有被函数链接时才被回收）。\n\n#### 3. __运行期上下文如何从内存中销毁__  \n- 当此上下文没有被任何函数链接时，js引擎会自动将其回收。但只要还有函数在引用此上下文（存在闭包的情况），则此上下文不会被回收。\n- 所以只要通过 __将闭包变量设置为等于null__ 解除该函数（以及其上下文）的引用，就等于通知垃圾回收例程将其清除。\n\n#### 4. __函数如何查找变量__  \n- 从[[scope]]作用域链的顶端开始向下查找。即从自身\b的执行器上下文开始找变量，未找到则转向[[scope]]的下一个上下文。 \n\n#### 例子\n- 例1：  \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fukrtxws7nj30jf0o0n3w.jpg)   \n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fukru71y2pj30s30lhqpc.jpg)  \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fukrucycgnj30tl0nekhv.jpg)  \n\n- 例2：  \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fukrw1ajtzj30ki0m2wr1.jpg)  \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fukrw1ajtzj30ki0m2wr1.jpg)  \n\n\u003ca id='bibao'\u003e\u003c/a\u003e\n\n## 闭包 \n- __闭包是指 有权访问另一个函数作用域中的变量 的函数__  \n- 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。所以，在本质上，__闭包就是将函数内部和函数外部连接起来的一座桥梁__。\n```\nfunction createComparisonFunction(propertyName) {\n  return function (object1, object2) {\n    var value1 = object1[propertyName];\n    var value2 = object2[propertyName];\n    if (value1 \u003c value2) {\n      return -1;\n    } else if (value1 \u003e value2) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n}\n\n//创建函数 \nvar compareNames = createComparisonFunction(\"name\");\n\n//调用函数 \nvar result = compareNames({name: \"Nicholas\"}, {name: \"Greg\"});\n\n//解除对匿名函数的引用（以便释放内存）\ncompareNames = null;\n```\n\n#### 闭包作用：\n  1. 实现公有变量  \n  2. 可以做缓存  \n  3. 可以实现封装，属性私有化  \n  4. 模块化开发，防止污染全局变量   \n\n#### 闭包注意点：\n  1. 由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，造成内存泄漏。  \n  2. 作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的后一个值。  \n\n\n"},{"path":"_blogs/JS/JS异步编程/README.md","title":"JS异步编程","author":"yrobot","keywords":"JS,异步,编程","createTime":1535040000000,"createTimeStr":"2018年08月24日","length":4481,"content":"# JS异步编程  \n__本页目录：__   \n[概念学习](#gn)   \n[浏览器线程和Event Loop](#eventLoop)   \n[JS的任务执行机制](#mechanism)   \n[JS异步的理解](#unds)   \n[JS的异步编程实现](#cometrue)   \n[JS异步优化页面卡顿](#better)   \n\n\u003ca id='gn'\u003e\u003c/a\u003e\n\n## 概念学习\n- __并发__：同一时间段有几个程序都处于已经启动到运行完毕之间，并且这几个程序都在同一个处理机上运行，并发的两种关系是同步和互斥；\n\n- __互斥__：进程之间访问临界资源时相互排斥的现象；\n\n- __同步__：进程之间存在依赖关系，一个进程结束的输出作为另一个进程的输入。具有同步关系的一组并发进程之间发送的信息称为消息或者事件；\n\n- __并行__：单处理器中进程被交替执行，表现出一种并发的外部特征；在多处理器中，进程可以交替执行，还能重叠执行，实现并行处理，并行就是同事发生的多个并发事件，具有并发的含义，但并发不一定是并行，也就是说事件之间不一定要同一时刻发生；\n\n- __多线程__：多线程是进程中并发运行的一段代码，能够实现线程之间的切换执行；\n\n- __异步(不按顺序)__：和同步相对，同步是顺序执行，而异步是彼此独立，在等待某个事件的过程中继续做自己的事，不要等待这一事件完成后再工作。线程是实现异步的一个方式，异步是让调用方法的主线程不需要同步等待另一个线程的完成，从而让主线程干其他事情。  \n-- 所谓\"异步\"，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。比如，有一个任务是读取文件进行处理，异步的执行过程就是下面这样。  \n-- 这种不连续的执行，就叫做异步。相应地，连续的执行，就叫做同步。\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fukonjqddzj30t20gs0yu.jpg)\n\n- __异步和多线程__：不是同等关系，异步是目的，多线程只是实现异步的一个手段，实现异步可以采用多线程技术或者交给其他进程来处理。\n\n\u003ca id='eventLoop'\u003e\u003c/a\u003e\n\n## 浏览器线程和Event Loop\n\n- js既然是单线程,那么肯定是排队执行代码，那么怎么去排这个队，就是Event Loop。虽然JS是单线程，但浏览器不是单线程。  \n- 浏览器中分为以下几个线程:\n  1. js线程\n  2. UI线程(浏览器内核)\n  2. 事件线程(onclick,onchange,...)：触发事件发生后，绑定的函数由Event Table移入Event Queue，等待被js主线程调用\n  4. 定时器线程(setTimeout, setInterval)： 确保js定时器和异步触发的准确性\n  3. 异步http请求线程(ajax)  \n  - 其中JS线程和UI线程相互互斥，也就是说，当UI线程在渲染的时候，JS线程会挂起，等待UI线程完成，再执行JS线程\n\n- 名词解析：\n  1. __浏览器事件触发线程__：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JavaScript 的单线程关系所有这些事件都得排队等待 JavaScript 引擎处理；\n  2. __定时触发器线程__：浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案；\n  3. __异步 HTTP 请求线程__：在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理；\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fukonkymdvj30cv08v751.jpg)  \n- 在点击按钮之后，页面卡顿，连续点击按钮时，页面无反应，等到loop运行完时，连续弹出alert。证明 事件线程 独立于 js线程，而同时 UI线程 被挂起。 \n代码：\n```\n\u003cbutton onclick=\"myClick()\"\u003eyep\u003c/button\u003e\n    \u003cscript\u003e\n        let count =0;\n        function myClick(){\n            alert(count++)\n            if(count==1)\n                loop();\n        }\n        function loop(){\n            let i=99999;\n            while(i--){\n                console.log(1);\n            }\n        }\n    \u003c/script\u003e\n``` \n\u003ca id='mechanism'\u003e\u003c/a\u003e\n\n## JS的任务执行机制\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fukopfdw9oj30vk0ugwpy.jpg)  \n__导图要表达的内容用文字来表述的话：__\n- 同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入Event Table并注册函数。\n- 当指定的事情完成时(条件函数完成，绑定的按钮发生点击，请求返回etc)，Event Table会将这个函数移入Event Queue。\n- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。\n- 上述过程会不断重复，也就是常说的Event Loop(事件循环)。\n\n\u003ca id='unds'\u003e\u003c/a\u003e\n\n## JS异步的理解\n\n- 如概念学习里所说的，js异步主要是：对于占用主线程的操作，利用js任务执行机制，将其放入Event Queue中，等待主线程空闲了才执行。 \n\n\u003ca id='cometrue'\u003e\u003c/a\u003e\n\n## JS的异步编程实现\n\nES 6以前：\n  - 定时器(setTimeout, setInterval)\n  - 回调函数\n  - 事件监听(事件发布/订阅)\n  - Promise对象  \n\nES 6：\n  - Generator函数(协程coroutine) \n\nES 7:\n  - async和await\n\n\u003ca id='better'\u003e\u003c/a\u003e\n\n## JS异步优化页面卡顿\n\n__方案1__：针对支持html5 webworker的现代浏览器方案:   \n_代码1._ 你的大量计算，放到一个js文件中。如下：\n```\n//job.js\nonmessage = function (evt){  //do massive job.在这里你进行大量耗时的计算过程。 \n  postMessage( data );//将计算结果的数据发送会主线程\n}\n```\n你的页面代码：\n```\n\u003c!DOCTYPE HTML\u003e\n\u003chtml\u003e\n\n\u003chead\u003e\n    \u003cmeta http-equiv=\"Content-Type\"  content=\"text/html; charset=utf-8\" /\u003e\n    \u003cscript type=\"text/javascript\"\u003e\n        //WEB页主线程var worker =new Worker(\"job.js\"); \n        //创建一个Worker对象并向它传递将在新线程中执行的脚本的URL \n        worker.postMessage('开始计算');\n        worker.onmessage = function (evt) {//接收worker传过来的数据函数   \n            console.log(evt.data);//输出worker发送来的数据，这里就获取到了大量计算的结果。 \n        } \n    \u003c/script\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\u003c/body\u003e\n\n\u003c/html\u003e\n```\n_方案2：_ 对于不支持WebWorker线程的浏览器。\n可以考虑分批处理。即是说创造一个间隔定时器setInterval。  \n每隔一小段时间，处理大量数据中的一部分。  \n这样就可以避免大量计算导致浏览器卡死。  \n大致代码如下(这里是简单的例子，具体情况具体分析)   \n假设我们要计算1000万个数据的和：  \n```\nvar jobData = [];//假设是一个数组。里面有1000万个数据  \nfunction  sliceJob() {\n    var  num  =  (jobData.length  /  100)  +  1;//把任务数据划分为100份。    \n    var  portion  =  100000;//每份有10万个数字。    \n    var  addition  =  0;//这里用来保存最后的结果。一开始是0；    \n    var  intv  =  setInterval(function () {\n            if (num--) {            //然后每一份结果。            \n        additoin  +=  every;\n    }  else  {            //计算最后一份，然后输出结果。            \n        alert('最终结果是:',  addition);\n        window.clearInterval(intv);\n    }\n        },  50);\n}\n```\n此外。jQuery的deferred对象无法实现你的要求。  \n因为deferred对象的目的是为了串行处理异步过程。  \n但是异步过程在执行的过程中，如果耗时过长，仍然会阻塞浏览器线程，导致浏览器不可操作（卡死）。  \n\n---\n\n\n"},{"path":"_blogs/JS/JS的三个定时器/README.md","title":"JS的三个定时器","author":"yrobot","keywords":"JS,定时器,三个","createTime":1535040000000,"createTimeStr":"2018年08月24日","length":4228,"content":"# JS的三个定时器  \n   \n \n\n__本页目录：__   \n[setTimeout](#setTimeout)  \n[setInterval](#setInterval)  \n[requestAnimationFrame](#requestAnimationFrame)  \n[JS动画](#jsAnimation)   \n[推荐使用requestAnimationFrame绘制JS动画](#useAnimation)   \n\n\u003ca id='setTimeout'\u003e\u003c/a\u003e\n\n## setTimeout\n- 在执行时,是在载入后延迟指定时间后执行一次表达式（仅执行一次）  \n\n\u003ca id='setInterval'\u003e\u003c/a\u003e\n\n## setInterval\n- 在执行时,它从载入后,每隔指定的时间就执行一次表达式  \n- 在代码运行到间歇调用和超时调用时，定时器（浏览器中 __独立于js线程的一个线程__）会在相应的时间，将相应的代码放入宏代码队列中，所以不必考虑放代码时，js是否有程序在运行。所以这两个函数只能保证按时将代码放入队列，但具体的执行时间要看队列前的函数执行情况（什么时候轮到放入的函数）。由于这三个函数都是js异步编程的一种实现，所以详情参看[JS异步编程 #浏览器线程和Event Loop](/JS/JS异步编程/README.md#eventLoop)\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fukmxrd5ixj30m409smxx.jpg)\n\n\u003ca id='requestAnimationFrame'\u003e\u003c/a\u003e\n\n## requestAnimationFrame \n- 不能指定延迟时间，而是根据浏览器的刷新频率而定（帧），即浏览器页面刷新一次函数就执行一次，适合实现页面动画  \n\n\u003ca id='jsAnimation'\u003e\u003c/a\u003e\n\n## JS动画\n理解了上面的概念以后，我们不难发现，setTimeout 其实就是通过设置一个间隔时间来不断的改变元素属性，从而达到动画效果的。但我们会发现，利用 seTimeout 实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因：\n1. setTimeout 的执行时间并不是确定的。在JavaScript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，所以 setTimeout 的实际执行时机一般要比其设定的时间晚一些。\n2. 刷新频率受 屏幕分辨率 和 屏幕尺寸 的影响，不同设备的屏幕绘制频率可能会不同，而 setTimeout 只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。  \n\n以上两种情况都会导致 setTimeout 的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。 那为什么步调不一致就会引起丢帧呢？   \n\n首先要明白，setTimeout 的执行只是在内存中对元素属性进行改变，这个变化必须要等到屏幕下次绘制时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素。假设屏幕每隔16.7ms刷新一次，而setTimeout 每隔10ms设置图像向左移动1px， 就会出现如下绘制过程：\n- 第0ms：屏幕未绘制，  等待中，setTimeout 也未执行，等待中；\n- 第10ms：屏幕未绘制，等待中，setTimeout 开始执行并设置元素属性 left=1px；\n- 第16.7ms：屏幕开始绘制，屏幕上的元素向左移动了 1px， setTimeout 未执行，继续等待中；\n- 第20ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=2px;\n- 第30ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=3px;\n- 第33.4ms：屏幕开始绘制，屏幕上的元素向左移动了 3px， setTimeout 未执行，继续等待中；\n- ...  \n\n从上面的绘制过程中可以看出，屏幕没有更新 left=2px 的那一帧画面，元素直接从left=1px 的位置跳到了 left=3px 的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。\n\n\u003ca href=\"\" id=\"useAnimation\"\u003e\u003c/a\u003e\n\n## 推荐使用requestAnimationFrame绘制JS动画 \n与 setTimeout 相比，requestAnimationFrame() 最大的优势是 __由系统来决定回调函数的执行时机__。具体一点讲就是，系统每次绘制之前会主动调用 requestAnimationFrame() 中的回调函数，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms。换句话说就是，requestAnimationFrame() 的执行步伐跟着系统的绘制频率走。它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。\n\n这个API的调用很简单，如下所示：\n```\nvar progress = 0;\n//回调函数\nfunction render() {\n    progress += 1; //修改图像的位置\n \n    if (progress \u003c 100) {\n           //在动画没有结束前，递归渲染\n           window.requestAnimationFrame(render);\n    }\n}\n \n//第一帧渲染\nwindow.requestAnimationFrame(render);\n```\n除此之外，requestAnimationFrame 还有以下两个优势：\n\n1. __PU节能__：使用 setTimeout 实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，而且还浪费 CPU 资源。而 rAF 则完全不同，当页面处理未激活的状态下，该页面的屏幕绘制任务也会被系统暂停，因此跟着系统步伐走的 rAF 也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。\n\n2. __函数节流__：在高频率事件(resize,scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，使用 rAF 可保证每个绘制间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个绘制间隔内函数执行多次时没有意义的，因为显示器每16.7ms 绘制一次，多次绘制并不会在屏幕上体现出来。\n\n\u003ca href=\"\" id=\"suitDown\"\u003e\u003c/a\u003e\n\n## 适配低版本\n以下代码考虑到部分浏览器不支持requestAnimationFrame的情况，对requestAnimationFrame和cancelAnimationFrame进行降级适配。\n```\nif (!Date.now)\n    Date.now = function() { return new Date().getTime(); };\n \n(function() {\n    'use strict';\n     \n    var vendors = ['webkit', 'moz'];\n    for (var i = 0; i \u003c vendors.length \u0026\u0026 !window.requestAnimationFrame; ++i) {\n        var vp = vendors[i];\n        window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];\n        window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame']\n                                   || window[vp+'CancelRequestAnimationFrame']);\n    }\n    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy\n        || !window.requestAnimationFrame || !window.cancelAnimationFrame) {\n        var lastTime = 0;\n        window.requestAnimationFrame = function(callback) {\n            var now = Date.now();\n            var nextTime = Math.max(lastTime + 16, now);\n            return setTimeout(function() { callback(lastTime = nextTime); },\n                              nextTime - now);\n        };\n        window.cancelAnimationFrame = clearTimeout;\n    }\n}());\n```\n---  \n*\b本章节部分参考[一像素 博客](https://www.cnblogs.com/onepixel/p/7078617.html)，在此感谢！*\n\n\n"},{"path":"_blogs/JS/THIS的指向/README.md","title":"THIS的指向","author":"yrobot","keywords":"THIS,指向","createTime":1535040000000,"createTimeStr":"2018年08月24日","length":940,"content":"# THIS的指向\n\n__本页目录：__   \n[this的建立](#build)   \n[this指向](#index)   \n[this规则概括](#rule)  \n\n\u003ca id='build'\u003e\u003c/a\u003e\n\n## this的建立\n- 一般函数在预编译过程中生成的AO上下文  \n- AO中除了函数内的一些属性和函数参数外，还有`arguments`和`this`(箭头函数没有)。  \n- 所以函数（除了箭头函数）预编译过程会生成`this`隐式对象，并 __默认指向window。__  \n\n\u003ca id='index'\u003e\u003c/a\u003e\n\n## this指向\n- 而在预编译过程中，`this`会默认指向`window`。  \n- 而`new`操作时，会在函数内生成一个隐式`this`对象，而同时改变AO中`this`指向为本`this`\n- 用`obj.func()`调用的时候，会将`func()`内的`this`指向改为`obj`  \n- #### 以上`this`的修改是在`func`有`this`的情况下，箭头函数没有this，直接沿着作用域链向上寻找this  \n- #### 注意函数作用域链的数据是由函数参数、函数内声明组成，fun.prop无法\b增加或更改作用域    \n\n\u003ca id='rule'\u003e\u003c/a\u003e\n\n## this规则概括\n\n1. 函数编译过程中AO上下文中`this`默认指向`window`  \n2. 全局作用域里`this`指向`window`  \n3. `call`/`apply`可以利用参数改变`this`的指向  \n4. `obj.fun()`调用时，`fun()`AO中`this`指向obj (`new` 生成对象时默认`return this`，所以只有`this.xxx`的属性才能被访问到)  \n5. html元素脚本中，函数参数中的`this`指向元素本身  \n\n---\n\n\n"},{"path":"_blogs/JS/遍历obj和array/README.md","title":"遍历obj和array","author":"yrobot","keywords":"array,obj,遍历","createTime":1535040000000,"createTimeStr":"2018年08月24日","length":1525,"content":"# 遍历obj和array  \n__本页目录：__   \n[基础for循环](#for)  \n[for in 循环](#forin)  \n[for of 循环](#forof)  \n[array.forEach()方法](#foreach)  \n[总结](#summary)  \n\n\u003ca id='for'\u003e\u003c/a\u003e\n\n## 1. 基础for循环\n```\nfor (var index = 0; index \u003c myArray.length; index++) {\n  console.log(myArray[index]);\n}\n```\n\n\u003ca id='forin'\u003e\u003c/a\u003e\n\n## 2. for in 循环\n- for...in 语句用于对数组或者对象的属性进行循环操作。\n```\nfor(let i in array)  // i为数组的index：0，1，2，3.....\nfor(let i in obj)  // i为obj 的属性名\n```\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fukqtphbb9j31e60bwgmv.jpg)\n\u003ca id='forof'\u003e\u003c/a\u003e\n\n## 3. for of 循环\n参考链接：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of\n```\nfor (let value of iterable) {  // value为属性值\n    //statements\n}\n``` \n__value__  \n在每次迭代中，将不同属性的值分配给变量。 \n\n__iterable__ ( Array，Map，Set，String，TypedArray，arguments 对象等等) (obj不是iterable)  \n被迭代枚举其属性的对象。  \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fukqtq7vk6j31e60fqmzh.jpg)  \n\n\u003ca id='foreach'\u003e\u003c/a\u003e\n\n## 4. array.forEach()方法\n```\narr.forEach(function callback(value[, index[, array]]) { // value:属性值，index:当前索引，array:当前遍历数组\n    //your iterator\n}[, thisArg]);   // thisArg:作为callback函数的this值\n``` \n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fukqto6spyj31ec0c0dh4.jpg)\n\n\u003ca id='summary'\u003e\u003c/a\u003e\n\n## 总结\n1. 少用for of，支持不好。性能也一般。性能基础for优化较好\n2. 遍历array，以上方法均可\n3. 遍历obj思路：\n    1. 获取obj的keys，利用基础for遍历\n    2. for in利用属性名获取属性值\n    3. 利用object.keys()方法获取keys，再用keys.forEach()遍历获取属性值\n\n"},{"path":"_blogs/MarkDown/markdown注意点.md","title":"markdown注意点","author":"yrobot","keywords":"markdown,注意","createTime":1535040000000,"createTimeStr":"2018年08月24日","length":525,"content":"# markdown注意点  \n__本页目录：__   \n[链接](#url)  \n[VS-Code:snippet](#snippet)  \n\n\u003ca id='url'\u003e\u003c/a\u003e\n\n## 链接\n__链接跳转：__ `[描述](url)`  \n__图片：__`![](url)`  \n\n__markdown语法要求：__  \n1. 页内锚点链接：字母要统统小写，空格统统要替换成 '-'。  \n2. 外部链接：不可包含空格。  \n\n__解决方案__：直接使用a标签即可  \n\n\u003ca id='snippet'\u003e\u003c/a\u003e\n\n## VS-Code:snippet\n\n- 可以在vscode用户代码块添加对markdown的snippet。\n- 个人vscode的.md文件一直不提示，无奈修改\"editor.action.triggerSuggest\"快捷键，强制唤醒md文件的代码提示。\n\n"},{"path":"_blogs/JS/JS多线程WebWorker/README.md","title":"JS多线程Web Worker","author":"yrobot","keywords":"多线程,Worker,JS,Web","createTime":1534953600000,"createTimeStr":"2018年08月23日","length":3983,"content":"# JS多线程Web Worker\n__本页目录：__   \n[为什么使用Web Woker](#why)  \n[Web Woker是什么](#what)  \n[检测浏览器支持](#support)  \n[新建Web Worker](#new)  \n[mainjs与worker之间的数据传递](#message)  \n[主线程中worker的属性](#workerPro)  \n[子线程中的全局属性](#selfPro)  \n[关闭子线程](#close) \n\n\u003ca href=\"\" id=\"why\"\u003e\u003c/a\u003e\n\n## 为什么使用Web Woker  \n核心思想：一些容易阻塞主线程的事情，或者说主线程一个线程完成不了的事情（单页面多连接），可以交给WebWoker\n#### 1. 使用专用线程进行数学运算  \nWeb Worker最简单的应用就是用来做后台计算，而这种计算并不会中断前台用户的操作\n#### 2. 图像处理   \n通过使用从`\u003ccanvas\u003e`或者`\u003cvideo\u003e`元素中获取的数据，可以把图像分割成几个不同的区域并且把它们推送给并行的不同Workers来做计算\n#### 3. 大量数据的检索   \n当需要在调用 ajax后处理大量的数据，如果处理这些数据所需的时间长短非常重要，可以在Web Worker中来做这些，避免冻结UI线程。\n#### 4. 背景数据分析  \n由于在使用Web Worker的时候，我们有更多潜在的CPU可用时间，我们现在可以考虑一下JavaScript中的新应用场景。例如，我们可以想像在不影响UI体验的情况下实时处理用户输入。利用这样一种可能，我们可以想像一个像Word（Office Web Apps 套装）一样的应用：当用户打字时后台在词典中进行查找，帮助用户自动纠错等等。\n\n\u003ca href=\"\" id=\"what\"\u003e\u003c/a\u003e  \n\n## Web Woker是什么  \nWeb Worker 是HTML5标准的一部分，这一规范定义了一套 API，它允许一段JavaScript程序运行在主线程之外的另外一个线程中。Web Worker 规范中定义了两类工作线程，分别是专用线程Dedicated Worker和共享线程 Shared Worker，其中，Dedicated Worker只能为一个页面所使用，而Shared Worker则可以被多个页面所共享。\n\n\u003ca href=\"\" id=\"support\"\u003e\u003c/a\u003e\n\n## 检测浏览器支持  \n```\n//引入modernizr.js的情况\nif(!Modernizr.webworker){\n    alert(\"This browser doesn't support Web Worker!\");\n}  \n\n//未引入modernizr.js的情况\nif(typeof(Worker)!==\"undefined\"){\n    //支持\n}else{\n    //不支持code\n}\n```\n\n\u003ca href=\"\" id=\"new\"\u003e\u003c/a\u003e\n\n## 新建Web Worker  \n`var worker = new Worker(\"task.js\"); //在main.js中new一个woker`\n\n浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。  \n`var myWorker = new Worker(jsUrl, [options]);`\n\nWorker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。\n```\n// 主线程\nvar myWorker = new Worker('worker.js', { name : 'myWorker' });\n\n// Worker 线程\nself.name // myWorker\n```\n\n\u003ca href=\"\" id=\"message\"\u003e\u003c/a\u003e\n\n## mainjs与worker之间的数据传递  \n#### 主线程—send—\u003eworker：  \n```\nworker.postMessage(data);   \n//data可以死各种类型的数据、string、object、array、number。。。  \n//子线程通过监听函数参数e的data属性获取上述data  \n```  \n#### 主线程\u003c—get—worker：  \n```\nworker.onmessage = function (event) {  \n  console.log('Received message ' + event.data);  \n  //相应业务操作  \n}  \n```  \n#### worker—send—\u003e主线程：  \n`self.postMessage(data);  //self指代worker线程全局对象(同this) `  \n\n#### worker\u003c—get—主线程：  \n```\nself.addEventListener('message', function (e) {  \n  console.log('Main data: ' + e.data);  \n}, false);  \n```\n__so：__  \n当主线程或者子线程要传递 命令以及数据 时：可以传递一个对象`{cmd:'go',data:'dt'}`。  \n接收者用`event.data.cmd`和`event.data.data`获取命令和数据。  \n#### 例子：主线程传参 `{cmd:\"\", msg:\"\"}`\n```\nself.addEventListener('message', function (e) {  \n  var data = e.data;  \n  switch (data.cmd) {  \n    case 'start':  \n      self.postMessage('WORKER STARTED: ' + data.msg);  \n      break;  \n    case 'stop':  \n      self.postMessage('WORKER STOPPED: ' + data.msg);  \n      self.close(); // Terminates the worker.  \n      break;  \n    default:  \n      self.postMessage('Unknown command: ' + data.msg);  \n  };  \n}, false);  \n```\n\n\u003ca href=\"\" id=\"workerPro\"\u003e\u003c/a\u003e\n\n## 主线程中worker的属性  \n- Worker.onerror：指定 error 事件的监听函数。  \n- Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。  \n- Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。   \n- Worker.postMessage()：向 Worker 线程发送消息。  \n- Worker.terminate()：立即终止 Worker 线程。  \n\n__子线程的错误监听实例：__   \n```\nworker.onerror(function (event) {\n  console.log([\n    'ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message\n  ].join(''));\n});\n\n// 或者\nworker.addEventListener('error', function (event) {\n  // ...\n});\n```\n\n\n\u003ca href=\"\" id=\"selfPro\"\u003e\u003c/a\u003e\n\n## 子线程中的全局属性  \nWeb Worker 有自己的全局对象，不是主线程的window，而是一个专门为 Worker 定制的全局对象.  \n- self.name：Worker 的名字。该属性只读，由构造函数指定。  \n- self.onmessage：指定message事件的监听函数。  \n- self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。  \n- self.close()：关闭 Worker 线程。  \n- self.postMessage()：向产生这个 Worker 线程发送消息。  \n- __self.importScripts()：加载 JS 脚本。__  \n\n\u003ca href=\"\" id=\"close\"\u003e\u003c/a\u003e\n\n## 关闭子线程  \n```\n// 主线程\nworker.terminate();\n\n// Worker 线程\nself.close();\n```\n---\n\n"},{"path":"_blogs/JSON/JSON使用注意点.md","title":"JSON使用注意点","slug":"home","author":"yrobot","keywords":"JSON,注意,使用","createTime":1534953600000,"createTimeStr":"2018年08月23日","length":1814,"content":"\n# JSON使用注意点  \n__本页目录：__   \n[关于引入](#import)  \n[关于操作](#todo)  \n\n\n\u003ca href=\"\" id=\"import\"\u003e\u003c/a\u003e\n\n## 关于引入？\n早期的JSON解析器基本上就是使用JavaScript的eval()函数。由于JSON是JavaScript语法的自己，因此eval()函数可以解析、解释并返回JavaScript的对象和数组。\n\nECMAScript 5对解析JSON的行为进行了规范，定义了全局对象JSON。\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuklqfg3zcj30hi06sjro.jpg)\n据网上资料，浏览器对JSON的支持情况 ： IE8 chrome1+ safari3+ firefox3+，所以在这些浏览器中使用JSON可以不引入json2.js，在其他低版本浏览器中需要引入json2.js。所以，默认引入即可，去除注释的json2也才8kb不到。\n\n\u003ca href=\"\" id=\"todo\"\u003e\u003c/a\u003e\n\n## 关于操作？\n-  __JSON.parse(string) ：接受一个 JSON字符串 并将其转换成一个 JavaScript 对象。__\n-  __JSON.stringify(obj) ：接受一个 JavaScript 对象并将其转换为一个 JSON字符串。__\n\n#### 1. __JSON.parse() 不允许在末尾添加多余的逗号__  \n- 下面两行代码都会抛出错误:  \n1 JSON.parse('[1, 2, 3, 4, ]');  \n2 JSON.parse('{\"foo\" : 1, }');  \n3 // SyntaxError JSON.parse: unexpected character   \n4 // at line 1 column 14 of the JSON data  \n- 省略末尾多余的逗号解析 JSON 就是正确:  \n1 JSON.parse('[1, 2, 3, 4 ]');  \n2 JSON.parse('{\"foo\" : 1 }');  \n\n#### 2. __JSON 的属性名必须使用双引号__  \n- 属性名上不能使用单引号，例如： 'foo'。  \n1 JSON.parse(\"{'foo' : 1 }\");  \n2 // SyntaxError: JSON.parse: expected property name or '}'   \n3 // at line 1 column 2 of the JSON data  \n- 取而代之，写成 \"foo\"：  \n1 JSON.parse('{\"foo\" : 1 }');  \n\n#### 3. __数字不能用 0 开头，比如01，并且你的小数点后面必须跟着至少一个数字。__  \n- 数字不能用 0 开头，比如01 ,小数点后面必须跟着至少一个数字。\n1 JSON.parse('{\"foo\" : 01 }');  \n2 // SyntaxError: JSON.parse: expected ',' or '}' after property value   \n3 // in object at line 1 column 2 of the JSON data  \n|\n4 JSON.parse('{\"foo\" : 1. }');   \n5 // SyntaxError: JSON.parse: unterminated fractional number   \n6 // at line 1 column 2 of the JSON data  \n- 正确的写法应该是只写一个1，不书写前面的0。在小数点的后面至少要跟上一个数字:  \n1 JSON.parse('{\"foo\" : 1 }');  \n2 JSON.parse('{\"foo\" : 1.0 }');  \n   \n\n\n\n\n\n"}]},{"title":"JS","list":[{"path":"_blogs/JS/JS模块化/README.md","title":"JS模块化","author":"yrobot","keywords":"JS,模块化","createTime":1571068800000,"createTimeStr":"2019年10月15日","length":5233,"content":"\u003ca id='top'\u003e\u003c/a\u003e\n\n# JS模块化  \n\u003ca href=\"#top\" style=\"position: fixed;font-size: 30px;color: rgb(88, 153, 226);right: 10px;bottom: 20px;z-index: 999;\"\u003eTOP\u003c/a\u003e\n\n__本页目录：__   \n[前言](#pre)  \n[无模块化](#none)  \n[CommonJS规范](#commonjs)  \n[AMD规范](#AMD)  \n[CMD规范](#CMD)  \n[ES6模块化](#ES6)  \n[CommonJs和ES6区别](#ES6CMJS)  \n\n__友情连接：__  \nQ：那么新的ES6模块化对我们前端开发有什么意义呢？webpack就没有用了嘛？  \nA：[探讨ESM对当前开发的意义或影响](../探讨ESM对当前开发的意义或影响/README.md)\n\n\u003ca id='pre'\u003e\u003c/a\u003e\n\n## 前言  \n其实一直以来我在前端开发中都会用到模块化的相关知识，但是我总是一知半解的。  \n而且目前完善的构建工具让我无需深入的了解前端模块的知识（用就得了，莽就行了）。  \n但是有一天，我的后端室友发给我了一篇 [《愿未来没有 Webpack》](https://juejin.im/post/5d4bcdb7e51d453b386a62c6)\n\n读完我不禁陷入了沉思。。。  \n不知道是什么时候开始接收了webpack作为前端开发必备工具这件事了。  \n而为什么要用webpack这件事，却从来没有问过自己。  \n而文中提到的[@pika/web](https://github.com/pikapkg/web)，又是一个什么神奇的操作？\n\n经过一段时间的学习理解，发现这原来是JS模块化造成的，总结成一句话就是：  \n`浏览器无法支持commonjs模块化，所以需要打包工具将所有依赖和自写代码打包到一个文件中；而因为浏览器渐渐开始原生支持ESM，所以只要将commonjs规范转换成ESM规范，就可以直接在浏览器中静态引用了`  \n\n所以在这探索的过程中，就不得不好好学习JS模块化的知识，本文就是对JS模块的一个学习总结 \n\nby the way, 以下讲的是一些规范（用于模块化的理论而已），具体实现参看具体实现框架/库  \n\n\n\u003ca id='none'\u003e\u003c/a\u003e\n\n## 无模块化  \n表现形式：\n```\n    \u003cscript src=\"jquery.js\"\u003e\u003c/script\u003e\n    \u003cscript src=\"main.js\"\u003e\u003c/script\u003e\n    \u003cscript src=\"other.js\"\u003e\u003c/script\u003e\n```\n直接在html中利用script标签引入js文件，并按照引入顺序一个一个执行，每个js都是用window全局作用域  \n\n#### 无模块化的问题：\n1. 文件有依赖关系时，被依赖的文件必须在依赖文件前利用script标签引入并执行\n2. js引入文件声明的全局变量等会 __污染全局作用域__ ，如果两个文件的全局变量重名，还会出现报错（甚至出现因为变量共用导致逻辑出错而发现不了的问题）\n3. 维护时， __模块之间的依赖关系隐蔽__ ，直接通过全局变量使用，而不是声明式的\n\n\u003ca id='commonjs'\u003e\u003c/a\u003e\n\n## CommonJS规范  \n表现形式：\n```\n    // utils.js (导出)\n    const log = s=\u003e{ console.log(s) };\n    module.exports={ log };  //exports 是对 module.exports 的引用,注意js对象引用使用（直接对exports赋值无法修改module.exports）\n\n    ------------------文件分割线-----------------\n\n    // index.js\n    const {log} = require('./utils.js');\n    log(\"you see see you\");\n```\n\n#### commonjs解决：  \n1. 声明依赖关系：利用exports和require声明暴露和引入，将模块的依赖关系展示出来\n2. 可避免全局作用域的变量污染：打包完的模块代码在新的函数作用域中，所以可以避免同名变量的全局污染。\nPS：由于js遇到未声明变量的赋值操作会将该变量将被自动作为全局变量声明([点击此查看](https://www.iteye.com/blog/huangqiqing123-1788646))，使用严格模式可以避免这种情况的发生\n\n#### commonjs弊端：  \n1. 当然最主要的弊端是浏览器并不原生支持commonjs模块化  \n2. 对于网上说的网络问题造成的模块引入慢，其实任何模块规范遇到网上模块引入到会有这个问题（从请求到执行很慢，多引用就多请求），所以也不算commonjs的弊端啦  \n\n#### 那么现在前端是怎么用commonjs的呢？：  \n目前前端使用commonjs的路子是：使用webpack等打包工具，在开发时可进使用commonjs，开发完成利用模块化工具会将模块的依赖关系进行梳理优化并将依赖打包到同一个文件中，这样就没有引用的问题了，以这种曲线救国的方法让开发可以使用commonjs进行模块引用。  \n \n这点可以参看webpack的[demo](https://webpack.toobug.net/zh-cn/chapter2/commonjs.html)  \n![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z1up3quqj30b60aumxq.jpg)   \n打包生成文件  \n![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z1vvc9tfj30np0z00xq.jpg)  \n\nps：这也是造成当前前端难以离开webpack等打包工具的尴尬现状的原因之一，但由于es6有了自己的模块导出和引入方法，而且目前浏览器对es6支持很好，所以@pika/web等依赖安装工具出现了。  \n\n回到最开始的问题，@pika/web依赖安装工具做了什么事： \n1. 将commonjs导出的依赖模块进行打包，打包成一个js，并用es6导出语法进行导出  \n2. 将所有生成模块js放入web_modules中  \n而我们就可以直接在js中根据路径引用这些依赖，只要在html中引入根script时加上type=\"module\"属性即可（告知浏览器这是个模块js）    \n\n\n\u003ca id='AMD'\u003e\u003c/a\u003e\n\n## AMD规范  \n非同步加载模块:Asynchronous module definition  \n所以AMD的优势就是可以异步加载模块  \n\nAMD 是 RequireJS 在推广过程中对模块定义的规范化产出   \n\nAMD标准中，定义了下面三个API：   \n1. require([module], callback)  \n2. define(id, [depends], callback)  \n3. require.config()  \n即通过define来定义一个模块，然后使用require来加载一个模块, 使用require.config()指定引用路径。  \n\n使用时在html引入\u003cscript data-main=\"./alert\" src=\"./require.js\"\u003e\u003c/script\u003e，data-main指定根js文件（原理就是遍历script标签，利用dom的getAttribute函数获取标签属性）  \n\nrequire.js实现原理参考：https://www.jianshu.com/p/5a39535909e4  \n\n__关键逻辑__   \n根据执行文件中的引用将对应模块文件利用dom操作将script标签加入html执行，然后将返回的方法进行保存，在使用的时候返回缓存的依赖方法  \n\n\n#### AMD优点：  \n1. 相比传统script标签引入，AMD依赖无需考虑引入顺序，依赖关系也清晰多了  \n2. 采用异步加载，a加载不阻塞页面渲染，b不阻塞下文js执行（用到模块的代码必须放到回调函数里）  \n\n\n\u003ca id='CMD'\u003e\u003c/a\u003e\n\n## CMD规范  \n通用模块定义：Common Module Definition   \nCMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS  \n\nCMD推崇就近依赖，不像AMD在一开始就指明依赖，CMD只有在用到某个模块的时候再去require  \n这样，CMD就可以通过逻辑判断，避免用不到的模块的加载了  \n\n#### CMD优势： \n1. 相比AMD，可以在执行到引入模块的代码时才去加载模块（即按需加载，提升性能） \n\n#### CMD弊端： \n1. 内部引入，依赖关系就不像commonjs和AMD那样明显了\n\n\u003ca id='ES6'\u003e\u003c/a\u003e\n\n## ES6模块化  \n通过 `exprot` 关键字导出模块，使用 `import` 关键字引入模块  \n```\n    // utils.js (导出)\n    const log = s=\u003e{ console.log(s) };\n    export { log }; \n\n    ------------------文件分割线-----------------\n\n    // index.js\n    import { log } from './utils.js'\n    log(\"you see see you\");\n```\n根脚本script标签要添加 type=module 属性来标记来告诉浏览器用es6模块来引入这个脚本  \n\n兼容就浏览器的方法：  \n```\n    \u003cscript type=\"module\" src=\"app.js\"\u003e\u003c/script\u003e\n    \u003cscript nomodule src=\"fallback.js\"\u003e\u003c/script\u003e\n```\n新版浏览器加载第一个 script 标签，忽略第二个；旧版不支持 type=module 的浏览器则忽略第一个，加载第二个。\n\n#### note： \n1. 脚本加载方式默认为 defer，不会因为执行拥塞页面渲染，也支持 async  \n2. 同一模块（url相同，包括后缀参数）用es6引入方法多次引入只执行一次  \n3. 添加type=module的script标签CORS 跨域限制会更严格，如果服务器未返回有效的 Allow-Origin 相关 CORS 头，浏览器会禁止加载改脚本 \n\n#### es6模块化的优势： \n1. 当然当然当然是浏览器的原生支持啦，大部分浏览器以及支持es6模块化语法，查看[can i use](https://caniuse.com/#feat=es6-module)  \n2. 使用es6模块引入的js脚本不会像普通脚本一样污染全局作用域（根层变量不会被声明到window中)  \n\n\n\u003ca id='ES6CMJS'\u003e\u003c/a\u003e\n\n## CommonJs和ES6区别  \n1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用  \n    commonjs在输出时一般这么操作  \n    ```\n    module.exports = {\n      counter: counter1,\n      incCounter: incCounter,\n    };\n    ```\n    module.exposrts.counter是非引用变量赋值来的，所以值和counter1是分离的。  \n    可以使用函数获取来动态获取最新的counter1值  \n    ```\n    module.exports = {\n      get counter() {\n        return counter1\n      },\n      incCounter: incCounter,\n    };\n    ```\n2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口\n\n"},{"path":"_blogs/JS/JS-DOM事件触发机制/README.md","title":"JS-DOM事件触发机制","author":"yrobot","keywords":"DOM,JS,触发,机制,事件","createTime":1535040000000,"createTimeStr":"2018年08月24日","length":3416,"content":"# JS-DOM事件触发机制  \n__本页目录：__   \n[问题的起因](#id1)  \n[事件冒泡](#id2)  \n[事件捕获](#id3)  \n[addEventListener的第三个参数](#id4)  \n[事件捕获先还是事件冒泡先？](#id5)  \n\n---\n\n\u003ca id='id'\u003e\u003c/a\u003e\n\n## 问题的起因\n- 事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。  \n- 考虑下面这段代码，就不写html-\u003ehead,body之类的代码了，自行脑补  \n    ```\n    \u003cdiv id=\"outer\"\u003e\n        \u003cp id=\"inner\"\u003eClick me!\u003c/p\u003e\n    \u003c/div\u003e\n    ```\n- 上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？  \n- 为了解决这个问题微软和网景提出了两种几乎完全相反的概念：__事件冒泡 和 事件捕获__。 \n\n\u003ca id='id2'\u003e\u003c/a\u003e\n\n## 事件冒泡\n- 微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。  \n\n- 因此在事件冒泡的概念下在p元素上发生click事件的顺序应该是 __p -\u003e div -\u003e body -\u003e html -\u003e document__ \n\u003ca id='id3'\u003e\u003c/a\u003e\n\n## 事件捕获\n- 网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。\n\n- 因此在事件捕获的概念下在p元素上发生click事件的顺序应该是 __document -\u003e html -\u003e body -\u003e div -\u003e p__\n\n\u003ca id='id4'\u003e\u003c/a\u003e\n\n## addEventListener的第三个参数\n- 网景 和 微软 曾经的战争还是比较火热的，当时， 网景主张捕获方式，微软主张冒泡方式。后来 w3c 采用折中的方式，平息了战火，制定了统一的标准—— __先捕获再冒泡__。 \n- __document -\u003e html -\u003e body -\u003e div -\u003e p -\u003e div -\u003e body -\u003e html -\u003e document__\n   \naddEventListener的第三个参数就是为冒泡和捕获准备的.   \n\n`element.addEventListener(event, function, useCapture)`\n\n第一个参数`event`是需要绑定的事件(string,例：'click')  \n第二个参数`function`是触发事件后要执行的函数  \n第三个参数`useCapture`默认值是false，表示在事件冒泡阶段调用事件处理函数; 如果参数为true，则表示在事件捕获阶段调用处理函数。  \n \n\u003ca id='id5'\u003e\u003c/a\u003e\n\n## 事件捕获先还是事件冒泡先？\n- 当事件捕获和事件冒泡一起存在的情况，事件又是如何触发呢？  \n \n- 这里记被点击的DOM节点为`target`节点：  \n    1. `document` 往 `target`节点，捕获前进，遇到注册的捕获事件立即触发执行  \n\n    2. 到达`target`节点，触发事件（对于`target`节点上，是先捕获还是先冒泡则捕获事件和冒泡事件的注册顺序，先注册先执行）  \n\n    3. `target`节点 往 `document `方向，冒泡前进，遇到注册的冒泡事件立即触发\n\n- __总结__ :  \n1. 对于非target节点则先执行捕获在执行冒泡  \n2. 对于target节点则是先执行先注册的事件，无论冒泡还是捕获\n\n#### 例子\n```\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003ctitle\u003eTestJSevent\u003c/title\u003e\n    \u003cstyle\u003e\n        #son {\n            width: 100px;\n            height: 100px;\n            background-color: #0f0;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n    \u003cdiv id=\"father\"\u003e\n        \u003cdiv id=\"mather\"\u003e\n            \u003cdiv id=\"son\"\u003e\u003c/div\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cdiv id=\"text\"\u003e\u003c/div\u003e\n    \u003cscript\u003e  \n        var Son = document.getElementById(\"son\");\n        var Father = document.getElementById(\"father\");\n        function Click(Id, Type) {\n            document.getElementById(\"text\").innerHTML += Id + \"  \" + Type + \" clicked  ||   \";\n        }\n        Son.addEventListener(\"click\", function () { Click(\"son\", \"false\") }, false);\n        Son.addEventListener(\"click\", function () { Click(\"son\", \"true\") }, true);\n        Father.addEventListener(\"click\", function () { Click(\"father\", \"true\") }, true);\n        Father.addEventListener(\"click\", function () { Click(\"father\", \"false\") }, false);\n        mather.addEventListener(\"click\", function () { Click(\"mather\", \"true\") }, true);\n        mather.addEventListener(\"click\", function () { Click(\"mather\", \"false\") }, false);  \n    \u003c/script\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n输出：\nfather true clicked || mather true clicked || son false clicked || son true clicked || mather false clicked || father false clicked ||\n\u003cbr\u003e\u003cbr\u003e\n#### IE浏览器兼容  \nIE浏览器对addEventListener兼容性并不算太好，只有IE9以上可以使用。要兼容旧版本的IE浏览器，可以使用IE的attachEvent函数\n\n`object.attachEvent(event, function)`\n\n两个参数与`addEventListener`相似，分别是事件和处理函数，默认是事件冒泡阶段调用处理函数，要注意的是，写事件名时候要加上\"`on`\"前缀（\"`onload`\"、\"`onclick`\"等）。\n\n"},{"path":"_blogs/JS/JS函数与闭包/README.md","title":"JS函数与闭包","author":"yrobot","keywords":"闭包,JS,函数","createTime":1535040000000,"createTimeStr":"2018年08月24日","length":2063,"content":"# JS函数与闭包  \n__本页目录：__   \n[JS函数](#func)  \n[闭包](#bibao)  \n\n\u003ca id='func'\u003e\u003c/a\u003e\n\n## JS函数\n\n#### 1. __js函数的[[scope]]__  \n- 每个javascript函数都是一个对象，对象中有些属性我们可以访问，但有些仅供javascript引擎存取，比如[[scope]]，他就是我们所指的作用域，其中储存了 __运行期上下文的集合__。\n- 可以将[[scope]]理解为函数仓库链，函数寻找变量的时候就根据这个链来查找。  \n\n#### 2. __运行期上下文__  \n- 函数执行前创建的对象（AO=运行期上下文：理解为本函数自带的仓库），用于定义函数运行时的环境。函数被多次调用时，会创建多个运行期上下文。\n- 当函数执行完毕，其运行期上下文引用被自动销毁（只是切断引用，其AO仍然存在，AO只有在没有被函数链接时才被回收）。\n\n#### 3. __运行期上下文如何从内存中销毁__  \n- 当此上下文没有被任何函数链接时，js引擎会自动将其回收。但只要还有函数在引用此上下文（存在闭包的情况），则此上下文不会被回收。\n- 所以只要通过 __将闭包变量设置为等于null__ 解除该函数（以及其上下文）的引用，就等于通知垃圾回收例程将其清除。\n\n#### 4. __函数如何查找变量__  \n- 从[[scope]]作用域链的顶端开始向下查找。即从自身\b的执行器上下文开始找变量，未找到则转向[[scope]]的下一个上下文。 \n\n#### 例子\n- 例1：  \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fukrtxws7nj30jf0o0n3w.jpg)   \n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fukru71y2pj30s30lhqpc.jpg)  \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fukrucycgnj30tl0nekhv.jpg)  \n\n- 例2：  \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fukrw1ajtzj30ki0m2wr1.jpg)  \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fukrw1ajtzj30ki0m2wr1.jpg)  \n\n\u003ca id='bibao'\u003e\u003c/a\u003e\n\n## 闭包 \n- __闭包是指 有权访问另一个函数作用域中的变量 的函数__  \n- 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。所以，在本质上，__闭包就是将函数内部和函数外部连接起来的一座桥梁__。\n```\nfunction createComparisonFunction(propertyName) {\n  return function (object1, object2) {\n    var value1 = object1[propertyName];\n    var value2 = object2[propertyName];\n    if (value1 \u003c value2) {\n      return -1;\n    } else if (value1 \u003e value2) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n}\n\n//创建函数 \nvar compareNames = createComparisonFunction(\"name\");\n\n//调用函数 \nvar result = compareNames({name: \"Nicholas\"}, {name: \"Greg\"});\n\n//解除对匿名函数的引用（以便释放内存）\ncompareNames = null;\n```\n\n#### 闭包作用：\n  1. 实现公有变量  \n  2. 可以做缓存  \n  3. 可以实现封装，属性私有化  \n  4. 模块化开发，防止污染全局变量   \n\n#### 闭包注意点：\n  1. 由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，造成内存泄漏。  \n  2. 作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的后一个值。  \n\n\n"},{"path":"_blogs/JS/JS异步编程/README.md","title":"JS异步编程","author":"yrobot","keywords":"JS,异步,编程","createTime":1535040000000,"createTimeStr":"2018年08月24日","length":4481,"content":"# JS异步编程  \n__本页目录：__   \n[概念学习](#gn)   \n[浏览器线程和Event Loop](#eventLoop)   \n[JS的任务执行机制](#mechanism)   \n[JS异步的理解](#unds)   \n[JS的异步编程实现](#cometrue)   \n[JS异步优化页面卡顿](#better)   \n\n\u003ca id='gn'\u003e\u003c/a\u003e\n\n## 概念学习\n- __并发__：同一时间段有几个程序都处于已经启动到运行完毕之间，并且这几个程序都在同一个处理机上运行，并发的两种关系是同步和互斥；\n\n- __互斥__：进程之间访问临界资源时相互排斥的现象；\n\n- __同步__：进程之间存在依赖关系，一个进程结束的输出作为另一个进程的输入。具有同步关系的一组并发进程之间发送的信息称为消息或者事件；\n\n- __并行__：单处理器中进程被交替执行，表现出一种并发的外部特征；在多处理器中，进程可以交替执行，还能重叠执行，实现并行处理，并行就是同事发生的多个并发事件，具有并发的含义，但并发不一定是并行，也就是说事件之间不一定要同一时刻发生；\n\n- __多线程__：多线程是进程中并发运行的一段代码，能够实现线程之间的切换执行；\n\n- __异步(不按顺序)__：和同步相对，同步是顺序执行，而异步是彼此独立，在等待某个事件的过程中继续做自己的事，不要等待这一事件完成后再工作。线程是实现异步的一个方式，异步是让调用方法的主线程不需要同步等待另一个线程的完成，从而让主线程干其他事情。  \n-- 所谓\"异步\"，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。比如，有一个任务是读取文件进行处理，异步的执行过程就是下面这样。  \n-- 这种不连续的执行，就叫做异步。相应地，连续的执行，就叫做同步。\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fukonjqddzj30t20gs0yu.jpg)\n\n- __异步和多线程__：不是同等关系，异步是目的，多线程只是实现异步的一个手段，实现异步可以采用多线程技术或者交给其他进程来处理。\n\n\u003ca id='eventLoop'\u003e\u003c/a\u003e\n\n## 浏览器线程和Event Loop\n\n- js既然是单线程,那么肯定是排队执行代码，那么怎么去排这个队，就是Event Loop。虽然JS是单线程，但浏览器不是单线程。  \n- 浏览器中分为以下几个线程:\n  1. js线程\n  2. UI线程(浏览器内核)\n  2. 事件线程(onclick,onchange,...)：触发事件发生后，绑定的函数由Event Table移入Event Queue，等待被js主线程调用\n  4. 定时器线程(setTimeout, setInterval)： 确保js定时器和异步触发的准确性\n  3. 异步http请求线程(ajax)  \n  - 其中JS线程和UI线程相互互斥，也就是说，当UI线程在渲染的时候，JS线程会挂起，等待UI线程完成，再执行JS线程\n\n- 名词解析：\n  1. __浏览器事件触发线程__：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JavaScript 的单线程关系所有这些事件都得排队等待 JavaScript 引擎处理；\n  2. __定时触发器线程__：浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案；\n  3. __异步 HTTP 请求线程__：在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理；\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fukonkymdvj30cv08v751.jpg)  \n- 在点击按钮之后，页面卡顿，连续点击按钮时，页面无反应，等到loop运行完时，连续弹出alert。证明 事件线程 独立于 js线程，而同时 UI线程 被挂起。 \n代码：\n```\n\u003cbutton onclick=\"myClick()\"\u003eyep\u003c/button\u003e\n    \u003cscript\u003e\n        let count =0;\n        function myClick(){\n            alert(count++)\n            if(count==1)\n                loop();\n        }\n        function loop(){\n            let i=99999;\n            while(i--){\n                console.log(1);\n            }\n        }\n    \u003c/script\u003e\n``` \n\u003ca id='mechanism'\u003e\u003c/a\u003e\n\n## JS的任务执行机制\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fukopfdw9oj30vk0ugwpy.jpg)  \n__导图要表达的内容用文字来表述的话：__\n- 同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入Event Table并注册函数。\n- 当指定的事情完成时(条件函数完成，绑定的按钮发生点击，请求返回etc)，Event Table会将这个函数移入Event Queue。\n- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。\n- 上述过程会不断重复，也就是常说的Event Loop(事件循环)。\n\n\u003ca id='unds'\u003e\u003c/a\u003e\n\n## JS异步的理解\n\n- 如概念学习里所说的，js异步主要是：对于占用主线程的操作，利用js任务执行机制，将其放入Event Queue中，等待主线程空闲了才执行。 \n\n\u003ca id='cometrue'\u003e\u003c/a\u003e\n\n## JS的异步编程实现\n\nES 6以前：\n  - 定时器(setTimeout, setInterval)\n  - 回调函数\n  - 事件监听(事件发布/订阅)\n  - Promise对象  \n\nES 6：\n  - Generator函数(协程coroutine) \n\nES 7:\n  - async和await\n\n\u003ca id='better'\u003e\u003c/a\u003e\n\n## JS异步优化页面卡顿\n\n__方案1__：针对支持html5 webworker的现代浏览器方案:   \n_代码1._ 你的大量计算，放到一个js文件中。如下：\n```\n//job.js\nonmessage = function (evt){  //do massive job.在这里你进行大量耗时的计算过程。 \n  postMessage( data );//将计算结果的数据发送会主线程\n}\n```\n你的页面代码：\n```\n\u003c!DOCTYPE HTML\u003e\n\u003chtml\u003e\n\n\u003chead\u003e\n    \u003cmeta http-equiv=\"Content-Type\"  content=\"text/html; charset=utf-8\" /\u003e\n    \u003cscript type=\"text/javascript\"\u003e\n        //WEB页主线程var worker =new Worker(\"job.js\"); \n        //创建一个Worker对象并向它传递将在新线程中执行的脚本的URL \n        worker.postMessage('开始计算');\n        worker.onmessage = function (evt) {//接收worker传过来的数据函数   \n            console.log(evt.data);//输出worker发送来的数据，这里就获取到了大量计算的结果。 \n        } \n    \u003c/script\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\u003c/body\u003e\n\n\u003c/html\u003e\n```\n_方案2：_ 对于不支持WebWorker线程的浏览器。\n可以考虑分批处理。即是说创造一个间隔定时器setInterval。  \n每隔一小段时间，处理大量数据中的一部分。  \n这样就可以避免大量计算导致浏览器卡死。  \n大致代码如下(这里是简单的例子，具体情况具体分析)   \n假设我们要计算1000万个数据的和：  \n```\nvar jobData = [];//假设是一个数组。里面有1000万个数据  \nfunction  sliceJob() {\n    var  num  =  (jobData.length  /  100)  +  1;//把任务数据划分为100份。    \n    var  portion  =  100000;//每份有10万个数字。    \n    var  addition  =  0;//这里用来保存最后的结果。一开始是0；    \n    var  intv  =  setInterval(function () {\n            if (num--) {            //然后每一份结果。            \n        additoin  +=  every;\n    }  else  {            //计算最后一份，然后输出结果。            \n        alert('最终结果是:',  addition);\n        window.clearInterval(intv);\n    }\n        },  50);\n}\n```\n此外。jQuery的deferred对象无法实现你的要求。  \n因为deferred对象的目的是为了串行处理异步过程。  \n但是异步过程在执行的过程中，如果耗时过长，仍然会阻塞浏览器线程，导致浏览器不可操作（卡死）。  \n\n---\n\n\n"},{"path":"_blogs/JS/JS的三个定时器/README.md","title":"JS的三个定时器","author":"yrobot","keywords":"JS,定时器,三个","createTime":1535040000000,"createTimeStr":"2018年08月24日","length":4228,"content":"# JS的三个定时器  \n   \n \n\n__本页目录：__   \n[setTimeout](#setTimeout)  \n[setInterval](#setInterval)  \n[requestAnimationFrame](#requestAnimationFrame)  \n[JS动画](#jsAnimation)   \n[推荐使用requestAnimationFrame绘制JS动画](#useAnimation)   \n\n\u003ca id='setTimeout'\u003e\u003c/a\u003e\n\n## setTimeout\n- 在执行时,是在载入后延迟指定时间后执行一次表达式（仅执行一次）  \n\n\u003ca id='setInterval'\u003e\u003c/a\u003e\n\n## setInterval\n- 在执行时,它从载入后,每隔指定的时间就执行一次表达式  \n- 在代码运行到间歇调用和超时调用时，定时器（浏览器中 __独立于js线程的一个线程__）会在相应的时间，将相应的代码放入宏代码队列中，所以不必考虑放代码时，js是否有程序在运行。所以这两个函数只能保证按时将代码放入队列，但具体的执行时间要看队列前的函数执行情况（什么时候轮到放入的函数）。由于这三个函数都是js异步编程的一种实现，所以详情参看[JS异步编程 #浏览器线程和Event Loop](/JS/JS异步编程/README.md#eventLoop)\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fukmxrd5ixj30m409smxx.jpg)\n\n\u003ca id='requestAnimationFrame'\u003e\u003c/a\u003e\n\n## requestAnimationFrame \n- 不能指定延迟时间，而是根据浏览器的刷新频率而定（帧），即浏览器页面刷新一次函数就执行一次，适合实现页面动画  \n\n\u003ca id='jsAnimation'\u003e\u003c/a\u003e\n\n## JS动画\n理解了上面的概念以后，我们不难发现，setTimeout 其实就是通过设置一个间隔时间来不断的改变元素属性，从而达到动画效果的。但我们会发现，利用 seTimeout 实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因：\n1. setTimeout 的执行时间并不是确定的。在JavaScript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，所以 setTimeout 的实际执行时机一般要比其设定的时间晚一些。\n2. 刷新频率受 屏幕分辨率 和 屏幕尺寸 的影响，不同设备的屏幕绘制频率可能会不同，而 setTimeout 只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。  \n\n以上两种情况都会导致 setTimeout 的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。 那为什么步调不一致就会引起丢帧呢？   \n\n首先要明白，setTimeout 的执行只是在内存中对元素属性进行改变，这个变化必须要等到屏幕下次绘制时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素。假设屏幕每隔16.7ms刷新一次，而setTimeout 每隔10ms设置图像向左移动1px， 就会出现如下绘制过程：\n- 第0ms：屏幕未绘制，  等待中，setTimeout 也未执行，等待中；\n- 第10ms：屏幕未绘制，等待中，setTimeout 开始执行并设置元素属性 left=1px；\n- 第16.7ms：屏幕开始绘制，屏幕上的元素向左移动了 1px， setTimeout 未执行，继续等待中；\n- 第20ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=2px;\n- 第30ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=3px;\n- 第33.4ms：屏幕开始绘制，屏幕上的元素向左移动了 3px， setTimeout 未执行，继续等待中；\n- ...  \n\n从上面的绘制过程中可以看出，屏幕没有更新 left=2px 的那一帧画面，元素直接从left=1px 的位置跳到了 left=3px 的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。\n\n\u003ca href=\"\" id=\"useAnimation\"\u003e\u003c/a\u003e\n\n## 推荐使用requestAnimationFrame绘制JS动画 \n与 setTimeout 相比，requestAnimationFrame() 最大的优势是 __由系统来决定回调函数的执行时机__。具体一点讲就是，系统每次绘制之前会主动调用 requestAnimationFrame() 中的回调函数，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms。换句话说就是，requestAnimationFrame() 的执行步伐跟着系统的绘制频率走。它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。\n\n这个API的调用很简单，如下所示：\n```\nvar progress = 0;\n//回调函数\nfunction render() {\n    progress += 1; //修改图像的位置\n \n    if (progress \u003c 100) {\n           //在动画没有结束前，递归渲染\n           window.requestAnimationFrame(render);\n    }\n}\n \n//第一帧渲染\nwindow.requestAnimationFrame(render);\n```\n除此之外，requestAnimationFrame 还有以下两个优势：\n\n1. __PU节能__：使用 setTimeout 实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，而且还浪费 CPU 资源。而 rAF 则完全不同，当页面处理未激活的状态下，该页面的屏幕绘制任务也会被系统暂停，因此跟着系统步伐走的 rAF 也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。\n\n2. __函数节流__：在高频率事件(resize,scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，使用 rAF 可保证每个绘制间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个绘制间隔内函数执行多次时没有意义的，因为显示器每16.7ms 绘制一次，多次绘制并不会在屏幕上体现出来。\n\n\u003ca href=\"\" id=\"suitDown\"\u003e\u003c/a\u003e\n\n## 适配低版本\n以下代码考虑到部分浏览器不支持requestAnimationFrame的情况，对requestAnimationFrame和cancelAnimationFrame进行降级适配。\n```\nif (!Date.now)\n    Date.now = function() { return new Date().getTime(); };\n \n(function() {\n    'use strict';\n     \n    var vendors = ['webkit', 'moz'];\n    for (var i = 0; i \u003c vendors.length \u0026\u0026 !window.requestAnimationFrame; ++i) {\n        var vp = vendors[i];\n        window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];\n        window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame']\n                                   || window[vp+'CancelRequestAnimationFrame']);\n    }\n    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy\n        || !window.requestAnimationFrame || !window.cancelAnimationFrame) {\n        var lastTime = 0;\n        window.requestAnimationFrame = function(callback) {\n            var now = Date.now();\n            var nextTime = Math.max(lastTime + 16, now);\n            return setTimeout(function() { callback(lastTime = nextTime); },\n                              nextTime - now);\n        };\n        window.cancelAnimationFrame = clearTimeout;\n    }\n}());\n```\n---  \n*\b本章节部分参考[一像素 博客](https://www.cnblogs.com/onepixel/p/7078617.html)，在此感谢！*\n\n\n"},{"path":"_blogs/JS/JS多线程WebWorker/README.md","title":"JS多线程Web Worker","author":"yrobot","keywords":"多线程,Worker,JS,Web","createTime":1534953600000,"createTimeStr":"2018年08月23日","length":3983,"content":"# JS多线程Web Worker\n__本页目录：__   \n[为什么使用Web Woker](#why)  \n[Web Woker是什么](#what)  \n[检测浏览器支持](#support)  \n[新建Web Worker](#new)  \n[mainjs与worker之间的数据传递](#message)  \n[主线程中worker的属性](#workerPro)  \n[子线程中的全局属性](#selfPro)  \n[关闭子线程](#close) \n\n\u003ca href=\"\" id=\"why\"\u003e\u003c/a\u003e\n\n## 为什么使用Web Woker  \n核心思想：一些容易阻塞主线程的事情，或者说主线程一个线程完成不了的事情（单页面多连接），可以交给WebWoker\n#### 1. 使用专用线程进行数学运算  \nWeb Worker最简单的应用就是用来做后台计算，而这种计算并不会中断前台用户的操作\n#### 2. 图像处理   \n通过使用从`\u003ccanvas\u003e`或者`\u003cvideo\u003e`元素中获取的数据，可以把图像分割成几个不同的区域并且把它们推送给并行的不同Workers来做计算\n#### 3. 大量数据的检索   \n当需要在调用 ajax后处理大量的数据，如果处理这些数据所需的时间长短非常重要，可以在Web Worker中来做这些，避免冻结UI线程。\n#### 4. 背景数据分析  \n由于在使用Web Worker的时候，我们有更多潜在的CPU可用时间，我们现在可以考虑一下JavaScript中的新应用场景。例如，我们可以想像在不影响UI体验的情况下实时处理用户输入。利用这样一种可能，我们可以想像一个像Word（Office Web Apps 套装）一样的应用：当用户打字时后台在词典中进行查找，帮助用户自动纠错等等。\n\n\u003ca href=\"\" id=\"what\"\u003e\u003c/a\u003e  \n\n## Web Woker是什么  \nWeb Worker 是HTML5标准的一部分，这一规范定义了一套 API，它允许一段JavaScript程序运行在主线程之外的另外一个线程中。Web Worker 规范中定义了两类工作线程，分别是专用线程Dedicated Worker和共享线程 Shared Worker，其中，Dedicated Worker只能为一个页面所使用，而Shared Worker则可以被多个页面所共享。\n\n\u003ca href=\"\" id=\"support\"\u003e\u003c/a\u003e\n\n## 检测浏览器支持  \n```\n//引入modernizr.js的情况\nif(!Modernizr.webworker){\n    alert(\"This browser doesn't support Web Worker!\");\n}  \n\n//未引入modernizr.js的情况\nif(typeof(Worker)!==\"undefined\"){\n    //支持\n}else{\n    //不支持code\n}\n```\n\n\u003ca href=\"\" id=\"new\"\u003e\u003c/a\u003e\n\n## 新建Web Worker  \n`var worker = new Worker(\"task.js\"); //在main.js中new一个woker`\n\n浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。  \n`var myWorker = new Worker(jsUrl, [options]);`\n\nWorker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。\n```\n// 主线程\nvar myWorker = new Worker('worker.js', { name : 'myWorker' });\n\n// Worker 线程\nself.name // myWorker\n```\n\n\u003ca href=\"\" id=\"message\"\u003e\u003c/a\u003e\n\n## mainjs与worker之间的数据传递  \n#### 主线程—send—\u003eworker：  \n```\nworker.postMessage(data);   \n//data可以死各种类型的数据、string、object、array、number。。。  \n//子线程通过监听函数参数e的data属性获取上述data  \n```  \n#### 主线程\u003c—get—worker：  \n```\nworker.onmessage = function (event) {  \n  console.log('Received message ' + event.data);  \n  //相应业务操作  \n}  \n```  \n#### worker—send—\u003e主线程：  \n`self.postMessage(data);  //self指代worker线程全局对象(同this) `  \n\n#### worker\u003c—get—主线程：  \n```\nself.addEventListener('message', function (e) {  \n  console.log('Main data: ' + e.data);  \n}, false);  \n```\n__so：__  \n当主线程或者子线程要传递 命令以及数据 时：可以传递一个对象`{cmd:'go',data:'dt'}`。  \n接收者用`event.data.cmd`和`event.data.data`获取命令和数据。  \n#### 例子：主线程传参 `{cmd:\"\", msg:\"\"}`\n```\nself.addEventListener('message', function (e) {  \n  var data = e.data;  \n  switch (data.cmd) {  \n    case 'start':  \n      self.postMessage('WORKER STARTED: ' + data.msg);  \n      break;  \n    case 'stop':  \n      self.postMessage('WORKER STOPPED: ' + data.msg);  \n      self.close(); // Terminates the worker.  \n      break;  \n    default:  \n      self.postMessage('Unknown command: ' + data.msg);  \n  };  \n}, false);  \n```\n\n\u003ca href=\"\" id=\"workerPro\"\u003e\u003c/a\u003e\n\n## 主线程中worker的属性  \n- Worker.onerror：指定 error 事件的监听函数。  \n- Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。  \n- Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。   \n- Worker.postMessage()：向 Worker 线程发送消息。  \n- Worker.terminate()：立即终止 Worker 线程。  \n\n__子线程的错误监听实例：__   \n```\nworker.onerror(function (event) {\n  console.log([\n    'ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message\n  ].join(''));\n});\n\n// 或者\nworker.addEventListener('error', function (event) {\n  // ...\n});\n```\n\n\n\u003ca href=\"\" id=\"selfPro\"\u003e\u003c/a\u003e\n\n## 子线程中的全局属性  \nWeb Worker 有自己的全局对象，不是主线程的window，而是一个专门为 Worker 定制的全局对象.  \n- self.name：Worker 的名字。该属性只读，由构造函数指定。  \n- self.onmessage：指定message事件的监听函数。  \n- self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。  \n- self.close()：关闭 Worker 线程。  \n- self.postMessage()：向产生这个 Worker 线程发送消息。  \n- __self.importScripts()：加载 JS 脚本。__  \n\n\u003ca href=\"\" id=\"close\"\u003e\u003c/a\u003e\n\n## 关闭子线程  \n```\n// 主线程\nworker.terminate();\n\n// Worker 线程\nself.close();\n```\n---\n\n"}]},{"title":"CSS3","list":[{"path":"_blogs/CSS3/CSS3-3D转换/README.md","title":"CSS3-3D转换","author":"yrobot","keywords":"3D,CSS3,转换","createTime":1535644800000,"createTimeStr":"2018年08月31日","length":5674,"content":"# CSS3-3D转换  \n__本页目录：__    \n[3D\b元素的属性](#id1)  \n- [transform](#id11)\n- [transform-origin](#id12)\n- [transform-style](#id13)\n- [perspective](#id14)\n- [perspective-origin](#id15)  \n- [backface-visibility](#id16)  \n\n[3D元素的方法](#id2)  \n\n__CSS3新增的3D变换属性：__  CSS3 3D 转换支持开发者在css代码中利用css3的3D函数，在页面里开发出一些简单的3D效果。  \n\n__本节内容要点：__  \n- 利用transform改变各个元素位置  \n- 利用transition增加动态效果  \n- 利用perspective属性改变视角  \n\n\n\u003ca href=\"\" id=\"id1\"\u003e\u003c/a\u003e\n\n## 3D\b元素的属性\n\u003ca href=\"\" id=\"id11\"\u003e\u003c/a\u003e\n\n1. __transform__：利用一些方法对元素进行2D或者3D转换。具体\b转换方法参看 [3D元素的方法](#id2)    \n   __语法：__ `transform: none|transform-functions;`  \n   - `none` 定义不进行转换。  \n   - `transform-functions` 使用[3D元素的方法](#id2)  \n  \n\u003ca href=\"\" id=\"id12\"\u003e\u003c/a\u003e\n\n2. __transform-origin__：设置元素坐标系原点的位置，影响到2D、3D的旋转效果    \n   __语法：__ `transform-origin: x-axis y-axis z-axis;`      \n   - x-axis\t定义视图被置于 X 轴的何处。可能的值：  \n    _left_  \n    _center_  \n    _right_  \n    _length_  \n    _%_  \n   - y-axis\t定义视图被置于 Y 轴的何处。可能的值：  \n    _top_  \n    _center_  \n    _bottom_  \n    _length_  \n    _%_  \n   - z-axis\t定义视图被置于 Z 轴的何处。可能的值：  \n    _length_\n\n   __示例：__ `-webkit-transform-origin:20% 40%;\t/* Safari 和 Chrome */`   \n\n   __取值对比：__  1.数字和百分比相对于左上角 2.关键字相对于整个元素  \n   ```\n    top = top center = center top = 50% 0  \n    right = right center = center right = 100%或(100% 50%)  \n    bottom = bottom center = center bottom = 50% 100%  \n    left = left center = center left = 0或(0 50%)   \n    center = center center = 50%或（50% 50%）  \n    top left = left top = 0 0  \n    right top = top right = 100% 0  \n    bottom right = right bottom = 100% 100%  \n    bottom left = left bottom = 0 100%  \n   ```\n   __浏览器支持__  \n  ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fut27g9rczj30v806oabn.jpg)\n  Internet Explorer 10、Firefox、Opera 支持 transform-origin 属性。  \n  Internet Explorer 9 支持替代的 -ms-transform-origin 属性（仅适用于 2D 转换）。  \n  Safari 和 Chrome 支持替代的 -webkit-transform-origin 属性（3D 和 2D 转换）。  \n  Opera 只支持 2D 转换。  \n\n\u003ca href=\"\" id=\"id13\"\u003e\u003c/a\u003e   \n\n3. __transform-style__：规定如何在 3D 空间中呈现被嵌套的元素  \n   __语法：__ `transform-style: flat|preserve-3d;`  \b   \n   - `flat`\t所有子元素在 2D 平面呈现。  \n      沿着X轴或Y轴方向旋转该元素将导致位于正或负Z轴位置的子元素显示在该元素的平面上，而不是它的前面或者后面。著作权归作者所有。  \n   - `preserve-3d`\t子元素将保留其 3D 位置。    \n  \n   __示例：__ `-webkit-transform-style: preserve-3d;\t/* Safari 和 Chrome */`  \n  \n   __浏览器支持__  \n  ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fut2ohsc19j30v006mtae.jpg)\n  Firefox 支持 transform-style 属性。  \n  Chrome、Safari 和 Opera 支持替代的 -webkit-transform-style 属性。 \n   \n\u003ca href=\"\" id=\"id14\"\u003e\u003c/a\u003e\n\n4. __perspective__：perspective 属性定义 3D 元素距视图的距离，以像素计。（改变视角距离）  \n   - 提示：请与 perspective-origin 属性一同使用该属性，这样您就能够改变 3D 元素的底部位置。   \n   \n   __语法：__ `perspective: number|none;`  \n   - `number`\t元素距离视图的距离，以像素计。  \n   - `none`\t默认值。与 0 相同。不设置透视。  \n      \n   __示例：__ \n    ```\n    div\n    {\n    perspective: 500;\n    -webkit-perspective: 500; /* Safari 和 Chrome */\n    }\n    ``` \n    __浏览器支持__  \n  目前浏览器都不支持 perspective 属性。  \n  Chrome 和 Safari 支持替代的 -webkit-perspective 属性。  \n   \n\u003ca href=\"\" id=\"id15\"\u003e\u003c/a\u003e\n\n5. __perspective-origin__：改变 3D 元素的底部位置（改变视角的朝向）  \n   __语法：__ `perspective-origin: x-axis y-axis;` 数字和百分比相对于左上角   \n   - x-axis\t定义视图被置于 X 轴的何处。可能的值：  \n    _left_  \n    _center_  \n    _right_  \n    _length_  \n    _%_  \n   - y-axis\t定义视图被置于 Y 轴的何处。可能的值：  \n    _top_  \n    _center_  \n    _bottom_  \n    _length_  \n    _%_  \n\n   __示例：__ \n   ```\n   div\n    {\n    perspective:150;\n    perspective-origin: 10% 10%;\n    -webkit-perspective:150;\t/* Safari 和 Chrome */\n    -webkit-perspective-origin: 10% 10%;\t/* Safari 和 Chrome */\n    }\n   ```\n   __浏览器支持__  \n  目前浏览器都不支持 perspective-origin 属性。  \n  Chrome 和 Safari 支持替代的 -webkit-perspecitve-origin 属性。  \n\n\u003ca href=\"\" id=\"id16\"\u003e\u003c/a\u003e\n\n6. __backface-visibility__：backface-visibility 属性定义当元素不面向屏幕时是否可见。  \n   __语法：__ `backface-visibility 属性定义当元素不面向屏幕时是否可见。`   \n   - `visible`\t背面是可见的。  \n   - `hidden`\t背面是不可见的。  \n\n   __示例：__   \n   ```\n   div\n    {\n    backface-visibility:hidden;\n    -webkit-backface-visibility:hidden;\t/* Chrome 和 Safari */\n    -moz-backface-visibility:hidden; \t/* Firefox */\n    -ms-backface-visibility:hidden; \t/* Internet Explorer */\n    }\n   ```\n   __浏览器支持__   \n  只有 Internet Explorer 10+ 和 Firefox 支持 backface-visibility 属性。  \n  Opera 15+、Safari 和 Chrome 支持替代的 -webkit-backface-visibility 属性。  \n\u003ca id='id2'\u003e\u003c/a\u003e\n\n## 3D元素的方法  \n__语法：__ `transform: none|transform-functions;` 方法使用应该加`transform:`前缀   \n   - `none`\t定义不进行转换。  \n   - `transform-functions`\t3D变换函数。具体函数及功能如下：  \n      - _matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)_\t定义 3D 转换，使用 16 个值的 4x4 矩阵。  \n      - _translate3d(x,y,z)_\t定义 3D 转化。  \n      - _translateX(x)_\t定义 3D 转化，仅使用用于 X 轴的值。  \n      - _translateY(y)_\t定义 3D 转化，仅使用用于 Y 轴的值。  \n      - _translateZ(z)_\t定义 3D 转化，仅使用用于 Z 轴的值。  \n      - _scale3d(x,y,z)_\t定义 3D 缩放转换。  \n      - _scaleX(x)_\t定义 3D 缩放转换，通过给定一个 X 轴的值。  \n      - _scaleY(y)_\t定义 3D 缩放转换，通过给定一个 Y 轴的值。  \n      - _scaleZ(z)_\t定义 3D 缩放转换，通过给定一个 Z 轴的值。  \n      - _rotate3d(x,y,z,angle)_\t定义 3D 旋转。  \n      - _rotateX(angle)_\t定义沿 X 轴的 3D 旋转。  \n      - _rotateY(angle)_\t定义沿 Y 轴的 3D 旋转。  \n      - _rotateZ(angle)_\t定义沿 Z 轴的 3D 旋转。  \n      - _perspective(n)_\t定义 3D 转换元素的透视视图。  \n  \n__示例：__   \n```\ndiv\n{\ntransform:rotate(7deg);\n-ms-transform:rotate(7deg); \t/* IE 9 */\n-moz-transform:rotate(7deg); \t/* Firefox */\n-webkit-transform:rotate(7deg); /* Safari 和 Chrome */\n-o-transform:rotate(7deg); \t/* Opera */\n}\n```\n\n__浏览器支持__   \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuqf7u1vz0j30u204ot9y.jpg)\nInternet Explorer 10、Firefox、Opera 支持 transform 属性。  \nInternet Explorer 9 支持替代的 -ms-transform 属性（仅适用于 2D 转换）。  \nSafari 和 Chrome 支持替代的 -webkit-transform 属性（3D 和 2D 转换）。  \nOpera 只支持 2D 转换。\n\n"},{"path":"_blogs/CSS3/CSS3-2D转换/README.md","title":"CSS3-2D转换","author":"yrobot","keywords":"2D,CSS3,转换","createTime":1535385600000,"createTimeStr":"2018年08月28日","length":2284,"content":"# CSS3-2D转换  \n__本页目录：__    \n[怎么使用](#id1)  \n- [平移函数translate()](#id11)\n- [旋转函数rotate()](#id12)\n- [缩放函数scale()](#id13)\n- [倾斜函数skew()](#id14)\n- [矩阵操作matrix()](#id15)  \n\n[浏览器支持](#id2)  \n\n__CSS3新增的2D变换属性：__   通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。\n\n\u003ca href=\"\" id=\"id1\"\u003e\u003c/a\u003e\n\n## 怎么使用\n\u003ca href=\"\" id=\"id11\"\u003e\u003c/a\u003e\n\n1. __translate()__：设置元素相对于当前的位置。  \n   __语法：__ `transform: translate(length,length);`  \n   - 设置元素基于当前位置向右向下偏移。\b   \n   - `length` 偏离的距离数据。  \n   __示例：__ `transform: translate(50px,100px);`  \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuockbel15j30ai0euwey.jpg) \n\u003ca href=\"\" id=\"id12\"\u003e\u003c/a\u003e\n\n2. __rotate()__：将元素进行顺时针旋转，旋转中心`transform-origin`进行设置，默认为元素中心  \n   __语法：__ `transform: rotate(rot);`     \n   - `rot` 元素顺时针转动的角度数据。   \n   __示例：__ `transform: rotate(30deg);`   \n   ![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuockq1b1rj308i0aggmc.jpg)\n\u003ca href=\"\" id=\"id13\"\u003e\u003c/a\u003e   \n\n3. __scale()__：使用scale方法来实现文字或图像的缩放处理  \n   __语法：__ `transform: scale(times);`  \b   \n   - `times` 数字，表示相对于当前元素缩放的倍数。可以有两个参数，表示长宽。  \n   __示例：__ `transform: scale(0.5, 2);`   \n   ![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuoclaoa1uj30fa0lqjsf.jpg)\n\u003ca href=\"\" id=\"14\"\u003e\u003c/a\u003e\n\n4. __skew()__：使用skew方法来实现文字或图像的倾斜处理，默认坐标中心在元素中心   \n   __语法：__ `transform: skew(rot);`  \n   - 参数中分布指定水平方向上的倾斜角度与垂直方向上的倾斜角度。第一个围绕X轴，第二个围绕Y轴    \n   - `rot` 一方向的倾斜角度。  \n   __示例：__ `transform: skew(30deg, 30deg);`   \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuocmattrhj30880a4jrw.jpg)\n\u003ca href=\"\" id=\"15\"\u003e\u003c/a\u003e\n\n5. __matrix()__：矩阵操作。matrix() 方法可以把所有 2D 转换方法组合在一起  \n   __语法：__ `transform: matrix(a,b,c,d,e,f);`  \n   - 实际上，这6参数，对应的矩阵如下： _注意书写方向是竖着的\b_   \n     ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuoak0zwuhj304302kq2w.jpg)  \n   - 进行运算：  \n     ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuoaq82zpxj30cm02xwep.jpg)  \n     坐标就从[x,y]变成了[ax+cy+e,bx+dy+f]  \n   - 关于为什么要`3*3`的矩阵？   \n     主要是为了统一用矩阵乘的操作，其实平移只需要`2*2`，为了统一利用`3*3`乘法变相实现加法(平移)效果。具体思想参考计算机图形学    \n   __示例：__ `transform: matrix(1, 0, 0, 1, 30, 30);`根据运算，可以得出此矩阵可以将元素向右下平移[30,30]   \n\n\u003ca id='id2'\u003e\u003c/a\u003e\n\n## 浏览器支持\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuo7z8j9byj318s04s3zs.jpg)  \nChrome 和 Safari 需要前缀 -webkit-  \nInternet Explorer 9 需要前缀 -ms-  \n\n"},{"path":"_blogs/CSS3/CSS3动画/README.md","title":"CSS3动画","author":"yrobot","keywords":"CSS3,动画","createTime":1535385600000,"createTimeStr":"2018年08月28日","length":4452,"content":"# CSS3动画  \n__本页目录：__   \n[怎么使用](#id1)  \n- [定义动画](#id11)\n- [引用动画，设定参数](#id12)  \n\n[浏览器支持](#id3)  \n\n__CSS3新增的动画属性：__  通过CSS3动画，我们能够创建动画，这可以在许多网页中取代动画图片、Flash动画 以及 JavaScript。作为页面切换的交互动画。\n\n__NOTE：__  \n1. \b\b一个元素要使用多个动画时（比如前一秒动画1，后面动画2），可以在css属性中用一个animation表示，动画之间用逗号相隔。例子：`animation: animation1 1s, animation2 1s 1s infinite alternate ;`\n\n\u003ca id='id1'\u003e\u003c/a\u003e\n\n## 怎么使用\n首先用我的话来大致概括一下css3动画的使用流程：\n1. 首先定义一个动画，使用`@keyframes`来定义动画(包括动画名、动画过程状态)\n2. 在一个元素的class中引用刚定义的动画，设定相关参数(动画时长、动画线性、动画延迟、元素开始和结束的状态、动画是否暂停\b)    \n\n这样一个css3动画就被定义和使用了。\n\n\u003ca href=\"\" id=\"id11\"\u003e\u003c/a\u003e\n\n#### 1. 定义动画  \n#### __语法：__   \n- `@keyframes`  @keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能作为动画中某一帧的状态。   \n    __示例：__ 规定一个名叫``myAnimation``的动画   \n    ```\n    @keyframes myAnimation\n    {\n    0%   {background: red;}\n    25%  {background: yellow;}\n    50%  {background: blue;}\n    100% {background: green;}\n    }\n\n    @-moz-keyframes myAnimation /* Firefox */\n    {\n    0%   {background: red;}\n    25%  {background: yellow;}\n    50%  {background: blue;}\n    100% {background: green;}\n    }\n\n    @-webkit-keyframes myAnimation /* Safari 和 Chrome */\n    {\n    0%   {background: red;}\n    25%  {background: yellow;}\n    50%  {background: blue;}\n    100% {background: green;}\n    }\n\n    @-o-keyframes myAnimation /* Opera */\n    {\n    0%   {background: red;}\n    25%  {background: yellow;}\n    50%  {background: blue;}\n    100% {background: green;}\n    }\n    ```  \n\n\u003ca href=\"\" id=\"id12\"\u003e\u003c/a\u003e\n\n#### 2. 引用动画，设定参数  \n在要设定动画的元素class上使用  \n#### __语法：__   \n- `animation`\t所有动画属性的简写属性，除了 animation-play-state 和 animation-fill-mode 属性。  \n    __语法：__ `animation: name duration timing-function delay iteration-count direction;`   \n    语法参数含义参看后面的语法解析。   \n    __示例：__ \n    ```\n    div\n    {\n    animation: myAnimation 5s infinite;\n    -webkit-animation: myAnimation 5s infinite; /* Safari 和 Chrome */\n    }\n    ```   \n- `animation-name`\t要引用 @keyframes 动画的名称。  \n    \n- `animation-duration`\t规定动画完成一个周期所花费的秒或毫秒。默认是 0。\n     \n- `animation-timing-function`\t规定动画的速度曲线。默认是 \"ease\"。  \n    __语法：__ `animation-timing-function: value;`     \n    _linear_：\t动画从头到尾的速度是相同的。  \n    _ease_：\t默认。动画以低速开始，然后加快，在结束前变慢。  \n    _ease-in_：\t动画以低速开始。  \n    _ease-out_：\t动画以低速结束。  \n    _ease-in-out_：\t动画以低速开始和结束。  \n    _cubic-bezier(n,n,n,n)_： 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。   \n    __示例：__   \n    ```\n    /* W3C 和 Opera: */\n    #div1 {animation-timing-function: linear;}\n\n    /* Firefox: */\n    #div1 {-moz-animation-timing-function: linear;}\n\n    /* Safari 和 Chrome: */\n    #div1 {-webkit-animation-timing-function: linear;}\n    ```\n- `animation-delay`\t规定动画何时开始。默认是 0。  \n  \n- `animation-iteration-count`\t规定动画被播放的次数。默认是 1。    \n    __语法：__ `animation-iteration-count: value;`       \n    _n_：\t 定义动画播放次数的数值。  \n    _infinite_：\t规定动画应该无限次播放。    \n    __示例：__   \n    ```\n    div\n    {\n    animation-iteration-count: 3;\n    -webkit-animation-iteration-count: 3; /* Safari 和 Chrome */\n    }\n    ```\n- `animation-direction`\t规定动画是否在下一周期逆向地播放。默认是 \"normal\"。  \n    __语法：__ `animation-direction: normal|alternate;`       \n    _normal_：\t默认值。动画应该正常播放。  \n    _alternate_：\t动画应该轮流反向播放。      \n    __示例：__   \n    ```\n    div\n    {\n    animation-direction: alternate;\n    -webkit-animation-direction: alternate; /* Safari 和 Chrome */\n    }\n    ```\n- `animation-play-state`\t规定动画是否正在运行或暂停。默认是 \"running\"。  \n   __语法：__ `animation-play-state: paused|running;`       \n    _paused_： 规定动画已暂停。  \n    _running_：\t规定动画正在播放。       \n    __示例：__   \n    ```\n    div\n    {\n    animation-play-state: paused;\n    -webkit-animation-play-state: paused; /* Safari 和 Chrome */\n    }\n    ```\n- `animation-fill-mode`\t规定对象动画时间之外的状态。     \n   __语法：__ `animation-fill-mode : none | forwards | backwards | both;`       \n    _none_： 不改变默认行为。   \n    _forwards_： 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。  \n    _backwards_： 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。  \n    _both_： 向前和向后填充模式都被应用。         \n    __示例：__   \n    ```\n    div\n    {\n    animation-fill-mode: forwards;\n    -webkit-animation-fill-mode: forwards; /* Safari 和 Chrome */\n    }\n    ``` \n\n#### __效果：__\n[\b参考W3school的demo](http://www.w3school.com.cn/tiy/t.asp?f=css3_animation4)\n\n\u003ca href=\"\" id=\"id3\"\u003e\u003c/a\u003e\n\n## 浏览器支持\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fupd51aiv4j30u209k76w.jpg)  \nInternet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。  \nChrome 和 Safari 需要前缀 -webkit-。\n\n"},{"path":"_blogs/CSS3/CSS3过渡/README.md","title":"CSS3过渡","author":"yrobot","keywords":"CSS3,过渡","createTime":1535385600000,"createTimeStr":"2018年08月28日","length":1599,"content":"# CSS3过渡  \n__本页目录：__   \n[用前思考](#id1)  \n[怎么使用](#id2)  \n[浏览器支持](#id3)  \n\n__CSS3的过渡属性：__  过渡属性可以设定元素在某些属性改变时，对变化过程填充逐渐变换的动画，类似于flash的补间动画\n\n\u003ca id='id1'\u003e\u003c/a\u003e\n\n## 用前思考\nCSS3 过渡是元素从一种样式逐渐改变为另一种的效果  \n那么我们仔细来分析一下，机器需要哪些数据来控制这个补间动画\n首先我们问问自己，如果别人要求我们来实现一种补间动画，我们会问要求人哪些问题呢？\n1. 是对哪些变化进行\b补间动画效果？- what  \n2. 是怎么变的？补间时长、补间线性(渐入渐出|平滑变化) - how  \n3. \b\b补间是马上就开始吗？ - when  \n\n好了，有了这些的问题，看下面的内容也就顺多了。    \n\n\u003ca id='id2'\u003e\u003c/a\u003e\n\n## 怎么使用  \n#### __语法：__   \n- `transition`  简写属性，用于在一个属性中设置下面\b四个过渡属性。   \n    __示例：__   `transition: width 1s linear 2s;`  \n- `transition-property` all/propertys/none  规定应用过渡的 CSS 属性的名称。propertys间用逗号分隔。\n    __示例：__   `transition-property: width,margin;`  \n- `transition-duration` Number 定义过渡效果花费的时间。默认是 0。  \n- `transition-timing-function`  规定过渡效果的时间曲线。默认是 \"ease\"。  \n_linear_ ： 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。  \n_ease_ ： 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。  \n_ease-in_ ： 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。  \n_ease-out_ ： 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。  \n_ease-in-out_ ： 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。  \n_cubic-bezier(n,n,n,n)_ ： 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。  \n- `transition-delay` 规定过渡效果何时开始。默认是 0。     \n\n#### __效果：__\n[\b参考W3school的demo](http://www.w3school.com.cn/tiy/t.asp?f=css3_transition1)\n\n\u003ca id='id3'\u003e\u003c/a\u003e\n\n## 浏览器支持\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fup7uarmc3j30u204sjsn.jpg)  \nInternet Explorer 10、Firefox、Chrome 以及 Opera 支持 transition 属性。  \nSafari 需要前缀 -webkit-。\n\n"},{"path":"_blogs/CSS3/CSS3新增属性/README.md","title":"CSS3新增属性","author":"yrobot","keywords":"CSS3,属性,新增","createTime":1535299200000,"createTimeStr":"2018年08月27日","length":11420,"content":"# CSS3新增属性  \n__本页目录：__   \n[CSS3 边框](#id1)  \n[CSS3 背景](#id2)  \n[CSS3 文本效果](#id3)  \n[CSS3 字体](#id4)  \n[CSS3 2D 转换](#id5)  \n[CSS3 3D 转换](#id6)  \n[CSS3 过渡](#id7)  \n[CSS3 动画](#id8)  \n[CSS3 多列](#id9)  \n[CSS3 用户界面](#id10)  \n\n本文框架主要参考[W3school的CSS教程](http://www.w3school.com.cn/css3/index.asp)，在此感谢!\n\n\u003ca id='id1'\u003e\u003c/a\u003e\n\n## CSS3 边框\n__CSS3新增的边框属性：__  \n1. __border-radius__：设置元素的圆角，还支持单个圆角设置，`border-top(bottom)-left(right)-radius`。  \n   __语法：__ `border-radius: 1-4 length|% / 1-4 length|%;`  \n   - 按此顺序设置每个 radii 的四个值(类似margin属性设置，\b对边相同可简写)。\b   \n   - `ength` 定义圆角的形状。    \n   - `%` 以百分比定义圆角的形状。  \n   __示例：__ `border-radius:2em;`  \n   __示例：__ `border-radius: 2em 1em 4em 3em;`  \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuocgpiov7j30hg0380su.jpg)  \n2. __box-shadow__：设置元素方框阴影  \n   __语法：__`box-shadow: h-shadow v-shadow blur spread color inset;`   \n   - `h-shadow` 必需。水平阴影的位置。允许负值    \t\n   - `v-shadow` 必需。垂直阴影的位置。允许负值    \n   - `blur` 可选。模糊距离    \n   - `spread` 可选。阴影的尺寸     \n   - `color` 可选。阴影的颜色   \n   - `inset` 可选。将外部阴影 (outset) 改为内部阴影   \n   __示例：__ `box-shadow: 10px 10px 5px #888888;`   \n   ![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuoch950z7j30j007kglk.jpg)  \n3. __border-image__：设置元素的边框为图片   \n   __语法：__   border-image 属性是一个简写属性   \n   - `border-image-source` 用在边框的图片的路径。\t  \n   - `border-image-slice` 图片边框向内偏移。\t  \n   - `border-image-width` 图片边框的宽度。\t  \n   - `border-image-outset` 边框图像区域超出边框的量。\t  \n   - `border-image-repeat` 图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。    \n   __示例：__   `border-image: url(/i/border_image_button.png) 0 14 0 14 stretch;`  \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuochr5fydj30lo04i0tb.jpg)\n\n__浏览器支持：__\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuo2czkkuaj318w0eidkx.jpg)\n\n\u003ca id='id2'\u003e\u003c/a\u003e\n\n## CSS3 背景\n__CSS3新增的背景属性：__  \n1. __background-size__:  规定背景图像的尺寸  \n   __语法：__   `background-size: length|percentage|cover|contain; `  \n   - `length` 设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 \"auto\"。     \n   - `percentage` 以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 \"auto\"。   \n   - __`cover`__ 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。  \n   - __`contain`__ 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。     \n   __示例：__   `border-radius:50%;`  \n2. __background-origin__:  background-origin 属性规定 background-position 属性相对于什么位置来定位  \n   __语法：__   `background-origin: padding-box|border-box|content-box; `    \n   - `padding-box` 背景图像相对于内边距框来定位。\t  \n   - `border-box` 背景图像相对于边框盒来定位。 \t  \n   - `content-box` 背景图像相对于内容框来定位。\t  \n   __示例：__   `background-origin:content-box;`\n\n__浏览器支持：__\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuo7a1mn2mj318w09q77m.jpg)\n\n\u003ca id='id3'\u003e\u003c/a\u003e\n\n## CSS3 文本效果\n__CSS3新增的文本效果属性：__  \n1. __text-shadow__:  text-shadow 属性向文本设置阴影   \n   __语法：__   `text-shadow: h-shadow v-shadow blur color;`  \n   - `h-shadow`\t必需。水平阴影的位置。允许负值。  \n   - `v-shadow`\t必需。垂直阴影的位置。允许负值。   \n   - `blur`\t可选。模糊的距离。  \n   - `color` 可选。阴影的颜色。  \n   __示例：__   `text-shadow:2px 2px 8px #FF0000;`  \n   ![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuocifrqvpj30eo03odgz.jpg)\n2. __word-wrap__:  word-wrap 属性允许长单词或 URL 地址换行到下一行  \n   __语法：__   `word-wrap: normal|break-word;`  \n   - `normal` 只在允许的断字点换行（浏览器保持默认处理）。 \n   - `break-word` 在长单词或 URL 地址内部进行换行。   \n   __示例：__   `word-wrap:break-word;`  \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuocjavfcdj313y0mogpb.jpg)\n\n__浏览器支持：__\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuo7ays4aaj318s09iada.jpg)\n\n\u003ca id='id4'\u003e\u003c/a\u003e\n\n## CSS3 字体\n__CSS3新增的字体属性：__  \n1. __@font-face__:  它允许网页开发者为其网页指定在线字体,便于在后面font-family中调用   \n   __语法：__   \n   ```\n    @font-face {\n    [ font-family: \u003cfamily-name\u003e; ] ||\n    [ src: [ \u003curl\u003e [ format(\u003cstring\u003e#) ]? | \u003cfont-face-name\u003e ]#; ] ||\n    [ unicode-range: \u003curange\u003e#; ] ||\n    [ font-variant: \u003cfont-variant\u003e; ] ||\n    [ font-feature-settings: normal | \u003cfeature-tag-value\u003e#; ] ||\n    [ font-variation-settings: normal | [ \u003cstring\u003e \u003cnumber\u003e] # ||\n    [ font-stretch: \u003cfont-stretch\u003e; ] ||\n    [ font-weight: \u003cweight\u003e; ] ||\n    [ font-style: \u003cstyle\u003e; ]\n    }\n   ```\n   - `font-family` name 必需。规定字体的名称。  \n   - `src` URL 必需。定义字体文件的 URL。  \n   - `font-stretch`  可选。定义如何拉伸字体。默认是 \"normal\"。  \n        normal  \n        condensed  \n        ultra-condensed  \n        extra-condensed  \n        semi-condensed  \n        expanded  \n        semi-expanded  \n        extra-expanded  \n        ultra-expanded  \n   - `font-style`\t可选。定义字体的样式。默认是 \"normal\"。  \n        ormal  \n        italic  \n        oblique  \n   - `font-weight` 可选。定义字体的粗细。默认是 \"normal\"。  \n        normal  \n        bold  \n        100  \n        200  \n        300  \n        400  \n        500  \n        600  \n        700  \n        800  \n        900  \n   - `unicode-range` unicode-range 可选。定义字体支持的 UNICODE 字符范围。默认是 \"U+0-10FFFF\"。    \n   __示例：__   \n   ```\n    @font-face {\n        font-family: \"Bitstream Vera Serif Bold\";\n        src: url(\"http://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf\");\n        }\n    \n    body { font-family: \"Bitstream Vera Serif Bold\", serif }\n   ``` \n\n__浏览器支持：__\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuo7ituu00j318q04odhc.jpg)\n\n\n\u003ca id='id5'\u003e\u003c/a\u003e\n\n## CSS3 2D 转换\n__CSS3新增的2D变换属性：__   通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。\n\n跳转 [CSS3-2D转换/RAEDME.md](../CSS3-2D转换/README.md)\n\n__浏览器支持：__\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuo7z8j9byj318s04s3zs.jpg)  \nChrome 和 Safari 需要前缀 -webkit-  \nInternet Explorer 9 需要前缀 -ms-  \n\n\u003ca id='id6'\u003e\u003c/a\u003e\n\n## CSS3 3D 转换\n__CSS3新增的3D变换属性：__  CSS3 3D 转换支持开发者在css代码中利用css3的3D函数，在页面里开发出一些简单的3D效果。  \n\n跳转 [CSS3-3D转换/RAEDME.md](../CSS3-3D转换/README.md)\n\n__浏览器支持：__\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuqf7u1vz0j30u204ot9y.jpg)\nInternet Explorer 10 和 Firefox 支持 3D 转换。  \nChrome 和 Safari 需要前缀 -webkit-。  \nOpera 仍然不支持 3D 转换（它只支持 2D 转换）。\n\n\u003ca id='id7'\u003e\u003c/a\u003e\n\n## CSS3 过渡\n__CSS3的过渡属性：__  过渡属性可以设定元素在某些属性改变时，对变化过程填充逐渐变换的动画，类似于flash的补间动画  \n\n跳转 [CSS3过渡/RAEDME.md](../CSS3过渡/README.md)\n\n__浏览器支持：__\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fup7uarmc3j30u204sjsn.jpg)\n\n\u003ca id='id8'\u003e\u003c/a\u003e\n\n## CSS3 动画\n__CSS3新增的动画属性：__  通过CSS3动画，我们能够创建动画，这可以在许多网页中取代动画图片、Flash动画 以及 JavaScript。作为页面切换的交互动画。  \n\n跳转 [CSS3动画/RAEDME.md](../CSS3动画/README.md)\n\n__浏览器支持：__\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fupd51aiv4j30u209k76w.jpg)  \nInternet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。  \nChrome 和 Safari 需要前缀 -webkit-。\n\n\n\u003ca id='id9'\u003e\u003c/a\u003e\n\n## CSS3 多列\n__CSS3新增的多列属性：__ 使用css3多列属性，可以将内容\b分成几列，类似报纸中文章的形式。   \n1. __column-count__: 规定元素应该被分隔的列数。  \n   __语法：__   `column-count: number|auto;`  \n   - `number` 元素内容将被划分的最佳列数。   \n   - `auto` 由其他属性决定列数，比如 \"column-width\"。      \n   __示例：__   \n   ```\n    div\n    {\n    -moz-column-count: 3; /* Firefox */\n    -webkit-column-count: 3; /* Safari 和 Chrome */\n    column-count: 3;\n    }\n   ``` \n   ![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuqrbczw9jj30x80d679n.jpg)\n\n2. __column-fill__: 规定如何填充列。  \n   __语法：__   `column-fill: balance|auto;`  \n   - `balance` 对列进行协调。浏览器应对列长度的差异进行最小化处理。   \n   - `auto` 按顺序对列进行填充，列长度会各有不同。      \n   __示例：__   \n   ```\n    div\n    {\n    column-fill:auto;\n    }\n   ``` \n\n3. __column-gap__: 规定列之间的间隔。  \n   __语法：__   `column-gap: length|normal;`  \n   - `length` 把列间的间隔设置为指定的长度。   \n   - `normal` 规定列间间隔为一个常规的间隔。W3C 建议的值是 1em。      \n   __示例：__   \n   ```\n    div\n    {\n    -moz-column-gap:40px; /* Firefox */\n    -webkit-column-gap:40px; /* Safari 和 Chrome */\n    column-gap:40px;\n    }\n   ``` \n   ![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuqrjcfhi9j30xi08wdiy.jpg)\n   \n4. __column-rule__: 设置所有 column-rule-* 属性的简写属性。包括 列之间 的 颜色、样式、宽度    \n   __语法：__   `column-rule: column-rule-width column-rule-style column-rule-color;`  \n   - __`column-rule-width`__\t设置列之间的宽度规则。 \n        - __语法：__   `column-rule-width: thin|medium|thick|length;`   \n        - `thin`\t定义纤细规则。  \n        - `medium`\t定义中等规则。  \n        - `thick`\t定义宽厚规则。    \n        - `length`\t规定规则的宽度。\n   - __`column-rule-style`__\t设置列之间的样式规则。  \n        - __语法：__   `column-rule-style: none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset;`   \n        - `none`\t定义没有规则。\t  \n        - `hidden`\t定义隐藏规则。\t  \n        - `dotted`\t定义点状规则。\t  \n        - `dashed`\t定义虚线规则。\t  \n        - `solid`\t定义实线规则。\t  \n        - `double`\t定义双线规则。\t  \n        - `groove`\t定义 3D grooved 规则。该效果取决于宽度和颜色值。\t  \n        - `ridge`\t定义 3D ridged 规则。该效果取决于宽度和颜色值。\t  \n        - `inset`\t定义 3D inset 规则。该效果取决于宽度和颜色值。\t  \n        - `outset`\t定义 3D outset 规则。该效果取决于宽度和颜色值。\t  \n\n   - __`column-rule-color`__\t设置列之间的颜色规则。   \n        - __语法：__   `column-rule-color: color;`   \n        - `color`\t规定颜色规则。请参阅 [CSS 颜色值](http://www.w3school.com.cn/cssref/css_colors_legal.asp)。  \n  \n   __示例：__   \n   ```\n    div\n    {\n    -moz-column-rule:3px outset #ff0000;\t/* Firefox */\n    -webkit-column-rule:3px outset #ff0000;\t/* Safari and Chrome */\n    column-rule:3px outset #ff0000;\n    }\n   ``` \n   ![](https://ws2.sinaimg.cn/large/006tNbRwgy1fusmomdnszj30xg09mgpn.jpg)\n   \n__浏览器支持：__\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuqqzk5gl6j30u20eewi4.jpg) \nInternet Explorer 10 和 Opera 支持多列属性。  \nFirefox 需要前缀 -moz-。  \nChrome 和 Safari 需要前缀 -webkit-。  \n\n\u003ca id='id10'\u003e\u003c/a\u003e\n\n## CSS3 用户界面\n__CSS3新增的用户界面属性：__ 利用css3的用户界面属性，可以重设元素尺寸、盒尺寸以及轮廓等。  \n\n__先看所有的用户界面属性__   \n- `appearance`\t允许您将元素设置为标准用户界面元素的外观  \n- `box-sizing`\t允许您以确切的方式定义适应某个区域的具体内容。  \n- `icon`\t为创作者提供使用图标化等价物来设置元素样式的能力。  \n- `nav-down`\t规定在使用 arrow-down 导航键时向何处导航。  \n- `nav-index`\t设置元素的 tab 键控制次序。\t  \n- `nav-left`\t规定在使用 arrow-left 导航键时向何处导航。\t  \n- `nav-right`\t规定在使用 arrow-right 导航键时向何处导航。\t  \n- `nav-up`\t规定在使用 arrow-up 导航键时向何处导航。\t  \n- `outline-offset`\t对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。\t  \n- `resize`\t规定是否可由用户对元素的尺寸进行调整。\t  \n\n__\b我这边简单介绍一下 浏览器支持比较好的 几个属性__  \n1. __box-sizing__: 改变css 的 width、height 在盒模型中的指向。  \n   - 因为css默认width指向的是盒模型的内容宽度(图中蓝色部分)，而 整个盒模型的宽度 = padding + border + 内容width，整个盒模型所占据文本流的位置还要包括其margin值。  \n   - 而一般我们所想的，我们设置的width值，应该是 整个\b盒模型的宽度，所以问题就产生了。  \n   - 那么这个`box-sizing`，就是用来解决\bwidth、height 在盒模型中的指向问题的。  \n   ![](https://ws4.sinaimg.cn/large/006tNbRwgy1fusoa0l7n5j30ak0aa74j.jpg)  \n\n   __语法：__   `box-sizing: content-box|border-box|inherit;`  \n   - `content-box` 默认，CSS2.1 规定的宽度高度行为。将width、height指向内容宽度，padding、border不被包括在内。  \n    _width、height指向如下图：_  \n    ![](https://ws3.sinaimg.cn/large/006tNbRwgy1fusob65rl6j30au0aeaam.jpg) \n   - `border-box` width指向 内容宽度+padding+border，内容宽度根据减法自适应。height同理。  \n    _width、height指向如下图：_  \n    ![](https://ws2.sinaimg.cn/large/006tNbRwgy1fusob3mmr2j30au0aeq3i.jpg)\n   - `inherit`   继承 父元素 box-sizing属性的值。  \n   \n   __示例：__   \n   ```\n    div\n    {\n    box-sizing:border-box;\n    -moz-box-sizing:border-box; /* Firefox */\n    -webkit-box-sizing:border-box; /* Safari */\n    }\n   ``` \n   __浏览器支持：__\n    ![](https://ws4.sinaimg.cn/large/006tNbRwgy1fusofkoju7j30vc06oabn.jpg)\n    Internet Explorer、Opera 以及 Chrome 支持 box-sizing 属性。  \n    Firefox 支持替代的 -moz-box-sizing 属性。   \n\n2. __outline-offset__: 此属性对轮廓进行偏移。  \n   __语法：__   `outline-offset: length|inherit;`  \n   - `length`\t轮廓与边框边缘的距离。  \n   - `inherit`\t规定应从父元素继承 outline-offset 属性的值。  \n   \n   __示例：__   \n   ```\n    div\n    {\n    border:2px solid black;\n    outline:2px solid red;\n    outline-offset:15px;\n    }\n   ```  \n   __使用对比：__ _后者为使用了`outline-offset:15px;`_   \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuson2ha9gj30ck07mwev.jpg)\n   ![](https://ws2.sinaimg.cn/large/006tNbRwgy1fusomvlpg6j30cs08ajrs.jpg)  \n   __浏览器支持：__   \n    所有主流浏览器都支持 outline-offset 属性，除了 Internet Explorer。  \n\n__\b其余几个属性只有小部分浏览器支持__   \n[__参看所有转换属性的使用__](http://www.w3school.com.cn/css3/css3_user_interface.asp)  \n\n\n"}]},{"title":"利用","list":[{"path":"_blogs/SPA/react的状态管理/利用react-redux.md","title":"react的状态管理—利用react-redux","author":"yrobot","keywords":"react,redux,状态管理,利用","createTime":1537632000000,"createTimeStr":"2018年09月23日","length":3707,"content":"# react的状态管理—利用react-redux \n__本页目录：__   \n[场景思考](#index)  \n[利用react-redux](#redux)  \n[查看效果](#result)  \n[查看代码](#code)  \n\n\u003ca id='index'\u003e\u003c/a\u003e\n\n## 场景思考\n现在我们用react去写一篇博客  \n博客包含 `标题` 和 `内容`  \n而我期望`标题`和`内容`的颜色可以一键修改  \n\n当然最暴力的实现方式就是利用dom操作去被动的修改  \n但是有没有更优雅更可控的方式呢？  \n\n首先来看看项目的组件树：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg)\n\n那么有什么好的优雅的方式使`Title`和`Content`的颜色保持一致呢？  \n换句话说，怎么更好的管理`Title`和`Content`的状态呢？ \n\n#### 回顾上一节  \n上一节我们使用react自带的 [\b利用context注入](./利用context注入.md) 方法   \n利用react的context去实现状态共享很方便  \n但是react的context还是实验性的，何时会更新无法预知  \n所以为了保证软件的稳定性，我们还是使用react推荐的第三方状态管理redux   \n\n\u003ca id='redux'\u003e\u003c/a\u003e\n\n## 利用react-redux\nredux 是一套专业解决应用状态管理的独立的通用模块\b  \n它不仅可以和react结合，形成react-redux，也可以和vue、angular结合  \n\n__react-redux的作用：__ 类似于\breact的context，\breact-redux在顶层组件利用Provider将store注入，在需要用到状态的组件处用connect函数包裹，从组件的props中获取store  \n\n__react-redux的使用方法：__  \n1. 根据全局数据，将其拆分为多个`reducer`\n2. 对于每个`reducer`分配`state`（`reducers.reducer`）和`action`，处理对应的`action`操作，生成行的`state`\n3. 将`reducer`合并成`reducers`,`reducers`分配传入的`state`和`action`操作到`reducer` \n4. `createStore()`传入`reducers`生成`store`，并用`Provider`将`store`注入顶层组件\n5. 在要引用`store`的组件部分用`connect()`连接，`connect()`会注册监听、将`dispatch()`[默认写入]和`mapStateToProps`的属性写入`props`，当然如果使用`mapDispatchToProps`生成的`action creator`也会写入`props`。\n6. 在组件中通过`props`获取5中写入`props`的数据即可使用。\n7. 通过`dispatch()`的参数会触发`reducers`的`action`操作，从而更新状态  \n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fvlqv6xb3uj30yu0sagqj.jpg)\n\n__react-redux的优势：__ \n1. 相对于react自带的context，react-redux更加稳定成熟，并对性能进行了优化  \n2. 相对于props的状态提升，react-redux更加的方便简洁，整个全局状态也更加清晰   \n\n__老话说的好，杀鸡焉用牛刀，在简单场景直接使用状态提升即可__  \n\n\u003ca id='result'\u003e\u003c/a\u003e\n\n## 查看效果\n1. \n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fvhmmoieh4j31kw0nxdpk.jpg)\n2. \n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fvhmmukgfyj31kw0o2qcy.jpg)\n\n\n\u003ca id='code'\u003e\u003c/a\u003e\n\n## 查看代码\nreducers.js生成全局状态：  \n```\nimport { combineReducers } from 'redux'\n\nconst mainColor = (state = 'black',action)=\u003e{\n    switch (action.type){\n        case 'CHANGE_COLOR':\n            state = action.color;\n            return state;\n        default:\n            return state;\n    }\n}\n\nexport default combineReducers({\n    mainColor,\n})\n```\n\nBlogPage.js中\b生成store，并利用Provider注入顶层组件：\n```\nimport reducers from './reducers.js'\n\nconst store = createStore(reducers);\n\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n        }\n    }\n    render() {\n        return (\n            \u003cProvider store = {store}\u003e\n                \u003cdiv className =\"blogContainer\"\u003e\n                    \u003cHeader \u003e\u003c/Header\u003e\n                    \u003cMain\u003e\u003c/Main\u003e\n                \u003c/div\u003e\n            \u003c/Provider\u003e\n        );\n    }\n}\n\nexport default BlogPage;\n```\n\nContent.js中利用connect()函数将状态写入组件props：  \n```\nclass Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    render() {\n        const {mainColor,changeMainColor} = this.props;\n        return (\n            \u003cdiv className=\"content\" style={{ color: mainColor }}\u003e\n                内容...\n                \u003cdiv className=\"button\" onClick={() =\u003e { changeMainColor('#' + (Math.random() * 0xffffff \u003c\u003c 0).toString(16)) }}\u003e切换颜色\u003c/div\u003e\n            \u003c/div\u003e\n\n        );\n    }\n}\n\nconst mapStateToProps = state =\u003e ({  //引入状态到props，并注册监听变化\n    mainColor: state.mainColor\n})\n\nconst mapDispatchToProps = dispatch =\u003e ({ //引入方法到props\n    changeMainColor: color =\u003e {\n        dispatch({\n            type:'CHANGE_COLOR',\n            color,\n        })\n    }\n})\n\nexport default connect(  //绑定组件 //高阶组件:函数接受一个组件作为参数，并返回一个新的组件\n    mapStateToProps,\n    mapDispatchToProps\n)(Content);\n```\n\n\n"},{"path":"_blogs/SPA/react的状态管理/利用context注入.md","title":"react的状态管理—利用context注入","author":"yrobot","keywords":"context,状态管理,react,注入,利用","createTime":1537545600000,"createTimeStr":"2018年09月22日","length":3544,"content":"# react的状态管理—利用context注入  \n__本页目录：__   \n[场景思考](#index)  \n[利用context注入](#context)  \n[查看效果](#result)  \n[查看代码](#code)  \n\n\u003ca id='index'\u003e\u003c/a\u003e\n\n## 场景思考\n现在我们用react去写一篇博客  \n博客包含 `标题` 和 `内容`  \n而我期望`标题`和`内容`的颜色可以一键修改  \n\n当然最暴力的实现方式就是利用dom操作去被动的修改  \n但是有没有更优雅更可控的方式呢？  \n\n首先来看看项目的组件树：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg)\n\n那么有什么好的优雅的方式使`Title`和`Content`的颜色保持一致呢？  \n换句话说，怎么更好的管理`Title`和`Content`的状态呢？ \n\n#### 回顾上一节  \n上一节我们使用最基础的[props状态提升](./利用props状态提升.md)的方法   \n但当组件链很长的时候，新增一个状态就必须修改每个组件的props  \n那有没有跟直接的方法，搞一个共享状态，每个组件可以自由访问呢  \nreact自带的context就是用来实现这一点的  \n\n\u003ca id='context'\u003e\u003c/a\u003e\n\n## 利用context注入\nreact的context可以代替props的传递工作  \n\n__context的作用：__ 将顶部\b组件的状态和方法与子组件共享  \n\n__context的使用方法：__  \n1. 利用`React.createContext()`生成一对`{Provider,Consumer}`  \n2. 用生成的`Provider`包裹\b顶部组件，利用他props的value字段传入共享状态与方法  \n   ```\n    \u003cProvider value={{状态和方法}}\u003e\n        \u003c顶层组件\u003e\n    \u003c/Provider\u003e\n   ```\n3. 用生成的`Consumer`包裹使用共享状态的组件，在Consumer内子组件外用函数传入共享的状态  \n   ```\n    \u003cConsumer\u003e\n        {value =\u003e (\n            \u003c子组件 使用value\u003e\n        )}\n    \u003c/Consumer\u003e\n   ```\n4. 保证状态位于顶层组件的`state`中，而共享的方法要更新状态也是利用`setState`，这样UI层才会刷新  \n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fvhm1xim52j30yg0pqads.jpg)\n\n__context的优势：__ \n1. 只需要在顶层组件和用到状态的子组件进行操作，省去了props状态提升中对中间组件的数据传递操作。代码更清晰。   \n2. 无需引入第三方状态管理，学习成本也相对较低  \n\n__尽管context相对于props状态提升方便很多，\b但是react官网还是 _不建议_ 使用context，因为context的API是实验性的，在未来的react版本中会被修改。__  \n\n__在简单场景,推荐使用props状态提升__  \n__在较复杂的场景，应该考虑引入第三方状态管理(如Redux、Mobx)__  \n\n\u003ca id='result'\u003e\u003c/a\u003e\n\n## 查看效果\n1. \n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fvhmmoieh4j31kw0nxdpk.jpg)\n2. \n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fvhmmukgfyj31kw0o2qcy.jpg)\n\n\n\n\u003ca id='code'\u003e\u003c/a\u003e\n\n## 查看代码\nmainColorContext.js暴露React.createContext：  \n```\nimport React from 'react';\n\nexport const mainColorContext = React.createContext(\n    {\n        mainColor:'black'\n    } // 默认值\n);\n```\n\nBlogPage.js中引入mainColorContext，定义全局状态mainColor和方法changeMainColor()并传入Provider： \n```\nimport {mainColorContext} from './mainColorContext.js'\n\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            mainColor: 'black'\n        }\n    }\n    changeMainColor = (color) =\u003e {\n        this.setState({ //this的绑定//运行时//但是箭头函数没有this//直接沿着作用域链往上找找到BlogPage类的this //换成function就不行了，obj.func()会修改this指向为obj\n            mainColor: color\n        })\n    }\n    render() {\n        const { mainColor } = this.state;\n        return (\n            \u003cmainColorContext.Provider value={{mainColor,changeMainColor:this.changeMainColor}}\u003e\n                \u003cdiv className=\"blogContainer\"\u003e\n                    \u003cHeader \u003e\u003c/Header\u003e\n                    \u003cMain\u003e\u003c/Main\u003e\n                \u003c/div\u003e\n            \u003c/mainColorContext.Provider\u003e\n        );\n    }\n}\n```\nContent.js组件中获取使用Consumer传递的数据和方法：\n```\nimport {mainColorContext} from '../../BlogPage/mainColorContext.js'\n\nclass Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    render() {\n        return (\n            \u003cmainColorContext.Consumer\u003e\n                {value =\u003e (\n                    \u003cdiv className=\"content\" style={{ color: value.mainColor }}\u003e\n                        文本...\n                    \u003cdiv className=\"button\" onClick={()=\u003e{value.changeMainColor('#' + (Math.random() * 0xffffff \u003c\u003c 0).toString(16))}}\u003e切换颜色\u003c/div\u003e\n                    \u003c/div\u003e\n                )}\n            \u003c/mainColorContext.Consumer\u003e\n\n        );\n    }\n}\n```\n\n\n"},{"path":"_blogs/SPA/react的状态管理/利用props状态提升.md","title":"react的状态管理—利用props状态提升","author":"yrobot","keywords":"状态管理,props,react,状态,提升,利用","createTime":1537200000000,"createTimeStr":"2018年09月18日","length":2494,"content":"# react的状态管理—利用props状态提升  \n__本页目录：__   \n[场景思考](#index)  \n[利用props状态提升](#props)  \n[查看效果](#result)  \n[查看代码](#code)  \n\n\u003ca id='index'\u003e\u003c/a\u003e\n\n## 场景思考\n现在我们用react去写一篇博客  \n博客包含 `标题` 和 `内容`  \n而我期望`标题`和`内容`的颜色可以一键修改  \n\n当然最暴力的实现方式就是利用dom操作去被动的修改  \n但是有没有更优雅更可控的方式呢？  \n\n首先来看看项目的组件树：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg)\n\n那么有什么好的优雅的方式使`Title`和`Content`的颜色保持一致呢？  \n换句话说，怎么更好的管理`Title`和`Content`的状态呢？  \n\n\n\u003ca id='props'\u003e\u003c/a\u003e\n\n## 利用props状态提升\n学习了react，就知道组件间数据交互最普遍的方式就是利用props传递  \n而目我们要做的就是Title和Content引用的是同一个颜色变量，而且在变量改变时组件自动重新渲染  \n利用react最基础的方法就是利用状态提升:  \n把一些共享的状态放在最顶端的组件中，子组件通过props去访问和修改这些状态  \n\n本场景中需要共享的状态只有一个`mainColor`和一个修改mainColor的函数`changeMainColor()`  \n具体流程如下图：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvexnc4cbcj30ss0poacx.jpg)\n\b可以看到，需要在content和title中用mainColor，需要通过组件props层层传递到需要用状态的组件，函数也是同理  \n\n\u003ca id='result'\u003e\u003c/a\u003e\n\n## 查看效果\n1. \n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fvey3e0sw6j31kw0lmdoe.jpg)\n2. \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvey3n6qu4j31kw0n1aju.jpg)\n3. \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fvey3xqxwpj31kw0nntin.jpg)\n\n\n\u003ca id='code'\u003e\u003c/a\u003e\n\n## 查看代码\n\nBlogPage中定义全局状态mainColor和方法changeMainColor()并传递： \n```\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            mainColor: 'black'\n        }\n    }\n    changeMainColor = (color) =\u003e {\n        this.setState({\n            mainColor: color\n        })\n    }\n    render() {\n        const { mainColor } = this.state;\n        return (\n            \u003cdiv className=\"blogContainer\"\u003e\n                \u003cHeader mainColor={mainColor}\u003e\u003c/Header\u003e\n                \u003cMain mainColor={mainColor} changeMainColor={this.changeMainColor}\u003e\u003c/Main\u003e\n            \u003c/div\u003e\n        );\n    }\n}\n```\nContent组件中使用props传递的数据和方法：\n```\nclass Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    randomColor = () =\u003e {\n        this.props.changeMainColor('#' + (Math.random() * 0xffffff \u003c\u003c 0).toString(16));\n    }\n    render() {\n        const {mainColor}=this.props;\n        return (\n            \u003cdiv className=\"content\" style={{color:mainColor}}\u003e\n                内容...\n                \u003cdiv className=\"button\" onClick={this.randomColor}\u003e切换颜色\u003c/div\u003e\n            \u003c/div\u003e\n        );\n    }\n}\n```\n\n\n--- \n*\b本章节部分参考[React.js 小书](http://huziketang.mangojuice.top/books/react/lesson29)，在此感谢！*\n\n\n"},{"path":"_blogs/HTML\u0026CSS/利用css绘制多边形/README.md","title":"利用css绘制多边形","author":"yrobot","keywords":"css,多边形,绘制,利用","createTime":1535904000000,"createTimeStr":"2018年09月03日","length":7151,"content":"# 利用css绘制多边形  \n本文主要讲解内容：  \n1. css绘制多边形的原理(一定要理解)  \n2. 一些简单多边形的绘制示例  \n\n__本页目录：__   \n[css绘制多边形的原理](#id1)  \n- [首先我们要知道css盒模型是什么样的](#id11)\n- [然后我们还要理解border](#id12)\n- [还要会用css伪元素](#id13)\n\n[css绘制正四边形](#id2)  \n[css绘制非正四边形](#id3)  \n[css绘制三角形](#id4)  \n[css绘制圆形](#id5)  \n[css绘制梯形](#id6)  \n[css绘制正五边形](#id7)  \n[css绘制正七边形](#id8)  \n\n\u003ca id='id1'\u003e\u003c/a\u003e\n\n## css绘制多边形的原理\n\n\u003ca href=\"\" id=\"id11\"\u003e\u003c/a\u003e\n\n### __首先我们要知道css盒模型是什么样的__  \n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuw4xid010j30a809aq38.jpg)  \n所谓的盒模型，可以理解为元素的表现内容，看上图可以发现：  \n```\n盒模型 = 内容 + padding + border + margin    \n```\n组成理解(_简单介绍_ )：  \n`内容` 元素内 文本、内元素 所包含的区域  \n`padding` \b 内容 与 border 之间的距离，用于处理border和内容的表现关系  \n`border`  边框，将内容包围的轮廓  \n`margin`  元素 与 其他元素之间的距离，用于处理元素间的表现关系，位置样式  \n\n一般理解的 元素 由 内容、padding、border 组成，因为这3个影响到元素的表现样式。  \ncss2中`width`的默认指向是内容宽度，而不是元素(包括padding、border)的宽度。  \n\b可以 利用 `box-sizing` 去修改width的指向：  \n- `box-sizing: content-box;` width、height指向内容  \n    ![](https://ws2.sinaimg.cn/large/0069RVTdgy1fuw5olkw8wj303o010mx2.jpg)\n- `box-sizing: border-box;` width、height指向一般元素  \n    ![](https://ws1.sinaimg.cn/large/0069RVTdgy1fuw5p6zb80j305q04wdgb.jpg)\n\n看下结果：_语言:stylus_    \n```\n.boxsize1\n    width 100px\n    height 80px\n    background-color #393\n    border 20px solid #999\n.boxsize2\n    width 100px\n    height 80px\n    background-color #393\n    border 20px solid #999\n    box-sizing border-box  //默认元素宽高指定，内容宽高自适应\n```\n![](https://ws4.sinaimg.cn/large/0069RVTdgy1fuw6rtydjoj30ci0egweo.jpg)  \n\n本章我们就要利用元素的表现样式(内容、padding、border  )进行图形绘制  \n\u003ca href=\"\" id=\"id12\"\u003e\u003c/a\u003e\n\n### __然后我们还要理解border__  \n我们先来看一段有趣的代码：  \n```\n.square1 {\n  width: 0px;\n  height: 0px;\n  border-width: 40px 50px;\n  border-style: solid;\n  border-color: #f00 #008000 #808080 #00f;\n}\n```\n想想一下，这段代码的渲染效果是什么样的?  \ncss是怎么处理border重叠的部分的？ \n好了，想清楚了，就来看一下结果吧。  \n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuw65nqy85j309001u0sr.jpg)  \n![](https://ws4.sinaimg.cn/large/0069RVTdgy1fuw60spn4lj306i05g0sm.jpg)  \n他的盒模型：  \n![](https://ws4.sinaimg.cn/large/0069RVTdgy1fuw62e6752j307y05umxa.jpg)  \n可以得出规律：\n1. border的长 = 盒模型对应的长或宽  \n2. 相邻方向border冲突时，进行等比均分。 \n\n在接下来的很多例子中都会用到border的这个规律  \n\u003ca href=\"\" id=\"id13\"\u003e\u003c/a\u003e\n\n### __还要会用css伪元素__ \n__css的伪元素：__ 之所以被称为伪元素，是因为他们不是真正的页面元素，html没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的css样式，表面上看上去貌似是页面的某些元素来展现，实际上是css样式展现的行为，因此被称为伪元素。   \n\n我们在绘制图形发现需要进行元素组装时，就可以利用伪元素 来减少对HTML元素的使用。 \n \n[css伪元素的用法](https://www.cnblogs.com/wonyun/p/5807191.html)\n\n\u003ca id='id2'\u003e\u003c/a\u003e\n\n## css绘制正四边形\n绘制正四边形最简单的方法就是利用内容，直接使用width、height  \n```\n.square2 {\n  width: 80px;\n  height: 80px;\n  background-color: #393;\n}\n```\n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuw6wmpdi1j309w092q31.jpg)\n\n当然利用border也可以  \n```\n.square3 {\n  width: 0px;\n  height: 0px;\n  border-width: 40px;\n  border-style: solid;\n  border-color: #008000;\n}\n```\n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuw6ypx233j30a208s74d.jpg)\n\n\u003ca id='id3'\u003e\u003c/a\u003e\n\n## css绘制非正四边形\n#### 绘制平行四边形  \n平行四边形利用[css3的倾斜函数skew()](/CSS3/CSS3-2D转换/README.md#14)比较方便  \n```\n.parallelogram {\n  width: 100px;\n  height: 80px;\n  background: #393;\n  -webkit-transform: skew(-30deg);\n  -moz-transform: skew(-30deg);\n  -o-transform: skew(-30deg);\n  transform: skew(-30deg);\n}\n```\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fuw79w9e6dj30bk08cweo.jpg)   \n\n当然使用 `border` + `:after`伪类也是可以的  \n```\n.parallelogram2 {\n  width: 0px;\n  height: 0px;\n  border-bottom: 80px solid #393;\n  border-left: 80px solid transparent;\n}\n.parallelogram2:after {\n  display: block;\n  content: '';\n  width: 0px;\n  height: 0px;\n  border-top: 80px solid #393;\n  border-right: 80px solid transparent;\n}\n```\n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuw7opf0mhj30bq06qwee.jpg)  \n\n#### 绘制菱形  \n思路：绘制两个等边三角形，进行拼接（`height = sqr(3)*width/2`）\n```\n.rhombus {\n  width: 0px;\n  height: 0px;\n  border-bottom: 69.3px solid #393;\n  border-left: 40px solid transparent;\n  border-right: 40px solid transparent;\n}\n.rhombus:after {\n  display: block;\n  content: '';\n  width: 0px;\n  width: 0px;\n  border-top: 69.3px solid #393;\n  border-left: 40px solid transparent;\n  border-right: 40px solid transparent;\n}\n```\n![](https://ws4.sinaimg.cn/large/0069RVTdgy1fuwb07zx8zj308605o748.jpg)\n\n\u003ca id='id4'\u003e\u003c/a\u003e\n\n## css绘制三角形 \n#### 绘制直角三角形  \n```\n.rightTriangle\n    width 0px\n    height 0px\n    border-bottom 80px solid #393 \n    border-left 80px solid transparent\n```\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fuwcpx6dhfj306s06aa9x.jpg)  \n\n#### 绘制等边三角形  \n等边三角形的宽高比为 1 : sqr(3)/2  \n所以\b可以根据底边长计算三角形高`height = sqr(3)*width/2`  \n本例中左右border宽为40，所以底边长为80，从而计算出底部border宽应为69.3  \n```\n.triangle\n    width 0px\n    height 0px\n    border-bottom 69.3px solid #393 \n    border-left 40px solid transparent\n    border-right 40px solid transparent\n```\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fuwb2kyyzqj306g064746.jpg)\n\n\u003ca id='id5'\u003e\u003c/a\u003e\n\n## css绘制圆形 \n圆形最简单的方式就是设置`border-radius`为50%  \n```\n.circle1\n    width 80px\n    height 80px\n    border-radius 50%\n    background-color #393\n```\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fuwcsqggv5j306c068a9z.jpg)\n\n也可以使用border实现  \n```\n.circle2\n    width 0px\n    height 0px\n    border 40px solid #393 \n    border-radius 50%\n```\n\n\b哎？猜猜这时候设置padding是什么样子的\n```\n.circle3\n    width 0px\n    height 0px\n    border 40px solid #393 \n    border-radius 50%\n    padding 20px\n```\n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuwcyjhdw6j308408874b.jpg)  \n看来border-radius把内外角度都设置了 \n\n\u003ca id='id6'\u003e\u003c/a\u003e\n\n## css绘制梯形 \n```\n.trapezoid\n    width 40px\n    height 0px\n    border-top 40px solid #393 \n    border-left 20px solid transparent\n    border-right 20px solid transparent\n```\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fuwd59x6bsj306w04gwec.jpg)\n\n\u003ca id='id7'\u003e\u003c/a\u003e\n\n## css绘制正五边形 \n正五边形可以拆分成上下两个部分：上边一个等腰三角形，下面一个等腰梯形，具体长宽计算这里不做介绍  \n```\n.pentagon {\n  width: 0px;\n  height: 0px;\n  border-top: 0px;\n  border-right: 81px solid transparent;\n  border-left: 81px solid transparent;\n  border-bottom: 59px solid #393;\n}\n.pentagon:after {\n  position: relative;\n  left: -81px;\n  top: 59px;\n  display: block;\n  content: '';\n  width: 100px;\n  height: 0px;\n  border-top: 95px solid #393;\n  border-left: 31px solid transparent;\n  border-right: 31px solid transparent;\n}\n```\n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuwdlbgoi3j30be0a8t8r.jpg)\n\n\u003ca id='id8'\u003e\u003c/a\u003e\n\n## css绘制正七边形 \n正七边形比较复杂，需要将整个图形分成3份来做  \n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fuwdo5l0qrj307s07974m.jpg)  \n上：等腰三角形  \n中：等腰梯形  \n下：等腰梯形  \n```\n.heptagon {\n  height: 0px;\n  width: 180px;\n  border-left: 22px solid transparent;\n  border-right: 22px solid transparent;\n  border-bottom: 97px solid #393;\n  margin-top: 63px;\n}\n.heptagon:before {\n  display: block;\n  content: '';\n  width: 0px;\n  height: 0px;\n  border-right: 90px solid transparent;\n  border-left: 90px solid transparent;\n  border-bottom: 43px solid #393;\n  position: relative;\n  top: -43px;\n}\n.heptagon:after {\n  width: 100px;\n  height: 0px;\n  content: '';\n  display: block;\n  border-top: 78px solid #393;\n  border-left: 62px solid transparent;\n  border-right: 62px solid transparent;\n  position: relative;\n  left: -22px;\n  bottom: -54px;\n}\n```\n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuwe4xtv6lj30ec0dowen.jpg)\n"}]},{"title":"属性","list":[{"path":"_blogs/CSS3/CSS3新增属性/README.md","title":"CSS3新增属性","author":"yrobot","keywords":"CSS3,属性,新增","createTime":1535299200000,"createTimeStr":"2018年08月27日","length":11420,"content":"# CSS3新增属性  \n__本页目录：__   \n[CSS3 边框](#id1)  \n[CSS3 背景](#id2)  \n[CSS3 文本效果](#id3)  \n[CSS3 字体](#id4)  \n[CSS3 2D 转换](#id5)  \n[CSS3 3D 转换](#id6)  \n[CSS3 过渡](#id7)  \n[CSS3 动画](#id8)  \n[CSS3 多列](#id9)  \n[CSS3 用户界面](#id10)  \n\n本文框架主要参考[W3school的CSS教程](http://www.w3school.com.cn/css3/index.asp)，在此感谢!\n\n\u003ca id='id1'\u003e\u003c/a\u003e\n\n## CSS3 边框\n__CSS3新增的边框属性：__  \n1. __border-radius__：设置元素的圆角，还支持单个圆角设置，`border-top(bottom)-left(right)-radius`。  \n   __语法：__ `border-radius: 1-4 length|% / 1-4 length|%;`  \n   - 按此顺序设置每个 radii 的四个值(类似margin属性设置，\b对边相同可简写)。\b   \n   - `ength` 定义圆角的形状。    \n   - `%` 以百分比定义圆角的形状。  \n   __示例：__ `border-radius:2em;`  \n   __示例：__ `border-radius: 2em 1em 4em 3em;`  \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuocgpiov7j30hg0380su.jpg)  \n2. __box-shadow__：设置元素方框阴影  \n   __语法：__`box-shadow: h-shadow v-shadow blur spread color inset;`   \n   - `h-shadow` 必需。水平阴影的位置。允许负值    \t\n   - `v-shadow` 必需。垂直阴影的位置。允许负值    \n   - `blur` 可选。模糊距离    \n   - `spread` 可选。阴影的尺寸     \n   - `color` 可选。阴影的颜色   \n   - `inset` 可选。将外部阴影 (outset) 改为内部阴影   \n   __示例：__ `box-shadow: 10px 10px 5px #888888;`   \n   ![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuoch950z7j30j007kglk.jpg)  \n3. __border-image__：设置元素的边框为图片   \n   __语法：__   border-image 属性是一个简写属性   \n   - `border-image-source` 用在边框的图片的路径。\t  \n   - `border-image-slice` 图片边框向内偏移。\t  \n   - `border-image-width` 图片边框的宽度。\t  \n   - `border-image-outset` 边框图像区域超出边框的量。\t  \n   - `border-image-repeat` 图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。    \n   __示例：__   `border-image: url(/i/border_image_button.png) 0 14 0 14 stretch;`  \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuochr5fydj30lo04i0tb.jpg)\n\n__浏览器支持：__\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuo2czkkuaj318w0eidkx.jpg)\n\n\u003ca id='id2'\u003e\u003c/a\u003e\n\n## CSS3 背景\n__CSS3新增的背景属性：__  \n1. __background-size__:  规定背景图像的尺寸  \n   __语法：__   `background-size: length|percentage|cover|contain; `  \n   - `length` 设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 \"auto\"。     \n   - `percentage` 以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 \"auto\"。   \n   - __`cover`__ 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。  \n   - __`contain`__ 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。     \n   __示例：__   `border-radius:50%;`  \n2. __background-origin__:  background-origin 属性规定 background-position 属性相对于什么位置来定位  \n   __语法：__   `background-origin: padding-box|border-box|content-box; `    \n   - `padding-box` 背景图像相对于内边距框来定位。\t  \n   - `border-box` 背景图像相对于边框盒来定位。 \t  \n   - `content-box` 背景图像相对于内容框来定位。\t  \n   __示例：__   `background-origin:content-box;`\n\n__浏览器支持：__\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuo7a1mn2mj318w09q77m.jpg)\n\n\u003ca id='id3'\u003e\u003c/a\u003e\n\n## CSS3 文本效果\n__CSS3新增的文本效果属性：__  \n1. __text-shadow__:  text-shadow 属性向文本设置阴影   \n   __语法：__   `text-shadow: h-shadow v-shadow blur color;`  \n   - `h-shadow`\t必需。水平阴影的位置。允许负值。  \n   - `v-shadow`\t必需。垂直阴影的位置。允许负值。   \n   - `blur`\t可选。模糊的距离。  \n   - `color` 可选。阴影的颜色。  \n   __示例：__   `text-shadow:2px 2px 8px #FF0000;`  \n   ![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuocifrqvpj30eo03odgz.jpg)\n2. __word-wrap__:  word-wrap 属性允许长单词或 URL 地址换行到下一行  \n   __语法：__   `word-wrap: normal|break-word;`  \n   - `normal` 只在允许的断字点换行（浏览器保持默认处理）。 \n   - `break-word` 在长单词或 URL 地址内部进行换行。   \n   __示例：__   `word-wrap:break-word;`  \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuocjavfcdj313y0mogpb.jpg)\n\n__浏览器支持：__\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuo7ays4aaj318s09iada.jpg)\n\n\u003ca id='id4'\u003e\u003c/a\u003e\n\n## CSS3 字体\n__CSS3新增的字体属性：__  \n1. __@font-face__:  它允许网页开发者为其网页指定在线字体,便于在后面font-family中调用   \n   __语法：__   \n   ```\n    @font-face {\n    [ font-family: \u003cfamily-name\u003e; ] ||\n    [ src: [ \u003curl\u003e [ format(\u003cstring\u003e#) ]? | \u003cfont-face-name\u003e ]#; ] ||\n    [ unicode-range: \u003curange\u003e#; ] ||\n    [ font-variant: \u003cfont-variant\u003e; ] ||\n    [ font-feature-settings: normal | \u003cfeature-tag-value\u003e#; ] ||\n    [ font-variation-settings: normal | [ \u003cstring\u003e \u003cnumber\u003e] # ||\n    [ font-stretch: \u003cfont-stretch\u003e; ] ||\n    [ font-weight: \u003cweight\u003e; ] ||\n    [ font-style: \u003cstyle\u003e; ]\n    }\n   ```\n   - `font-family` name 必需。规定字体的名称。  \n   - `src` URL 必需。定义字体文件的 URL。  \n   - `font-stretch`  可选。定义如何拉伸字体。默认是 \"normal\"。  \n        normal  \n        condensed  \n        ultra-condensed  \n        extra-condensed  \n        semi-condensed  \n        expanded  \n        semi-expanded  \n        extra-expanded  \n        ultra-expanded  \n   - `font-style`\t可选。定义字体的样式。默认是 \"normal\"。  \n        ormal  \n        italic  \n        oblique  \n   - `font-weight` 可选。定义字体的粗细。默认是 \"normal\"。  \n        normal  \n        bold  \n        100  \n        200  \n        300  \n        400  \n        500  \n        600  \n        700  \n        800  \n        900  \n   - `unicode-range` unicode-range 可选。定义字体支持的 UNICODE 字符范围。默认是 \"U+0-10FFFF\"。    \n   __示例：__   \n   ```\n    @font-face {\n        font-family: \"Bitstream Vera Serif Bold\";\n        src: url(\"http://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf\");\n        }\n    \n    body { font-family: \"Bitstream Vera Serif Bold\", serif }\n   ``` \n\n__浏览器支持：__\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuo7ituu00j318q04odhc.jpg)\n\n\n\u003ca id='id5'\u003e\u003c/a\u003e\n\n## CSS3 2D 转换\n__CSS3新增的2D变换属性：__   通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。\n\n跳转 [CSS3-2D转换/RAEDME.md](../CSS3-2D转换/README.md)\n\n__浏览器支持：__\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuo7z8j9byj318s04s3zs.jpg)  \nChrome 和 Safari 需要前缀 -webkit-  \nInternet Explorer 9 需要前缀 -ms-  \n\n\u003ca id='id6'\u003e\u003c/a\u003e\n\n## CSS3 3D 转换\n__CSS3新增的3D变换属性：__  CSS3 3D 转换支持开发者在css代码中利用css3的3D函数，在页面里开发出一些简单的3D效果。  \n\n跳转 [CSS3-3D转换/RAEDME.md](../CSS3-3D转换/README.md)\n\n__浏览器支持：__\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuqf7u1vz0j30u204ot9y.jpg)\nInternet Explorer 10 和 Firefox 支持 3D 转换。  \nChrome 和 Safari 需要前缀 -webkit-。  \nOpera 仍然不支持 3D 转换（它只支持 2D 转换）。\n\n\u003ca id='id7'\u003e\u003c/a\u003e\n\n## CSS3 过渡\n__CSS3的过渡属性：__  过渡属性可以设定元素在某些属性改变时，对变化过程填充逐渐变换的动画，类似于flash的补间动画  \n\n跳转 [CSS3过渡/RAEDME.md](../CSS3过渡/README.md)\n\n__浏览器支持：__\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fup7uarmc3j30u204sjsn.jpg)\n\n\u003ca id='id8'\u003e\u003c/a\u003e\n\n## CSS3 动画\n__CSS3新增的动画属性：__  通过CSS3动画，我们能够创建动画，这可以在许多网页中取代动画图片、Flash动画 以及 JavaScript。作为页面切换的交互动画。  \n\n跳转 [CSS3动画/RAEDME.md](../CSS3动画/README.md)\n\n__浏览器支持：__\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fupd51aiv4j30u209k76w.jpg)  \nInternet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。  \nChrome 和 Safari 需要前缀 -webkit-。\n\n\n\u003ca id='id9'\u003e\u003c/a\u003e\n\n## CSS3 多列\n__CSS3新增的多列属性：__ 使用css3多列属性，可以将内容\b分成几列，类似报纸中文章的形式。   \n1. __column-count__: 规定元素应该被分隔的列数。  \n   __语法：__   `column-count: number|auto;`  \n   - `number` 元素内容将被划分的最佳列数。   \n   - `auto` 由其他属性决定列数，比如 \"column-width\"。      \n   __示例：__   \n   ```\n    div\n    {\n    -moz-column-count: 3; /* Firefox */\n    -webkit-column-count: 3; /* Safari 和 Chrome */\n    column-count: 3;\n    }\n   ``` \n   ![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuqrbczw9jj30x80d679n.jpg)\n\n2. __column-fill__: 规定如何填充列。  \n   __语法：__   `column-fill: balance|auto;`  \n   - `balance` 对列进行协调。浏览器应对列长度的差异进行最小化处理。   \n   - `auto` 按顺序对列进行填充，列长度会各有不同。      \n   __示例：__   \n   ```\n    div\n    {\n    column-fill:auto;\n    }\n   ``` \n\n3. __column-gap__: 规定列之间的间隔。  \n   __语法：__   `column-gap: length|normal;`  \n   - `length` 把列间的间隔设置为指定的长度。   \n   - `normal` 规定列间间隔为一个常规的间隔。W3C 建议的值是 1em。      \n   __示例：__   \n   ```\n    div\n    {\n    -moz-column-gap:40px; /* Firefox */\n    -webkit-column-gap:40px; /* Safari 和 Chrome */\n    column-gap:40px;\n    }\n   ``` \n   ![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuqrjcfhi9j30xi08wdiy.jpg)\n   \n4. __column-rule__: 设置所有 column-rule-* 属性的简写属性。包括 列之间 的 颜色、样式、宽度    \n   __语法：__   `column-rule: column-rule-width column-rule-style column-rule-color;`  \n   - __`column-rule-width`__\t设置列之间的宽度规则。 \n        - __语法：__   `column-rule-width: thin|medium|thick|length;`   \n        - `thin`\t定义纤细规则。  \n        - `medium`\t定义中等规则。  \n        - `thick`\t定义宽厚规则。    \n        - `length`\t规定规则的宽度。\n   - __`column-rule-style`__\t设置列之间的样式规则。  \n        - __语法：__   `column-rule-style: none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset;`   \n        - `none`\t定义没有规则。\t  \n        - `hidden`\t定义隐藏规则。\t  \n        - `dotted`\t定义点状规则。\t  \n        - `dashed`\t定义虚线规则。\t  \n        - `solid`\t定义实线规则。\t  \n        - `double`\t定义双线规则。\t  \n        - `groove`\t定义 3D grooved 规则。该效果取决于宽度和颜色值。\t  \n        - `ridge`\t定义 3D ridged 规则。该效果取决于宽度和颜色值。\t  \n        - `inset`\t定义 3D inset 规则。该效果取决于宽度和颜色值。\t  \n        - `outset`\t定义 3D outset 规则。该效果取决于宽度和颜色值。\t  \n\n   - __`column-rule-color`__\t设置列之间的颜色规则。   \n        - __语法：__   `column-rule-color: color;`   \n        - `color`\t规定颜色规则。请参阅 [CSS 颜色值](http://www.w3school.com.cn/cssref/css_colors_legal.asp)。  \n  \n   __示例：__   \n   ```\n    div\n    {\n    -moz-column-rule:3px outset #ff0000;\t/* Firefox */\n    -webkit-column-rule:3px outset #ff0000;\t/* Safari and Chrome */\n    column-rule:3px outset #ff0000;\n    }\n   ``` \n   ![](https://ws2.sinaimg.cn/large/006tNbRwgy1fusmomdnszj30xg09mgpn.jpg)\n   \n__浏览器支持：__\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuqqzk5gl6j30u20eewi4.jpg) \nInternet Explorer 10 和 Opera 支持多列属性。  \nFirefox 需要前缀 -moz-。  \nChrome 和 Safari 需要前缀 -webkit-。  \n\n\u003ca id='id10'\u003e\u003c/a\u003e\n\n## CSS3 用户界面\n__CSS3新增的用户界面属性：__ 利用css3的用户界面属性，可以重设元素尺寸、盒尺寸以及轮廓等。  \n\n__先看所有的用户界面属性__   \n- `appearance`\t允许您将元素设置为标准用户界面元素的外观  \n- `box-sizing`\t允许您以确切的方式定义适应某个区域的具体内容。  \n- `icon`\t为创作者提供使用图标化等价物来设置元素样式的能力。  \n- `nav-down`\t规定在使用 arrow-down 导航键时向何处导航。  \n- `nav-index`\t设置元素的 tab 键控制次序。\t  \n- `nav-left`\t规定在使用 arrow-left 导航键时向何处导航。\t  \n- `nav-right`\t规定在使用 arrow-right 导航键时向何处导航。\t  \n- `nav-up`\t规定在使用 arrow-up 导航键时向何处导航。\t  \n- `outline-offset`\t对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。\t  \n- `resize`\t规定是否可由用户对元素的尺寸进行调整。\t  \n\n__\b我这边简单介绍一下 浏览器支持比较好的 几个属性__  \n1. __box-sizing__: 改变css 的 width、height 在盒模型中的指向。  \n   - 因为css默认width指向的是盒模型的内容宽度(图中蓝色部分)，而 整个盒模型的宽度 = padding + border + 内容width，整个盒模型所占据文本流的位置还要包括其margin值。  \n   - 而一般我们所想的，我们设置的width值，应该是 整个\b盒模型的宽度，所以问题就产生了。  \n   - 那么这个`box-sizing`，就是用来解决\bwidth、height 在盒模型中的指向问题的。  \n   ![](https://ws4.sinaimg.cn/large/006tNbRwgy1fusoa0l7n5j30ak0aa74j.jpg)  \n\n   __语法：__   `box-sizing: content-box|border-box|inherit;`  \n   - `content-box` 默认，CSS2.1 规定的宽度高度行为。将width、height指向内容宽度，padding、border不被包括在内。  \n    _width、height指向如下图：_  \n    ![](https://ws3.sinaimg.cn/large/006tNbRwgy1fusob65rl6j30au0aeaam.jpg) \n   - `border-box` width指向 内容宽度+padding+border，内容宽度根据减法自适应。height同理。  \n    _width、height指向如下图：_  \n    ![](https://ws2.sinaimg.cn/large/006tNbRwgy1fusob3mmr2j30au0aeq3i.jpg)\n   - `inherit`   继承 父元素 box-sizing属性的值。  \n   \n   __示例：__   \n   ```\n    div\n    {\n    box-sizing:border-box;\n    -moz-box-sizing:border-box; /* Firefox */\n    -webkit-box-sizing:border-box; /* Safari */\n    }\n   ``` \n   __浏览器支持：__\n    ![](https://ws4.sinaimg.cn/large/006tNbRwgy1fusofkoju7j30vc06oabn.jpg)\n    Internet Explorer、Opera 以及 Chrome 支持 box-sizing 属性。  \n    Firefox 支持替代的 -moz-box-sizing 属性。   \n\n2. __outline-offset__: 此属性对轮廓进行偏移。  \n   __语法：__   `outline-offset: length|inherit;`  \n   - `length`\t轮廓与边框边缘的距离。  \n   - `inherit`\t规定应从父元素继承 outline-offset 属性的值。  \n   \n   __示例：__   \n   ```\n    div\n    {\n    border:2px solid black;\n    outline:2px solid red;\n    outline-offset:15px;\n    }\n   ```  \n   __使用对比：__ _后者为使用了`outline-offset:15px;`_   \n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuson2ha9gj30ck07mwev.jpg)\n   ![](https://ws2.sinaimg.cn/large/006tNbRwgy1fusomvlpg6j30cs08ajrs.jpg)  \n   __浏览器支持：__   \n    所有主流浏览器都支持 outline-offset 属性，除了 Internet Explorer。  \n\n__\b其余几个属性只有小部分浏览器支持__   \n[__参看所有转换属性的使用__](http://www.w3school.com.cn/css3/css3_user_interface.asp)  \n\n\n"},{"path":"_blogs/HTML\u0026CSS/CSS中可以和不可以继承的属性/README.md","title":"CSS中可以和不可以继承的属性","author":"yrobot","keywords":"CSS,属性,继承","createTime":1535040000000,"createTimeStr":"2018年08月24日","length":2705,"content":"# CSS中可以和不可以继承的属性    \n    \n   \n  \n__本页目录：__     \n[无继承性的属性](#id1)    \n[有继承性的属性](#id2)    \n[所有元素可以继承的属性](#id3)    \n[内联元素可以继承的属性](#id4)    \n[块级元素可以继承的属性](#id5)    \n  \n\u003ca id='id1'\u003e\u003c/a\u003e  \n  \n## 无继承性的属性  \n1. display：规定元素应该生成的框的类型  \n2. 文本属性：  \nvertical-align：垂直文本对齐  \ntext-decoration：规定添加到文本的装饰  \ntext-shadow：文本阴影效果  \nwhite-space：空白符的处理  \nunicode-bidi：设置文本的方向  \n3. 盒子模型的属性：width. height. margin . margin-top. margin-right. margin-bottom. margin-left. border. border-style. border-top-style. border-right-style. border-bottom-style. border-left-style. border-width. border-top-width. border-right-right. border-bottom-width. border-left-width. border-color. border-top-color. border-right-color. border-bottom-color. border-left-color. border-top. border-right. border-bottom. border-left. padding. padding-top. padding-right. padding-bottom. padding-left  \n4. 背景属性：background. background-color. background-image. background-repeat. background-position. background-attachment  \n5. 定位属性：float. clear. position. top. right. bottom. left. min-width. min-height. max-width. max-height. overflow. clip. z-index  \n6. 生成内容属性：content. counter-reset. counter-increment  \n7. 轮廓样式属性：outline-style. outline-width. outline-color. outline  \n8. 页面样式属性：size. page-break-before. page-break-after  \n9. 声音样式属性：pause-before. pause-after. pause. cue-before. cue-after. cue. play-during  \n  \n\u003ca id='id2'\u003e\u003c/a\u003e  \n  \n## 有继承性的属性  \n1. 字体系列属性  \nfont：组合字体  \nfont-family：规定元素的字体系列  \nfont-weight：设置字体的粗细  \nfont-size：设置字体的尺寸  \nfont-style：定义字体的风格  \nfont-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。  \nfont-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。  \nfont-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。  \n2. 文本系列属性  \ntext-indent：文本缩进  \ntext-align：文本水平对齐  \nline-height：行高  \nword-spacing：增加或减少单词间的空白（即字间隔）  \nletter-spacing：增加或减少字符间的空白（字符间距）  \ntext-transform：控制文本大小写  \ndirection：规定文本的书写方向  \ncolor：文本颜色  \n3. 元素可见性：visibility  \n4. 表格布局属性：caption-side. border-collapse. border-spacing. empty-cells. table-layout  \n5. 列表布局属性：list-style-type. list-style-image. list-style-position. list-style  \n6. 生成内容属性：quotes  \n7. 光标属性：cursor  \n8. 页面样式属性：page. page-break-inside. windows. orphans  \n9. 声音样式属性：speak. speak-punctuation. speak-numeral. speak-header. speech-rate. volume. voice-family. pitch. pitch-range. stress. richness. . azimuth. elevation  \n  \n\u003ca id='id3'\u003e\u003c/a\u003e  \n  \n## 所有元素可以继承的属性  \n\n1. 元素可见性：visibility\n2. 光标属性：cursor  \n\n\u003ca id='id4'\u003e\u003c/a\u003e  \n  \n## 内联元素可以继承的属性  \n1. 字体系列属性\n2. 除text-indent、text-align之外的文本系列属性  \n\n\u003ca id='id5'\u003e\u003c/a\u003e  \n  \n## 块级元素可以继承的属性  \n1. text-indent、text-align\n  \n---   \n\n  \n"},{"path":"_blogs/HTML\u0026CSS/display属性/README.md","title":"display 属性","author":"yrobot","keywords":"display,属性","createTime":1535040000000,"createTimeStr":"2018年08月24日","length":809,"content":"# display 属性  \n__本页目录：__   \n[display有哪些值,以及作用](#display)  \n[html元素嵌套规则](#nest)  \n\n\u003ca id='display'\u003e\u003c/a\u003e\n\n## display有哪些值,以及作用\n\n  - block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。\n  - none 缺省值。像行内元素类型一样显示。\n  - inline 行内元素类型。默认宽度为内容宽度，__不可设置宽高、margin上下、padding上下__，同行显示。\n  - inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。__元素间会有间隙__（HTML 中的换行符、空格符、制表符等合并为空白符，字体大小不为 0 的情况下，空白符自然占据一定的宽度，使用inline-block 会产生元素间的空隙）\n  - list-item 像块类型元素一样显示，并添加样式列表标记。\n  - table 此元素会作为块级表格来显示。\n  - inherit 规定应该从父元素继承display属性的值\n\n\u003ca id='nest'\u003e\u003c/a\u003e\n\n## html元素嵌套规则\n\n1. 块级元素可以包含内联元素或某些块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。\n2. 块级元素不能放在p里面。\n3. 有几个特殊的块级元素只能包含内联元素，不能包含块级元素。如h1,h2,h3,h4,h5,h6,p,dt\n4. li内可以包含div\n5. 块级元素与块级元素并列、内联元素与内联元素并列。\n\n"}]},{"title":"状态管理","list":[{"path":"_blogs/SPA/react的状态管理/利用react-redux.md","title":"react的状态管理—利用react-redux","author":"yrobot","keywords":"react,redux,状态管理,利用","createTime":1537632000000,"createTimeStr":"2018年09月23日","length":3707,"content":"# react的状态管理—利用react-redux \n__本页目录：__   \n[场景思考](#index)  \n[利用react-redux](#redux)  \n[查看效果](#result)  \n[查看代码](#code)  \n\n\u003ca id='index'\u003e\u003c/a\u003e\n\n## 场景思考\n现在我们用react去写一篇博客  \n博客包含 `标题` 和 `内容`  \n而我期望`标题`和`内容`的颜色可以一键修改  \n\n当然最暴力的实现方式就是利用dom操作去被动的修改  \n但是有没有更优雅更可控的方式呢？  \n\n首先来看看项目的组件树：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg)\n\n那么有什么好的优雅的方式使`Title`和`Content`的颜色保持一致呢？  \n换句话说，怎么更好的管理`Title`和`Content`的状态呢？ \n\n#### 回顾上一节  \n上一节我们使用react自带的 [\b利用context注入](./利用context注入.md) 方法   \n利用react的context去实现状态共享很方便  \n但是react的context还是实验性的，何时会更新无法预知  \n所以为了保证软件的稳定性，我们还是使用react推荐的第三方状态管理redux   \n\n\u003ca id='redux'\u003e\u003c/a\u003e\n\n## 利用react-redux\nredux 是一套专业解决应用状态管理的独立的通用模块\b  \n它不仅可以和react结合，形成react-redux，也可以和vue、angular结合  \n\n__react-redux的作用：__ 类似于\breact的context，\breact-redux在顶层组件利用Provider将store注入，在需要用到状态的组件处用connect函数包裹，从组件的props中获取store  \n\n__react-redux的使用方法：__  \n1. 根据全局数据，将其拆分为多个`reducer`\n2. 对于每个`reducer`分配`state`（`reducers.reducer`）和`action`，处理对应的`action`操作，生成行的`state`\n3. 将`reducer`合并成`reducers`,`reducers`分配传入的`state`和`action`操作到`reducer` \n4. `createStore()`传入`reducers`生成`store`，并用`Provider`将`store`注入顶层组件\n5. 在要引用`store`的组件部分用`connect()`连接，`connect()`会注册监听、将`dispatch()`[默认写入]和`mapStateToProps`的属性写入`props`，当然如果使用`mapDispatchToProps`生成的`action creator`也会写入`props`。\n6. 在组件中通过`props`获取5中写入`props`的数据即可使用。\n7. 通过`dispatch()`的参数会触发`reducers`的`action`操作，从而更新状态  \n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fvlqv6xb3uj30yu0sagqj.jpg)\n\n__react-redux的优势：__ \n1. 相对于react自带的context，react-redux更加稳定成熟，并对性能进行了优化  \n2. 相对于props的状态提升，react-redux更加的方便简洁，整个全局状态也更加清晰   \n\n__老话说的好，杀鸡焉用牛刀，在简单场景直接使用状态提升即可__  \n\n\u003ca id='result'\u003e\u003c/a\u003e\n\n## 查看效果\n1. \n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fvhmmoieh4j31kw0nxdpk.jpg)\n2. \n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fvhmmukgfyj31kw0o2qcy.jpg)\n\n\n\u003ca id='code'\u003e\u003c/a\u003e\n\n## 查看代码\nreducers.js生成全局状态：  \n```\nimport { combineReducers } from 'redux'\n\nconst mainColor = (state = 'black',action)=\u003e{\n    switch (action.type){\n        case 'CHANGE_COLOR':\n            state = action.color;\n            return state;\n        default:\n            return state;\n    }\n}\n\nexport default combineReducers({\n    mainColor,\n})\n```\n\nBlogPage.js中\b生成store，并利用Provider注入顶层组件：\n```\nimport reducers from './reducers.js'\n\nconst store = createStore(reducers);\n\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n        }\n    }\n    render() {\n        return (\n            \u003cProvider store = {store}\u003e\n                \u003cdiv className =\"blogContainer\"\u003e\n                    \u003cHeader \u003e\u003c/Header\u003e\n                    \u003cMain\u003e\u003c/Main\u003e\n                \u003c/div\u003e\n            \u003c/Provider\u003e\n        );\n    }\n}\n\nexport default BlogPage;\n```\n\nContent.js中利用connect()函数将状态写入组件props：  \n```\nclass Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    render() {\n        const {mainColor,changeMainColor} = this.props;\n        return (\n            \u003cdiv className=\"content\" style={{ color: mainColor }}\u003e\n                内容...\n                \u003cdiv className=\"button\" onClick={() =\u003e { changeMainColor('#' + (Math.random() * 0xffffff \u003c\u003c 0).toString(16)) }}\u003e切换颜色\u003c/div\u003e\n            \u003c/div\u003e\n\n        );\n    }\n}\n\nconst mapStateToProps = state =\u003e ({  //引入状态到props，并注册监听变化\n    mainColor: state.mainColor\n})\n\nconst mapDispatchToProps = dispatch =\u003e ({ //引入方法到props\n    changeMainColor: color =\u003e {\n        dispatch({\n            type:'CHANGE_COLOR',\n            color,\n        })\n    }\n})\n\nexport default connect(  //绑定组件 //高阶组件:函数接受一个组件作为参数，并返回一个新的组件\n    mapStateToProps,\n    mapDispatchToProps\n)(Content);\n```\n\n\n"},{"path":"_blogs/SPA/react的状态管理/利用context注入.md","title":"react的状态管理—利用context注入","author":"yrobot","keywords":"context,状态管理,react,注入,利用","createTime":1537545600000,"createTimeStr":"2018年09月22日","length":3544,"content":"# react的状态管理—利用context注入  \n__本页目录：__   \n[场景思考](#index)  \n[利用context注入](#context)  \n[查看效果](#result)  \n[查看代码](#code)  \n\n\u003ca id='index'\u003e\u003c/a\u003e\n\n## 场景思考\n现在我们用react去写一篇博客  \n博客包含 `标题` 和 `内容`  \n而我期望`标题`和`内容`的颜色可以一键修改  \n\n当然最暴力的实现方式就是利用dom操作去被动的修改  \n但是有没有更优雅更可控的方式呢？  \n\n首先来看看项目的组件树：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg)\n\n那么有什么好的优雅的方式使`Title`和`Content`的颜色保持一致呢？  \n换句话说，怎么更好的管理`Title`和`Content`的状态呢？ \n\n#### 回顾上一节  \n上一节我们使用最基础的[props状态提升](./利用props状态提升.md)的方法   \n但当组件链很长的时候，新增一个状态就必须修改每个组件的props  \n那有没有跟直接的方法，搞一个共享状态，每个组件可以自由访问呢  \nreact自带的context就是用来实现这一点的  \n\n\u003ca id='context'\u003e\u003c/a\u003e\n\n## 利用context注入\nreact的context可以代替props的传递工作  \n\n__context的作用：__ 将顶部\b组件的状态和方法与子组件共享  \n\n__context的使用方法：__  \n1. 利用`React.createContext()`生成一对`{Provider,Consumer}`  \n2. 用生成的`Provider`包裹\b顶部组件，利用他props的value字段传入共享状态与方法  \n   ```\n    \u003cProvider value={{状态和方法}}\u003e\n        \u003c顶层组件\u003e\n    \u003c/Provider\u003e\n   ```\n3. 用生成的`Consumer`包裹使用共享状态的组件，在Consumer内子组件外用函数传入共享的状态  \n   ```\n    \u003cConsumer\u003e\n        {value =\u003e (\n            \u003c子组件 使用value\u003e\n        )}\n    \u003c/Consumer\u003e\n   ```\n4. 保证状态位于顶层组件的`state`中，而共享的方法要更新状态也是利用`setState`，这样UI层才会刷新  \n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fvhm1xim52j30yg0pqads.jpg)\n\n__context的优势：__ \n1. 只需要在顶层组件和用到状态的子组件进行操作，省去了props状态提升中对中间组件的数据传递操作。代码更清晰。   \n2. 无需引入第三方状态管理，学习成本也相对较低  \n\n__尽管context相对于props状态提升方便很多，\b但是react官网还是 _不建议_ 使用context，因为context的API是实验性的，在未来的react版本中会被修改。__  \n\n__在简单场景,推荐使用props状态提升__  \n__在较复杂的场景，应该考虑引入第三方状态管理(如Redux、Mobx)__  \n\n\u003ca id='result'\u003e\u003c/a\u003e\n\n## 查看效果\n1. \n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fvhmmoieh4j31kw0nxdpk.jpg)\n2. \n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fvhmmukgfyj31kw0o2qcy.jpg)\n\n\n\n\u003ca id='code'\u003e\u003c/a\u003e\n\n## 查看代码\nmainColorContext.js暴露React.createContext：  \n```\nimport React from 'react';\n\nexport const mainColorContext = React.createContext(\n    {\n        mainColor:'black'\n    } // 默认值\n);\n```\n\nBlogPage.js中引入mainColorContext，定义全局状态mainColor和方法changeMainColor()并传入Provider： \n```\nimport {mainColorContext} from './mainColorContext.js'\n\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            mainColor: 'black'\n        }\n    }\n    changeMainColor = (color) =\u003e {\n        this.setState({ //this的绑定//运行时//但是箭头函数没有this//直接沿着作用域链往上找找到BlogPage类的this //换成function就不行了，obj.func()会修改this指向为obj\n            mainColor: color\n        })\n    }\n    render() {\n        const { mainColor } = this.state;\n        return (\n            \u003cmainColorContext.Provider value={{mainColor,changeMainColor:this.changeMainColor}}\u003e\n                \u003cdiv className=\"blogContainer\"\u003e\n                    \u003cHeader \u003e\u003c/Header\u003e\n                    \u003cMain\u003e\u003c/Main\u003e\n                \u003c/div\u003e\n            \u003c/mainColorContext.Provider\u003e\n        );\n    }\n}\n```\nContent.js组件中获取使用Consumer传递的数据和方法：\n```\nimport {mainColorContext} from '../../BlogPage/mainColorContext.js'\n\nclass Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    render() {\n        return (\n            \u003cmainColorContext.Consumer\u003e\n                {value =\u003e (\n                    \u003cdiv className=\"content\" style={{ color: value.mainColor }}\u003e\n                        文本...\n                    \u003cdiv className=\"button\" onClick={()=\u003e{value.changeMainColor('#' + (Math.random() * 0xffffff \u003c\u003c 0).toString(16))}}\u003e切换颜色\u003c/div\u003e\n                    \u003c/div\u003e\n                )}\n            \u003c/mainColorContext.Consumer\u003e\n\n        );\n    }\n}\n```\n\n\n"},{"path":"_blogs/SPA/react的状态管理/利用props状态提升.md","title":"react的状态管理—利用props状态提升","author":"yrobot","keywords":"状态管理,props,react,状态,提升,利用","createTime":1537200000000,"createTimeStr":"2018年09月18日","length":2494,"content":"# react的状态管理—利用props状态提升  \n__本页目录：__   \n[场景思考](#index)  \n[利用props状态提升](#props)  \n[查看效果](#result)  \n[查看代码](#code)  \n\n\u003ca id='index'\u003e\u003c/a\u003e\n\n## 场景思考\n现在我们用react去写一篇博客  \n博客包含 `标题` 和 `内容`  \n而我期望`标题`和`内容`的颜色可以一键修改  \n\n当然最暴力的实现方式就是利用dom操作去被动的修改  \n但是有没有更优雅更可控的方式呢？  \n\n首先来看看项目的组件树：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg)\n\n那么有什么好的优雅的方式使`Title`和`Content`的颜色保持一致呢？  \n换句话说，怎么更好的管理`Title`和`Content`的状态呢？  \n\n\n\u003ca id='props'\u003e\u003c/a\u003e\n\n## 利用props状态提升\n学习了react，就知道组件间数据交互最普遍的方式就是利用props传递  \n而目我们要做的就是Title和Content引用的是同一个颜色变量，而且在变量改变时组件自动重新渲染  \n利用react最基础的方法就是利用状态提升:  \n把一些共享的状态放在最顶端的组件中，子组件通过props去访问和修改这些状态  \n\n本场景中需要共享的状态只有一个`mainColor`和一个修改mainColor的函数`changeMainColor()`  \n具体流程如下图：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvexnc4cbcj30ss0poacx.jpg)\n\b可以看到，需要在content和title中用mainColor，需要通过组件props层层传递到需要用状态的组件，函数也是同理  \n\n\u003ca id='result'\u003e\u003c/a\u003e\n\n## 查看效果\n1. \n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fvey3e0sw6j31kw0lmdoe.jpg)\n2. \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvey3n6qu4j31kw0n1aju.jpg)\n3. \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fvey3xqxwpj31kw0nntin.jpg)\n\n\n\u003ca id='code'\u003e\u003c/a\u003e\n\n## 查看代码\n\nBlogPage中定义全局状态mainColor和方法changeMainColor()并传递： \n```\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            mainColor: 'black'\n        }\n    }\n    changeMainColor = (color) =\u003e {\n        this.setState({\n            mainColor: color\n        })\n    }\n    render() {\n        const { mainColor } = this.state;\n        return (\n            \u003cdiv className=\"blogContainer\"\u003e\n                \u003cHeader mainColor={mainColor}\u003e\u003c/Header\u003e\n                \u003cMain mainColor={mainColor} changeMainColor={this.changeMainColor}\u003e\u003c/Main\u003e\n            \u003c/div\u003e\n        );\n    }\n}\n```\nContent组件中使用props传递的数据和方法：\n```\nclass Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    randomColor = () =\u003e {\n        this.props.changeMainColor('#' + (Math.random() * 0xffffff \u003c\u003c 0).toString(16));\n    }\n    render() {\n        const {mainColor}=this.props;\n        return (\n            \u003cdiv className=\"content\" style={{color:mainColor}}\u003e\n                内容...\n                \u003cdiv className=\"button\" onClick={this.randomColor}\u003e切换颜色\u003c/div\u003e\n            \u003c/div\u003e\n        );\n    }\n}\n```\n\n\n--- \n*\b本章节部分参考[React.js 小书](http://huziketang.mangojuice.top/books/react/lesson29)，在此感谢！*\n\n\n"}]},{"title":"react","list":[{"path":"_blogs/SPA/react的状态管理/利用react-redux.md","title":"react的状态管理—利用react-redux","author":"yrobot","keywords":"react,redux,状态管理,利用","createTime":1537632000000,"createTimeStr":"2018年09月23日","length":3707,"content":"# react的状态管理—利用react-redux \n__本页目录：__   \n[场景思考](#index)  \n[利用react-redux](#redux)  \n[查看效果](#result)  \n[查看代码](#code)  \n\n\u003ca id='index'\u003e\u003c/a\u003e\n\n## 场景思考\n现在我们用react去写一篇博客  \n博客包含 `标题` 和 `内容`  \n而我期望`标题`和`内容`的颜色可以一键修改  \n\n当然最暴力的实现方式就是利用dom操作去被动的修改  \n但是有没有更优雅更可控的方式呢？  \n\n首先来看看项目的组件树：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg)\n\n那么有什么好的优雅的方式使`Title`和`Content`的颜色保持一致呢？  \n换句话说，怎么更好的管理`Title`和`Content`的状态呢？ \n\n#### 回顾上一节  \n上一节我们使用react自带的 [\b利用context注入](./利用context注入.md) 方法   \n利用react的context去实现状态共享很方便  \n但是react的context还是实验性的，何时会更新无法预知  \n所以为了保证软件的稳定性，我们还是使用react推荐的第三方状态管理redux   \n\n\u003ca id='redux'\u003e\u003c/a\u003e\n\n## 利用react-redux\nredux 是一套专业解决应用状态管理的独立的通用模块\b  \n它不仅可以和react结合，形成react-redux，也可以和vue、angular结合  \n\n__react-redux的作用：__ 类似于\breact的context，\breact-redux在顶层组件利用Provider将store注入，在需要用到状态的组件处用connect函数包裹，从组件的props中获取store  \n\n__react-redux的使用方法：__  \n1. 根据全局数据，将其拆分为多个`reducer`\n2. 对于每个`reducer`分配`state`（`reducers.reducer`）和`action`，处理对应的`action`操作，生成行的`state`\n3. 将`reducer`合并成`reducers`,`reducers`分配传入的`state`和`action`操作到`reducer` \n4. `createStore()`传入`reducers`生成`store`，并用`Provider`将`store`注入顶层组件\n5. 在要引用`store`的组件部分用`connect()`连接，`connect()`会注册监听、将`dispatch()`[默认写入]和`mapStateToProps`的属性写入`props`，当然如果使用`mapDispatchToProps`生成的`action creator`也会写入`props`。\n6. 在组件中通过`props`获取5中写入`props`的数据即可使用。\n7. 通过`dispatch()`的参数会触发`reducers`的`action`操作，从而更新状态  \n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fvlqv6xb3uj30yu0sagqj.jpg)\n\n__react-redux的优势：__ \n1. 相对于react自带的context，react-redux更加稳定成熟，并对性能进行了优化  \n2. 相对于props的状态提升，react-redux更加的方便简洁，整个全局状态也更加清晰   \n\n__老话说的好，杀鸡焉用牛刀，在简单场景直接使用状态提升即可__  \n\n\u003ca id='result'\u003e\u003c/a\u003e\n\n## 查看效果\n1. \n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fvhmmoieh4j31kw0nxdpk.jpg)\n2. \n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fvhmmukgfyj31kw0o2qcy.jpg)\n\n\n\u003ca id='code'\u003e\u003c/a\u003e\n\n## 查看代码\nreducers.js生成全局状态：  \n```\nimport { combineReducers } from 'redux'\n\nconst mainColor = (state = 'black',action)=\u003e{\n    switch (action.type){\n        case 'CHANGE_COLOR':\n            state = action.color;\n            return state;\n        default:\n            return state;\n    }\n}\n\nexport default combineReducers({\n    mainColor,\n})\n```\n\nBlogPage.js中\b生成store，并利用Provider注入顶层组件：\n```\nimport reducers from './reducers.js'\n\nconst store = createStore(reducers);\n\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n        }\n    }\n    render() {\n        return (\n            \u003cProvider store = {store}\u003e\n                \u003cdiv className =\"blogContainer\"\u003e\n                    \u003cHeader \u003e\u003c/Header\u003e\n                    \u003cMain\u003e\u003c/Main\u003e\n                \u003c/div\u003e\n            \u003c/Provider\u003e\n        );\n    }\n}\n\nexport default BlogPage;\n```\n\nContent.js中利用connect()函数将状态写入组件props：  \n```\nclass Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    render() {\n        const {mainColor,changeMainColor} = this.props;\n        return (\n            \u003cdiv className=\"content\" style={{ color: mainColor }}\u003e\n                内容...\n                \u003cdiv className=\"button\" onClick={() =\u003e { changeMainColor('#' + (Math.random() * 0xffffff \u003c\u003c 0).toString(16)) }}\u003e切换颜色\u003c/div\u003e\n            \u003c/div\u003e\n\n        );\n    }\n}\n\nconst mapStateToProps = state =\u003e ({  //引入状态到props，并注册监听变化\n    mainColor: state.mainColor\n})\n\nconst mapDispatchToProps = dispatch =\u003e ({ //引入方法到props\n    changeMainColor: color =\u003e {\n        dispatch({\n            type:'CHANGE_COLOR',\n            color,\n        })\n    }\n})\n\nexport default connect(  //绑定组件 //高阶组件:函数接受一个组件作为参数，并返回一个新的组件\n    mapStateToProps,\n    mapDispatchToProps\n)(Content);\n```\n\n\n"},{"path":"_blogs/SPA/react的状态管理/利用context注入.md","title":"react的状态管理—利用context注入","author":"yrobot","keywords":"context,状态管理,react,注入,利用","createTime":1537545600000,"createTimeStr":"2018年09月22日","length":3544,"content":"# react的状态管理—利用context注入  \n__本页目录：__   \n[场景思考](#index)  \n[利用context注入](#context)  \n[查看效果](#result)  \n[查看代码](#code)  \n\n\u003ca id='index'\u003e\u003c/a\u003e\n\n## 场景思考\n现在我们用react去写一篇博客  \n博客包含 `标题` 和 `内容`  \n而我期望`标题`和`内容`的颜色可以一键修改  \n\n当然最暴力的实现方式就是利用dom操作去被动的修改  \n但是有没有更优雅更可控的方式呢？  \n\n首先来看看项目的组件树：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg)\n\n那么有什么好的优雅的方式使`Title`和`Content`的颜色保持一致呢？  \n换句话说，怎么更好的管理`Title`和`Content`的状态呢？ \n\n#### 回顾上一节  \n上一节我们使用最基础的[props状态提升](./利用props状态提升.md)的方法   \n但当组件链很长的时候，新增一个状态就必须修改每个组件的props  \n那有没有跟直接的方法，搞一个共享状态，每个组件可以自由访问呢  \nreact自带的context就是用来实现这一点的  \n\n\u003ca id='context'\u003e\u003c/a\u003e\n\n## 利用context注入\nreact的context可以代替props的传递工作  \n\n__context的作用：__ 将顶部\b组件的状态和方法与子组件共享  \n\n__context的使用方法：__  \n1. 利用`React.createContext()`生成一对`{Provider,Consumer}`  \n2. 用生成的`Provider`包裹\b顶部组件，利用他props的value字段传入共享状态与方法  \n   ```\n    \u003cProvider value={{状态和方法}}\u003e\n        \u003c顶层组件\u003e\n    \u003c/Provider\u003e\n   ```\n3. 用生成的`Consumer`包裹使用共享状态的组件，在Consumer内子组件外用函数传入共享的状态  \n   ```\n    \u003cConsumer\u003e\n        {value =\u003e (\n            \u003c子组件 使用value\u003e\n        )}\n    \u003c/Consumer\u003e\n   ```\n4. 保证状态位于顶层组件的`state`中，而共享的方法要更新状态也是利用`setState`，这样UI层才会刷新  \n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fvhm1xim52j30yg0pqads.jpg)\n\n__context的优势：__ \n1. 只需要在顶层组件和用到状态的子组件进行操作，省去了props状态提升中对中间组件的数据传递操作。代码更清晰。   \n2. 无需引入第三方状态管理，学习成本也相对较低  \n\n__尽管context相对于props状态提升方便很多，\b但是react官网还是 _不建议_ 使用context，因为context的API是实验性的，在未来的react版本中会被修改。__  \n\n__在简单场景,推荐使用props状态提升__  \n__在较复杂的场景，应该考虑引入第三方状态管理(如Redux、Mobx)__  \n\n\u003ca id='result'\u003e\u003c/a\u003e\n\n## 查看效果\n1. \n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fvhmmoieh4j31kw0nxdpk.jpg)\n2. \n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fvhmmukgfyj31kw0o2qcy.jpg)\n\n\n\n\u003ca id='code'\u003e\u003c/a\u003e\n\n## 查看代码\nmainColorContext.js暴露React.createContext：  \n```\nimport React from 'react';\n\nexport const mainColorContext = React.createContext(\n    {\n        mainColor:'black'\n    } // 默认值\n);\n```\n\nBlogPage.js中引入mainColorContext，定义全局状态mainColor和方法changeMainColor()并传入Provider： \n```\nimport {mainColorContext} from './mainColorContext.js'\n\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            mainColor: 'black'\n        }\n    }\n    changeMainColor = (color) =\u003e {\n        this.setState({ //this的绑定//运行时//但是箭头函数没有this//直接沿着作用域链往上找找到BlogPage类的this //换成function就不行了，obj.func()会修改this指向为obj\n            mainColor: color\n        })\n    }\n    render() {\n        const { mainColor } = this.state;\n        return (\n            \u003cmainColorContext.Provider value={{mainColor,changeMainColor:this.changeMainColor}}\u003e\n                \u003cdiv className=\"blogContainer\"\u003e\n                    \u003cHeader \u003e\u003c/Header\u003e\n                    \u003cMain\u003e\u003c/Main\u003e\n                \u003c/div\u003e\n            \u003c/mainColorContext.Provider\u003e\n        );\n    }\n}\n```\nContent.js组件中获取使用Consumer传递的数据和方法：\n```\nimport {mainColorContext} from '../../BlogPage/mainColorContext.js'\n\nclass Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    render() {\n        return (\n            \u003cmainColorContext.Consumer\u003e\n                {value =\u003e (\n                    \u003cdiv className=\"content\" style={{ color: value.mainColor }}\u003e\n                        文本...\n                    \u003cdiv className=\"button\" onClick={()=\u003e{value.changeMainColor('#' + (Math.random() * 0xffffff \u003c\u003c 0).toString(16))}}\u003e切换颜色\u003c/div\u003e\n                    \u003c/div\u003e\n                )}\n            \u003c/mainColorContext.Consumer\u003e\n\n        );\n    }\n}\n```\n\n\n"},{"path":"_blogs/SPA/react的状态管理/利用props状态提升.md","title":"react的状态管理—利用props状态提升","author":"yrobot","keywords":"状态管理,props,react,状态,提升,利用","createTime":1537200000000,"createTimeStr":"2018年09月18日","length":2494,"content":"# react的状态管理—利用props状态提升  \n__本页目录：__   \n[场景思考](#index)  \n[利用props状态提升](#props)  \n[查看效果](#result)  \n[查看代码](#code)  \n\n\u003ca id='index'\u003e\u003c/a\u003e\n\n## 场景思考\n现在我们用react去写一篇博客  \n博客包含 `标题` 和 `内容`  \n而我期望`标题`和`内容`的颜色可以一键修改  \n\n当然最暴力的实现方式就是利用dom操作去被动的修改  \n但是有没有更优雅更可控的方式呢？  \n\n首先来看看项目的组件树：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvekxo7hlhj30c00aj0sy.jpg)\n\n那么有什么好的优雅的方式使`Title`和`Content`的颜色保持一致呢？  \n换句话说，怎么更好的管理`Title`和`Content`的状态呢？  \n\n\n\u003ca id='props'\u003e\u003c/a\u003e\n\n## 利用props状态提升\n学习了react，就知道组件间数据交互最普遍的方式就是利用props传递  \n而目我们要做的就是Title和Content引用的是同一个颜色变量，而且在变量改变时组件自动重新渲染  \n利用react最基础的方法就是利用状态提升:  \n把一些共享的状态放在最顶端的组件中，子组件通过props去访问和修改这些状态  \n\n本场景中需要共享的状态只有一个`mainColor`和一个修改mainColor的函数`changeMainColor()`  \n具体流程如下图：  \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvexnc4cbcj30ss0poacx.jpg)\n\b可以看到，需要在content和title中用mainColor，需要通过组件props层层传递到需要用状态的组件，函数也是同理  \n\n\u003ca id='result'\u003e\u003c/a\u003e\n\n## 查看效果\n1. \n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fvey3e0sw6j31kw0lmdoe.jpg)\n2. \n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvey3n6qu4j31kw0n1aju.jpg)\n3. \n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fvey3xqxwpj31kw0nntin.jpg)\n\n\n\u003ca id='code'\u003e\u003c/a\u003e\n\n## 查看代码\n\nBlogPage中定义全局状态mainColor和方法changeMainColor()并传递： \n```\nclass BlogPage extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            mainColor: 'black'\n        }\n    }\n    changeMainColor = (color) =\u003e {\n        this.setState({\n            mainColor: color\n        })\n    }\n    render() {\n        const { mainColor } = this.state;\n        return (\n            \u003cdiv className=\"blogContainer\"\u003e\n                \u003cHeader mainColor={mainColor}\u003e\u003c/Header\u003e\n                \u003cMain mainColor={mainColor} changeMainColor={this.changeMainColor}\u003e\u003c/Main\u003e\n            \u003c/div\u003e\n        );\n    }\n}\n```\nContent组件中使用props传递的数据和方法：\n```\nclass Content extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n    randomColor = () =\u003e {\n        this.props.changeMainColor('#' + (Math.random() * 0xffffff \u003c\u003c 0).toString(16));\n    }\n    render() {\n        const {mainColor}=this.props;\n        return (\n            \u003cdiv className=\"content\" style={{color:mainColor}}\u003e\n                内容...\n                \u003cdiv className=\"button\" onClick={this.randomColor}\u003e切换颜色\u003c/div\u003e\n            \u003c/div\u003e\n        );\n    }\n}\n```\n\n\n--- \n*\b本章节部分参考[React.js 小书](http://huziketang.mangojuice.top/books/react/lesson29)，在此感谢！*\n\n\n"}]}],"compeled":30},"__N_SSG":true},"page":"/","query":{},"buildId":"Ez9vbocOzqB6exjCwVDao","assetPrefix":"/docs","isFallback":false,"gsp":true}</script><script nomodule="" src="/docs/_next/static/chunks/polyfills-8683bd742a84c1edd48c.js"></script><script src="/docs/_next/static/chunks/webpack-208e2f69f0f38c7c6e8e.js" async=""></script><script src="/docs/_next/static/chunks/framework-d3984ef788efc6bd8157.js" async=""></script><script src="/docs/_next/static/chunks/597-ebe22cee24f07ec0dbde.js" async=""></script><script src="/docs/_next/static/chunks/778-1467ee0b708f5cd375c0.js" async=""></script><script src="/docs/_next/static/chunks/main-9ca82ec4d4aca520c43d.js" async=""></script><script src="/docs/_next/static/chunks/pages/_app-5560dea6b09e4f77dbca.js" async=""></script><script src="/docs/_next/static/chunks/500-9a32898805276f2ba062.js" async=""></script><script src="/docs/_next/static/chunks/pages/index-467caf0c573490ef4707.js" async=""></script><script src="/docs/_next/static/Ez9vbocOzqB6exjCwVDao/_buildManifest.js" async=""></script><script src="/docs/_next/static/Ez9vbocOzqB6exjCwVDao/_ssgManifest.js" async=""></script></body></html>